package packman

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
)

// ColorSchemeData contains the data of a color scheme
// Material Theme Builder Android Views XML file.
type ColorSchemeData struct {
	XMLName xml.Name           `xml:"resources"`
	Colors  []ColorSchemeColor `xml:",any"`
}

// ColorSchemeColor contains the data for one color
// in a [ColorSchemeData] object.
type ColorSchemeColor struct {
	XMLName xml.Name `xml:"color"`
	Name    string   `xml:"name,attr"`
	Color   string   `xml:",chardata"`
}

// IsDark returns whether the color scheme color
// is a color for dark mode. It also removes
// the Light/Dark prefix from the color's name.
// It panics if it the color is for neither light nor dark mode.
func (c *ColorSchemeColor) IsDark() bool {
	if strings.HasPrefix(c.Name, "Light") {
		c.Name = strings.TrimPrefix(c.Name, "Light")
		return false
	}
	if strings.HasPrefix(c.Name, "Dark") {
		c.Name = strings.TrimPrefix(c.Name, "Dark")
		return true
	}
	panic("(ColorSchemeColor).IsDark: color is for neither light nor dark mode")
}

// IsValid returns whether the color is a valid color
// that can be used in a color scheme.
func (c *ColorSchemeColor) IsValid() bool {
	return c.Name != "seed"
}

// Camel fixes the name of the color to
// be correctly formatted camel case
// with any prefixes removed
func (c *ColorSchemeColor) FixName() {
	c.Name = strings.TrimPrefix(c.Name, "md_theme_")
	c.Name = strcase.ToCamel(c.Name)
}

// colorSchemesPreambleData contains
// the data used for the colorSchemesPreamble template.
type colorSchemesPreambleData struct {
	Package string
	Comment string
}

// colorSchemesPreamble is the template for the information
// located at the top of the colorschemes.go file
var colorSchemesPreamble = template.Must(template.New("colorSchemesPreamble").Parse(`// Code generated by "goki colorgen"; DO NOT EDIT

package {{.Package}}

import (
	"github.com/goki/gi/gist"
)

{{.Comment}}
var ColorSchemes = gist.ColorSchemes{
	Light: gist.ColorScheme{`))

// colorSchemeDarkPreamble is the string
// located at the top of the dark color scheme
// declaration.
const colorSchemeDarkPreamble = `
	},
	Dark: gist.ColorScheme{`

// colorSchemesEnd is the string located
// at the end of the colorschemes.go file
const colorSchemesEnd = `
	},
}
`

// colorDataTmpl is the template for
// the information for one color scheme color
var colorDataTmpl = template.Must(template.New("colorData").Parse(
	`
		{{.Name}}: gist.MustColorFromHex("{{.Color}}"),`,
))

// tempCustomColors is a TEMPORARY slice of color scheme colors
// to be added into the resulting colorschemes.go file. It contains
// some of the colors that have not been added to the material theme
// builder yet. TODO: remove this once the rest of the colors are
// added to the material theme builder
// (see https://github.com/material-foundation/material-theme-builder/issues/187).
var tempCustomColors = []ColorSchemeColor{
	{Name: "Light surface dim", Color: "#DED8E1"},
	{Name: "Light surface bright", Color: "#FEF7FF"},
	{Name: "Light surface container lowest", Color: "#FFFFFF"},
	{Name: "Light surface container low", Color: "#F7F2FA"},
	{Name: "Light surface container", Color: "#F3EDF7"},
	{Name: "Light surface container high", Color: "#ECE6F0"},
	{Name: "Light surface container highest", Color: "#E6E0E9"},
}

// GenerateColorScheme generates a Go color scheme
// declaration file from a Material Theme Builder
// Android Views XML file located at the given source
// file path. It stores the resulting Go file
// at the given destination file path. The generated
// file is part of the given package and puts the
// given comment as the comment for the ColorSchemes variable.
func GenerateColorScheme(src, dst, pkg, comment string) error {
	d, err := GetColorSchemeData(src)
	if err != nil {
		return fmt.Errorf("GenerateColorScheme: error getting color scheme data: %w", err)
	}

	buf := &bytes.Buffer{}
	err = colorSchemesPreamble.Execute(buf, colorSchemesPreambleData{pkg, comment})
	if err != nil {
		return fmt.Errorf("GenerateColorScheme: error executing preamble template: %w", err)
	}
	// whether we have switched over to dark colors yet
	onDark := false
	for _, c := range d.Colors {
		if !c.IsValid() {
			continue
		}
		c.FixName()
		if c.IsDark() && !onDark {
			buf.WriteString(colorSchemeDarkPreamble)
			onDark = true
		}
		err := colorDataTmpl.Execute(buf, c)
		if err != nil {
			return fmt.Errorf("GenerateColorScheme: error executing color data template: %w", err)
		}
	}
	buf.WriteString(colorSchemesEnd)
	err = os.WriteFile(dst, buf.Bytes(), 0666)
	if err != nil {
		return fmt.Errorf("GenerateColorSchemes: error writing result to file: %w", err)
	}
	return nil
}

// GetColorSchemeData gets the [ColorSchemeData] from
// the XML file located at the given filepath.
func GetColorSchemeData(fpath string) (ColorSchemeData, error) {
	b, err := os.ReadFile(fpath)
	if err != nil {
		return ColorSchemeData{}, fmt.Errorf("GetColorSchemeData: error loading file %s: %w", fpath, err)
	}
	v := ColorSchemeData{}
	err = xml.Unmarshal(b, &v)
	if err != nil {
		return ColorSchemeData{}, fmt.Errorf("GetColorSchemeData: error unmarshalling file data: %w", err)
	}
	return v, nil
}
