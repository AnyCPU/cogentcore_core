// Copyright (c) 2018, The GoKi Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gi

import (
	"strings"
	"unicode"
)

// Completer is an implementation of completion for debugging - there will be a real code completer
// that understands golang
////////////////////////////////////////////////////////////////////////////////////////

// Completer is an interface to be implemented for code completion.
type Completer interface {
	// Matches uses the seed to pare down the list of possible completions
	Matches(completions []string, seed string)

	// Count returns the number of matches
	Count() int

	// Seed returns the current seed
	Seed() string

	// Match returns the match at index
	Match(index int) string

	// Extend tries to extend the current seed checking possible completions for a longer common seed
	// e.g. if the current seed is "ab" and the completions are "abcde" and "abcdf" then Extend returns "cd"
	// but if the possible completions are "abcde" and "abz" then Extend returns ""
	Extend() string
}

// CompletionFunc is the function that acts as callback to get the list of possible completion
// and also determines the correct seed based on the text passed as a parameter of CompletionFunc
type CompletionFunc func(text string) (list []string, seed string)

////////////////////////////////////////////////////////////////////////////////////////
// BaseCompleter
type BaseCompleter struct {
	seed           string // the portion of the text from which completions are generated
	completions    []string
	matches        []string
	completionFunc func() []string // function to get the list of possible matches if not generated by the completer itself

}

////////////////////////////////////////////////////////////////////////////////////////
// BasicCompleter
type BasicCompleter struct {
	BaseCompleter
}

func (sc *BasicCompleter) Matches(completions []string, seed string) {
	sc.completions = completions
	sc.seed = seed

	sc.matches = sc.completions[0:0]
	match_start := -1
	match_end := -1
	if len(sc.seed) > 0 {
		for i, s := range sc.completions {
			if match_end > -1 {
				break
			}
			if match_start == -1 {
				if strings.HasPrefix(s, sc.seed) {
					match_start = i // first match in sorted list
				}
				continue
			}
			if match_start > -1 {
				if strings.HasPrefix(s, sc.seed) == false {
					match_end = i
				}
			}
		}
		if match_start > -1 && match_end == -1 { // everything possible was a match!
			match_end = len(sc.completions)
		}
	}

	//fmt.Printf("match start: %d, match_end: %d", match_start, match_end)
	if match_start > -1 && match_end > -1 {
		sc.matches = sc.completions[match_start:match_end]
	}
}

func (sc *BasicCompleter) Count() int {
	return len(sc.matches)
}

func (sc *BasicCompleter) Seed() string {
	return sc.seed
}

func (sc *BasicCompleter) Match(index int) string {
	return sc.matches[index]
}

func (sc *BasicCompleter) Extend() string {
	keep_looking := true
	new_seed := sc.seed
	potential_seed := new_seed
	first_match := sc.matches[0]
	for keep_looking {
		if len(first_match) <= len(new_seed) {
			keep_looking = false // ran out of chars
			break
		}

		potential_seed = first_match[0 : len(new_seed)+1]
		for _, s := range sc.matches {
			if !strings.HasPrefix(s, potential_seed) {
				keep_looking = false
				break
			}
		}
		if keep_looking {
			new_seed = potential_seed
		}
	}
	return strings.Replace(new_seed, sc.seed, "", 1) // only return the seed extension
}

// SeedWhiteSpace returns the text after the last whitespace
func SeedWhiteSpace(text string) string {
	seedStart := 0
	for i := len(text) - 1; i >= 0; i-- {
		r := rune(text[i])
		if unicode.IsSpace(r) {
			seedStart = i + 1
			break
		}
	}
	return text[seedStart:]
}

