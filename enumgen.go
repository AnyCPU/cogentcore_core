// Code generated by "enumgen"; DO NOT EDIT.

package grog

import (
	"errors"
	"strconv"
	"strings"

	"goki.dev/enums"
)

var _LevelValues = []Level{-4, 0, 4, 8}

// LevelN is the highest valid value
// for type Level, plus one.
const LevelN Level = 9

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LevelNoOp() {
	var x [1]struct{}
	_ = x[Debug-(-4)]
	_ = x[Info-(0)]
	_ = x[Warn-(4)]
	_ = x[Error-(8)]
}

var _LevelNameToValueMap = map[string]Level{
	`Debug`: -4,
	`debug`: -4,
	`Info`:  0,
	`info`:  0,
	`Warn`:  4,
	`warn`:  4,
	`Error`: 8,
	`error`: 8,
}

var _LevelDescMap = map[Level]string{
	-4: `Debug indicates that a message is a debugging message, or to show all messages in the context of debugging. It can be set by the end user as the value of [UserLevel] through the &#34;-vv&#34; (very verbose) flag in xe.`,
	0:  `Info indicates that a message is an informational message, or to show all messages at or above the info level. It can be set by the end user as the value of [UserLevel] through the &#34;-v&#34; (verbose) flag in xe.`,
	4:  `Warn indicates that a message is a warning message, or to show all messages at or above the warning level. It is the default value for [UserLevel].`,
	8:  `Error indicates that a message is an error message, or to only show error messages. It can be set by the end user as the value of [UserLevel] through the &#34;-q&#34; (quiet) flag in xe.`,
}

var _LevelMap = map[Level]string{
	-4: `Debug`,
	0:  `Info`,
	4:  `Warn`,
	8:  `Error`,
}

// String returns the string representation
// of this Level value.
func (i Level) String() string {
	if str, ok := _LevelMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Level value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Level) SetString(s string) error {
	if val, ok := _LevelNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LevelNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Level")
}

// Int64 returns the Level value as an int64.
func (i Level) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Level value from an int64.
func (i *Level) SetInt64(in int64) {
	*i = Level(in)
}

// Desc returns the description of the Level value.
func (i Level) Desc() string {
	if str, ok := _LevelDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LevelValues returns all possible values
// for the type Level.
func LevelValues() []Level {
	return _LevelValues
}

// Values returns all possible values
// for the type Level.
func (i Level) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LevelValues))
	for i, d := range _LevelValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Level.
func (i Level) IsValid() bool {
	_, ok := _LevelMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Level) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Level) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
