// Code generated by "goki generate"; DO NOT EDIT.

package ki

import (
	"errors"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

const _FlagsName = "IsFieldHasKiFieldsHasNoKiFieldsUpdatingOnlySelfUpdateNodeDeletedNodeDestroyedChildAddedChildDeletedChildrenDeletedValUpdated"

var _FlagsIndex = [...]uint8{0, 7, 18, 31, 39, 53, 64, 77, 87, 99, 114, 124}

const _FlagsLowerName = "isfieldhaskifieldshasnokifieldsupdatingonlyselfupdatenodedeletednodedestroyedchildaddedchilddeletedchildrendeletedvalupdated"

// String returns the string representation
// of this Flags value.
func (i Flags) String() string {
	if !(i < 0 || i >= Flags(len(_FlagsIndex)-1)) {
		return _FlagsName[_FlagsIndex[i]:_FlagsIndex[i+1]]
	}
	str := ""
	for _, ie := range _FlagsValues {
		if i.HasFlag(&ie) {
			ies := ie.String()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FlagsNoOp() {
	var x [1]struct{}
	_ = x[IsField-(0)]
	_ = x[HasKiFields-(1)]
	_ = x[HasNoKiFields-(2)]
	_ = x[Updating-(3)]
	_ = x[OnlySelfUpdate-(4)]
	_ = x[NodeDeleted-(5)]
	_ = x[NodeDestroyed-(6)]
	_ = x[ChildAdded-(7)]
	_ = x[ChildDeleted-(8)]
	_ = x[ChildrenDeleted-(9)]
	_ = x[ValUpdated-(10)]
}

var _FlagsValues = []Flags{IsField, HasKiFields, HasNoKiFields, Updating, OnlySelfUpdate, NodeDeleted, NodeDestroyed, ChildAdded, ChildDeleted, ChildrenDeleted, ValUpdated}

// FlagsN is the highest valid value
// for type Flags, plus one.
const FlagsN Flags = 11

var _FlagsNameToValueMap = map[string]Flags{
	_FlagsName[0:7]:          IsField,
	_FlagsLowerName[0:7]:     IsField,
	_FlagsName[7:18]:         HasKiFields,
	_FlagsLowerName[7:18]:    HasKiFields,
	_FlagsName[18:31]:        HasNoKiFields,
	_FlagsLowerName[18:31]:   HasNoKiFields,
	_FlagsName[31:39]:        Updating,
	_FlagsLowerName[31:39]:   Updating,
	_FlagsName[39:53]:        OnlySelfUpdate,
	_FlagsLowerName[39:53]:   OnlySelfUpdate,
	_FlagsName[53:64]:        NodeDeleted,
	_FlagsLowerName[53:64]:   NodeDeleted,
	_FlagsName[64:77]:        NodeDestroyed,
	_FlagsLowerName[64:77]:   NodeDestroyed,
	_FlagsName[77:87]:        ChildAdded,
	_FlagsLowerName[77:87]:   ChildAdded,
	_FlagsName[87:99]:        ChildDeleted,
	_FlagsLowerName[87:99]:   ChildDeleted,
	_FlagsName[99:114]:       ChildrenDeleted,
	_FlagsLowerName[99:114]:  ChildrenDeleted,
	_FlagsName[114:124]:      ValUpdated,
	_FlagsLowerName[114:124]: ValUpdated,
}

var _FlagsNames = []string{
	_FlagsName[0:7],
	_FlagsName[7:18],
	_FlagsName[18:31],
	_FlagsName[31:39],
	_FlagsName[39:53],
	_FlagsName[53:64],
	_FlagsName[64:77],
	_FlagsName[77:87],
	_FlagsName[87:99],
	_FlagsName[99:114],
	_FlagsName[114:124],
}

var _FlagsDescMap = map[Flags]string{
	0:  _FlagsDescs[0],
	1:  _FlagsDescs[1],
	2:  _FlagsDescs[2],
	3:  _FlagsDescs[3],
	4:  _FlagsDescs[4],
	5:  _FlagsDescs[5],
	6:  _FlagsDescs[6],
	7:  _FlagsDescs[7],
	8:  _FlagsDescs[8],
	9:  _FlagsDescs[9],
	10: _FlagsDescs[10],
}

var _FlagsDescs = []string{
	`IsField indicates a node is a field in its parent node, not a child in children.`,
	`HasKiFields indicates a node has Ki Node fields that will be processed in recursive descent. Use the HasFields() method to check as it will establish validity of flags on first call. If neither HasFields nor HasNoFields are set, then it knows to update flags.`,
	`HasNoKiFields indicates a node has NO Ki Node fields that will be processed in recursive descent. Use the HasFields() method to check as it will establish validity of flags on first call. If neither HasFields nor HasNoFields are set, then it knows to update flags.`,
	`Updating flag is set at UpdateStart and cleared if we were the first updater at UpdateEnd.`,
	`OnlySelfUpdate means that the UpdateStart / End logic only applies to this node in isolation, not to its children -- useful for a parent node that has a different functional role than its children.`,
	`NodeDeleted means this node has been deleted.`,
	`NodeDestroyed means this node has been destroyed -- do not trigger any more update signals on it.`,
	`ChildAdded means one or more new children were added to the node.`,
	`ChildDeleted means one or more children were deleted from the node.`,
	`ChildrenDeleted means all children were deleted.`,
	`ValUpdated means a value was updated (Field, Prop, any kind of value)`,
}

// SetString sets the Flags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Flags) SetString(s string) error {
	*i = 0
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _FlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _FlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type Flags")
		}
	}
	return nil
}

// Int64 returns the Flags value as an int64.
func (i Flags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Flags value from an int64.
func (i *Flags) SetInt64(in int64) {
	*i = Flags(in)
}

// Desc returns the description of the Flags value.
func (i Flags) Desc() string {
	if str, ok := _FlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FlagsValues returns all possible values of
// the type Flags. This slice will be in the
// same order as those returned by the Values,
// Strings, and Descs methods on Flags.
func FlagsValues() []Flags {
	return _FlagsValues
}

// Values returns all possible values of
// type Flags. This slice will be in the
// same order as those returned by Strings and Descs.
func (i Flags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FlagsValues))
	for i, d := range _FlagsValues {
		res[i] = d
	}
	return res
}

// Strings returns the string representations of
// all possible values of type Flags.
// This slice will be in the same order as
// those returned by Values and Descs.
func (i Flags) Strings() []string {
	return _FlagsNames
}

// Descs returns the descriptions of all
// possible values of type Flags.
// This slice will be in the same order as
// those returned by Values and Strings.
func (i Flags) Descs() []string {
	return _FlagsDescs
}

// IsValid returns whether the value is a
// valid option for type Flags.
func (i Flags) IsValid() bool {
	for _, v := range _FlagsValues {
		if i == v {
			return true
		}
	}
	return false
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i Flags) HasFlag(f enums.BitFlag) bool {
	return i&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *Flags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Flags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Flags) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

const _NodeSignalsName = "NodeSignalNilNodeSignalUpdatedNodeSignalDeleting"

var _NodeSignalsIndex = [...]uint8{0, 13, 30, 48}

const _NodeSignalsLowerName = "nodesignalnilnodesignalupdatednodesignaldeleting"

// String returns the string representation
// of this NodeSignals value.
func (i NodeSignals) String() string {
	if !(i < 0 || i >= NodeSignals(len(_NodeSignalsIndex)-1)) {
		return _NodeSignalsName[_NodeSignalsIndex[i]:_NodeSignalsIndex[i+1]]
	}
	str := ""
	for _, ie := range _NodeSignalsValues {
		if i.HasFlag(&ie) {
			ies := ie.String()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _NodeSignalsNoOp() {
	var x [1]struct{}
	_ = x[NodeSignalNil-(0)]
	_ = x[NodeSignalUpdated-(1)]
	_ = x[NodeSignalDeleting-(2)]
}

var _NodeSignalsValues = []NodeSignals{NodeSignalNil, NodeSignalUpdated, NodeSignalDeleting}

// NodeSignalsN is the highest valid value
// for type NodeSignals, plus one.
const NodeSignalsN NodeSignals = 3

var _NodeSignalsNameToValueMap = map[string]NodeSignals{
	_NodeSignalsName[0:13]:       NodeSignalNil,
	_NodeSignalsLowerName[0:13]:  NodeSignalNil,
	_NodeSignalsName[13:30]:      NodeSignalUpdated,
	_NodeSignalsLowerName[13:30]: NodeSignalUpdated,
	_NodeSignalsName[30:48]:      NodeSignalDeleting,
	_NodeSignalsLowerName[30:48]: NodeSignalDeleting,
}

var _NodeSignalsNames = []string{
	_NodeSignalsName[0:13],
	_NodeSignalsName[13:30],
	_NodeSignalsName[30:48],
}

var _NodeSignalsDescMap = map[NodeSignals]string{
	0: _NodeSignalsDescs[0],
	1: _NodeSignalsDescs[1],
	2: _NodeSignalsDescs[2],
}

var _NodeSignalsDescs = []string{
	`NodeSignalNil is a nil signal value`,
	`NodeSignalUpdated indicates that the node was updated -- the node Flags accumulate the specific changes made since the last update signal -- these flags are sent in the signal data -- strongly recommend using that instead of the flags, which can be subsequently updated by the time a signal is processed`,
	`NodeSignalDeleting indicates that the node is being deleted from its parent children list -- this is not blocked by Updating status and is delivered immediately. No further notifications are sent -- assume it will be destroyed unless you hear from it again.`,
}

// SetString sets the NodeSignals value from its
// string representation, and returns an
// error if the string is invalid.
func (i *NodeSignals) SetString(s string) error {
	*i = 0
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _NodeSignalsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _NodeSignalsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type NodeSignals")
		}
	}
	return nil
}

// Int64 returns the NodeSignals value as an int64.
func (i NodeSignals) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the NodeSignals value from an int64.
func (i *NodeSignals) SetInt64(in int64) {
	*i = NodeSignals(in)
}

// Desc returns the description of the NodeSignals value.
func (i NodeSignals) Desc() string {
	if str, ok := _NodeSignalsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// NodeSignalsValues returns all possible values of
// the type NodeSignals. This slice will be in the
// same order as those returned by the Values,
// Strings, and Descs methods on NodeSignals.
func NodeSignalsValues() []NodeSignals {
	return _NodeSignalsValues
}

// Values returns all possible values of
// type NodeSignals. This slice will be in the
// same order as those returned by Strings and Descs.
func (i NodeSignals) Values() []enums.Enum {
	res := make([]enums.Enum, len(_NodeSignalsValues))
	for i, d := range _NodeSignalsValues {
		res[i] = d
	}
	return res
}

// Strings returns the string representations of
// all possible values of type NodeSignals.
// This slice will be in the same order as
// those returned by Values and Descs.
func (i NodeSignals) Strings() []string {
	return _NodeSignalsNames
}

// Descs returns the descriptions of all
// possible values of type NodeSignals.
// This slice will be in the same order as
// those returned by Values and Strings.
func (i NodeSignals) Descs() []string {
	return _NodeSignalsDescs
}

// IsValid returns whether the value is a
// valid option for type NodeSignals.
func (i NodeSignals) IsValid() bool {
	for _, v := range _NodeSignalsValues {
		if i == v {
			return true
		}
	}
	return false
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i NodeSignals) HasFlag(f enums.BitFlag) bool {
	return i&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *NodeSignals) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i NodeSignals) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *NodeSignals) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
