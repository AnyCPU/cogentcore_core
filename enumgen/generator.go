// Copyright (c) 2023, The GoKi Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Based on http://github.com/dmarkham/enumer and
// golang.org/x/tools/cmd/stringer:

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package enumgen

import (
	"bytes"
	"fmt"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

// Generator holds the state of the generator.
// It is primarily used to buffer
// the output for [format.Source].
type Generator struct {
	Config Config       // The configuration information
	Buf    bytes.Buffer // The accumulated output.
	Pkg    *Package     // The package we are scanning.
}

// NewGenerator returns a new generator with the
// given configuration information.
func NewGenerator(config Config) *Generator {
	return &Generator{Config: config}
}

// ParsePackage parses the single package located in the configuration directory.
func (g *Generator) ParsePackage() error {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedSyntax | packages.NeedTypesInfo,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, g.Config.Dir)
	if err != nil {
		return err
	}
	if len(pkgs) != 1 {
		return fmt.Errorf("expected 1 package, but found %d packages", len(pkgs))
	}
	g.AddPackage(pkgs[0])
	return nil
}

// AddPackage adds a type-checked Package and its syntax files to the generator.
func (g *Generator) AddPackage(pkg *packages.Package) {
	g.Pkg = &Package{
		Name:  pkg.Name,
		Defs:  pkg.TypesInfo.Defs,
		Files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.Pkg.Files[i] = &File{
			file: file,
			pkg:  g.Pkg,
		}
	}
}

// Printf prints the formatted string to the
// accumulated output in [Generator.Buf]
func (g *Generator) Printf(format string, args ...any) {
	fmt.Fprintf(&g.Buf, format, args...)
}

// PrintHeader prints the header and package clause
// to the accumulated output
func (g *Generator) PrintHeader() {
	g.Printf("// Code generated by \"enumgen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	if g.Config.Comment != "" {
		g.Printf("// %s\n", g.Config.Comment)
	}
	g.Printf("package %s", g.Pkg.Name)
	g.Printf("\n")
	g.Printf("import (\n")
	g.Printf("\t\"fmt\"\n")
	g.Printf("\t\"strings\"\n")
	if g.Config.SQL {
		g.Printf("\t\"database/sql/driver\"\n")
	}
	if g.Config.JSON {
		g.Printf("\t\"encoding/json\"\n")
	}
	if g.Config.GQLGEN {
		g.Printf("\t\"io\"\n")
		g.Printf("\t\"strconv\"\n")
	}
	g.Printf(")\n")
}
