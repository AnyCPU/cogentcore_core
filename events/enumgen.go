// Code generated by "enumgen"; DO NOT EDIT.

package events

import (
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _DropModsValues = []DropMods{0, 1, 2, 3, 4}

// DropModsN is the highest valid value
// for type DropMods, plus one.
const DropModsN DropMods = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _DropModsNoOp() {
	var x [1]struct{}
	_ = x[NoDropMod-(0)]
	_ = x[DropCopy-(1)]
	_ = x[DropMove-(2)]
	_ = x[DropLink-(3)]
	_ = x[DropIgnore-(4)]
}

var _DropModsNameToValueMap = map[string]DropMods{
	`NoDropMod`: 0,
	`nodropmod`: 0,
	`Copy`:      1,
	`copy`:      1,
	`Move`:      2,
	`move`:      2,
	`Link`:      3,
	`link`:      3,
	`Ignore`:    4,
	`ignore`:    4,
}

var _DropModsDescMap = map[DropMods]string{
	0: ``,
	1: `Copy is the default and implies data is just copied -- receiver can do with it as they please and source does not need to take any further action`,
	2: `Move is signaled with a Shift or Meta key (by default) and implies that the source should delete itself when it receives the DropFmSource event action with this Mod value set -- receiver must update the Mod to reflect actual action taken, and be particularly careful with this one`,
	3: `Link can be any other kind of alternative action -- link is applicable to files (symbolic link)`,
	4: `Ignore means that the receiver chose to not process this drop`,
}

var _DropModsMap = map[DropMods]string{
	0: `NoDropMod`,
	1: `Copy`,
	2: `Move`,
	3: `Link`,
	4: `Ignore`,
}

// String returns the string representation
// of this DropMods value.
func (i DropMods) String() string {
	if str, ok := _DropModsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the DropMods value from its
// string representation, and returns an
// error if the string is invalid.
func (i *DropMods) SetString(s string) error {
	if val, ok := _DropModsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _DropModsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type DropMods")
}

// Int64 returns the DropMods value as an int64.
func (i DropMods) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the DropMods value from an int64.
func (i *DropMods) SetInt64(in int64) {
	*i = DropMods(in)
}

// Desc returns the description of the DropMods value.
func (i DropMods) Desc() string {
	if str, ok := _DropModsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// DropModsValues returns all possible values
// for the type DropMods.
func DropModsValues() []DropMods {
	return _DropModsValues
}

// Values returns all possible values
// for the type DropMods.
func (i DropMods) Values() []enums.Enum {
	res := make([]enums.Enum, len(_DropModsValues))
	for i, d := range _DropModsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type DropMods.
func (i DropMods) IsValid() bool {
	_, ok := _DropModsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DropMods) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DropMods) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _ButtonsValues = []Buttons{0, 1, 2, 3}

// ButtonsN is the highest valid value
// for type Buttons, plus one.
const ButtonsN Buttons = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _ButtonsNoOp() {
	var x [1]struct{}
	_ = x[NoButton-(0)]
	_ = x[Left-(1)]
	_ = x[Middle-(2)]
	_ = x[Right-(3)]
}

var _ButtonsNameToValueMap = map[string]Buttons{
	`NoButton`: 0,
	`nobutton`: 0,
	`Left`:     1,
	`left`:     1,
	`Middle`:   2,
	`middle`:   2,
	`Right`:    3,
	`right`:    3,
}

var _ButtonsDescMap = map[Buttons]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

var _ButtonsMap = map[Buttons]string{
	0: `NoButton`,
	1: `Left`,
	2: `Middle`,
	3: `Right`,
}

// String returns the string representation
// of this Buttons value.
func (i Buttons) String() string {
	if str, ok := _ButtonsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Buttons value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Buttons) SetString(s string) error {
	if val, ok := _ButtonsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _ButtonsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Buttons")
}

// Int64 returns the Buttons value as an int64.
func (i Buttons) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Buttons value from an int64.
func (i *Buttons) SetInt64(in int64) {
	*i = Buttons(in)
}

// Desc returns the description of the Buttons value.
func (i Buttons) Desc() string {
	if str, ok := _ButtonsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// ButtonsValues returns all possible values
// for the type Buttons.
func ButtonsValues() []Buttons {
	return _ButtonsValues
}

// Values returns all possible values
// for the type Buttons.
func (i Buttons) Values() []enums.Enum {
	res := make([]enums.Enum, len(_ButtonsValues))
	for i, d := range _ButtonsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Buttons.
func (i Buttons) IsValid() bool {
	_, ok := _ButtonsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Buttons) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Buttons) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _SelectModesValues = []SelectModes{0, 1, 2, 3, 4, 5, 6}

// SelectModesN is the highest valid value
// for type SelectModes, plus one.
const SelectModesN SelectModes = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SelectModesNoOp() {
	var x [1]struct{}
	_ = x[SelectOne-(0)]
	_ = x[ExtendContinuous-(1)]
	_ = x[ExtendOne-(2)]
	_ = x[NoSelect-(3)]
	_ = x[Unselect-(4)]
	_ = x[SelectQuiet-(5)]
	_ = x[UnselectQuiet-(6)]
}

var _SelectModesNameToValueMap = map[string]SelectModes{
	`SelectOne`:        0,
	`selectone`:        0,
	`ExtendContinuous`: 1,
	`extendcontinuous`: 1,
	`ExtendOne`:        2,
	`extendone`:        2,
	`NoSelect`:         3,
	`noselect`:         3,
	`Unselect`:         4,
	`unselect`:         4,
	`SelectQuiet`:      5,
	`selectquiet`:      5,
	`UnselectQuiet`:    6,
	`unselectquiet`:    6,
}

var _SelectModesDescMap = map[SelectModes]string{
	0: `SelectOne selects a single item, and is the default when no modifier key is pressed`,
	1: `ExtendContinuous, activated by Shift key, extends the selection to select a continuous region of selected items, with no gaps`,
	2: `ExtendOne, activated by Control or Meta / Command, extends the selection by adding the one additional item just clicked on, creating a potentially discontinuous set of selected items`,
	3: `NoSelect means do not update selection -- this is used programmatically and not available via modifier key`,
	4: `Unselect means unselect items -- this is used programmatically and not available via modifier key -- typically ExtendOne will unselect if already selected`,
	5: `SelectQuiet means select without doing other updates or signals -- for bulk updates with a final update at the end -- used programmatically`,
	6: `UnselectQuiet means unselect without doing other updates or signals -- for bulk updates with a final update at the end -- used programmatically`,
}

var _SelectModesMap = map[SelectModes]string{
	0: `SelectOne`,
	1: `ExtendContinuous`,
	2: `ExtendOne`,
	3: `NoSelect`,
	4: `Unselect`,
	5: `SelectQuiet`,
	6: `UnselectQuiet`,
}

// String returns the string representation
// of this SelectModes value.
func (i SelectModes) String() string {
	if str, ok := _SelectModesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SelectModes value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SelectModes) SetString(s string) error {
	if val, ok := _SelectModesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SelectModesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type SelectModes")
}

// Int64 returns the SelectModes value as an int64.
func (i SelectModes) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SelectModes value from an int64.
func (i *SelectModes) SetInt64(in int64) {
	*i = SelectModes(in)
}

// Desc returns the description of the SelectModes value.
func (i SelectModes) Desc() string {
	if str, ok := _SelectModesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SelectModesValues returns all possible values
// for the type SelectModes.
func SelectModesValues() []SelectModes {
	return _SelectModesValues
}

// Values returns all possible values
// for the type SelectModes.
func (i SelectModes) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SelectModesValues))
	for i, d := range _SelectModesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SelectModes.
func (i SelectModes) IsValid() bool {
	_, ok := _SelectModesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SelectModes) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SelectModes) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _TypesValues = []Types{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43}

// TypesN is the highest valid value
// for type Types, plus one.
const TypesN Types = 44

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TypesNoOp() {
	var x [1]struct{}
	_ = x[UnknownType-(0)]
	_ = x[MouseDown-(1)]
	_ = x[MouseUp-(2)]
	_ = x[MouseMove-(3)]
	_ = x[MouseDrag-(4)]
	_ = x[Click-(5)]
	_ = x[DoubleClick-(6)]
	_ = x[ContextMenu-(7)]
	_ = x[LongPressStart-(8)]
	_ = x[LongPressEnd-(9)]
	_ = x[MouseEnter-(10)]
	_ = x[MouseLeave-(11)]
	_ = x[LongHoverStart-(12)]
	_ = x[LongHoverEnd-(13)]
	_ = x[DragStart-(14)]
	_ = x[Drop-(15)]
	_ = x[DragMove-(16)]
	_ = x[DragEnter-(17)]
	_ = x[DragLeave-(18)]
	_ = x[SlideStart-(19)]
	_ = x[SlideMove-(20)]
	_ = x[SlideStop-(21)]
	_ = x[Scroll-(22)]
	_ = x[KeyDown-(23)]
	_ = x[KeyUp-(24)]
	_ = x[KeyChord-(25)]
	_ = x[TouchStart-(26)]
	_ = x[TouchEnd-(27)]
	_ = x[TouchMove-(28)]
	_ = x[Magnify-(29)]
	_ = x[Rotate-(30)]
	_ = x[Select-(31)]
	_ = x[Focus-(32)]
	_ = x[FocusLost-(33)]
	_ = x[Change-(34)]
	_ = x[Input-(35)]
	_ = x[Show-(36)]
	_ = x[Close-(37)]
	_ = x[Window-(38)]
	_ = x[WindowResize-(39)]
	_ = x[WindowPaint-(40)]
	_ = x[OS-(41)]
	_ = x[OSOpenFiles-(42)]
	_ = x[Custom-(43)]
}

var _TypesNameToValueMap = map[string]Types{
	`UnknownType`:    0,
	`unknowntype`:    0,
	`MouseDown`:      1,
	`mousedown`:      1,
	`MouseUp`:        2,
	`mouseup`:        2,
	`MouseMove`:      3,
	`mousemove`:      3,
	`MouseDrag`:      4,
	`mousedrag`:      4,
	`Click`:          5,
	`click`:          5,
	`DoubleClick`:    6,
	`doubleclick`:    6,
	`ContextMenu`:    7,
	`contextmenu`:    7,
	`LongPressStart`: 8,
	`longpressstart`: 8,
	`LongPressEnd`:   9,
	`longpressend`:   9,
	`MouseEnter`:     10,
	`mouseenter`:     10,
	`MouseLeave`:     11,
	`mouseleave`:     11,
	`LongHoverStart`: 12,
	`longhoverstart`: 12,
	`LongHoverEnd`:   13,
	`longhoverend`:   13,
	`DragStart`:      14,
	`dragstart`:      14,
	`Drop`:           15,
	`drop`:           15,
	`DragMove`:       16,
	`dragmove`:       16,
	`DragEnter`:      17,
	`dragenter`:      17,
	`DragLeave`:      18,
	`dragleave`:      18,
	`SlideStart`:     19,
	`slidestart`:     19,
	`SlideMove`:      20,
	`slidemove`:      20,
	`SlideStop`:      21,
	`slidestop`:      21,
	`Scroll`:         22,
	`scroll`:         22,
	`KeyDown`:        23,
	`keydown`:        23,
	`KeyUp`:          24,
	`keyup`:          24,
	`KeyChord`:       25,
	`keychord`:       25,
	`TouchStart`:     26,
	`touchstart`:     26,
	`TouchEnd`:       27,
	`touchend`:       27,
	`TouchMove`:      28,
	`touchmove`:      28,
	`Magnify`:        29,
	`magnify`:        29,
	`Rotate`:         30,
	`rotate`:         30,
	`Select`:         31,
	`select`:         31,
	`Focus`:          32,
	`focus`:          32,
	`FocusLost`:      33,
	`focuslost`:      33,
	`Change`:         34,
	`change`:         34,
	`Input`:          35,
	`input`:          35,
	`Show`:           36,
	`show`:           36,
	`Close`:          37,
	`close`:          37,
	`Window`:         38,
	`window`:         38,
	`WindowResize`:   39,
	`windowresize`:   39,
	`WindowPaint`:    40,
	`windowpaint`:    40,
	`OS`:             41,
	`os`:             41,
	`OSOpenFiles`:    42,
	`osopenfiles`:    42,
	`Custom`:         43,
	`custom`:         43,
}

var _TypesDescMap = map[Types]string{
	0:  `zero value is an unknown type`,
	1:  `MouseDown happens when a mouse button is pressed down. See MouseButton() for which. See Click for a synthetic event representing a MouseDown followed by MouseUp on the same element with Left (primary) mouse button. Often that is the most useful.`,
	2:  `MouseUp happens when a mouse button is released. See MouseButton() for which.`,
	3:  `MouseMove is always sent when the mouse is moving but no button is down, even if there might be other higher-level events too. These can be numerous and thus it is typically more efficient to listen to other events derived from this. Not unique, and Prev position is updated during compression.`,
	4:  `MouseDrag is always sent when the mouse is moving and there is a button down, even if there might be other higher-level events too. The start pos indicates where (and when) button first was pressed. Not unique and Prev position is updated during compression.`,
	5:  `Click represents a MouseDown followed by MouseUp in sequence on the same element, with the Left (primary) button. This is the typical event for most basic user interaction.`,
	6:  `DoubleClick represents two Click events in a row in rapid succession.`,
	7:  `ContextMenu represents a MouseDown/Up event with the Right mouse button (which is also activated by Control key + Left Click).`,
	8:  `LongPressStart is when the mouse has been relatively stable after MouseDown on an element for a minimum duration (500 msec default).`,
	9:  `LongPressEnd is sent after LongPressStart when the mouse has gone up, moved sufficiently, left the current element, or another input event has happened.`,
	10: `MouseEnter is when the mouse enters the bounding box of a new element. It is used for setting the Hover state, and can trigger cursor changes. See DragEnter for alternative case during Drag events.`,
	11: `MouseLeave is when the mouse leaves the bounding box of an element, that previously had a MouseEnter event. Given that elements can have overlapping bounding boxes (e.g., child elements within a container), it is not the case that a MouseEnter on a child triggers a MouseLeave on surrounding containers. See DragLeave for alternative case during Drag events.`,
	12: `LongHoverStart is when the mouse has been relatively stable after MouseEnter on an element for a minimum duration (500 msec default). This triggers the LongHover state typically used for Tooltips.`,
	13: `LongHoverEnd is after LongHoverStart when the mouse has moved sufficiently, left the current element, or another input event has happened, thereby terminating the LongHover state.`,
	14: `DragStart is at the start of a drag-n-drop event sequence, when a Draggable element is Active and a sufficient distance of MouseDrag events has occurred to engage the DragStart event.`,
	15: `Drop is the final action of the drag-n-drop sequence, when an item being Dragged is dropped on top of a target element. This is also triggered with a nil target if the Escape key is pressed while dragging. The target will also be nil if the target does not have the DropOK state active.`,
	16: `DragMove is for a MouseDrag event during the drag-n-drop sequence. Usually don&#39;t need to listen to this one. MouseDrag is also sent.`,
	17: `DragEnter is like MouseEnter but after a DragStart during a drag-n-drop sequence. MouseEnter is not sent in this case.`,
	18: `DragLeave is like MouseLeave but after a DragStart during a drag-n-drop sequence. MouseLeave is not sent in this case.`,
	19: `SlideStart is for a Slideable element when Active and a sufficient distance of MouseDrag events has occurred to engage the SlideStart event. Sets the Sliding state.`,
	20: `SlideMove is for a Slideable element after SlideStart is being dragged via MouseDrag events.`,
	21: `SlideStop is when the mouse button is released on a Slideable element being dragged via MouseDrag events. This typically also accompanied by a Changed event for the new slider value.`,
	22: `Scroll is for scroll wheel or other scrolling events (gestures). These are not unique and Delta is updated during compression.`,
	23: `KeyDown is when a key is pressed down. This provides fine-grained data about each key as it happens. KeyChord is recommended for a more complete Key event.`,
	24: `KeyUp is when a key is released. This provides fine-grained data about each key as it happens. KeyChord is recommended for a more complete Key event.`,
	25: `KeyChord is only generated when a non-modifier key is released, and it also contains a string representation of the full chord, suitable for translation into keyboard commands, emacs-style etc. It can be somewhat delayed relative to the KeyUp.`,
	26: `TouchStart is when a touch event starts, for the low-level touch event processing. TouchStart also activates MouseDown, Scroll, Magnify, or Rotate events depending on gesture recognition.`,
	27: `TouchEnd is when a touch event ends, for the low-level touch event processing. TouchEnd also activates MouseUp events depending on gesture recognition.`,
	28: `TouchMove is when a touch event moves, for the low-level touch event processing. TouchMove also activates MouseMove, Scroll, Magnify, or Rotate events depending on gesture recognition.`,
	29: `Magnify is a touch-based magnify event (e.g., pinch)`,
	30: `Rotate is a touch-based rotate event.`,
	31: `Select is sent for any direction of selection change on (or within if relevant) a Selectable element. Typically need to query the element(s) to determine current selection state.`,
	32: `Focus is sent when Focsable element receives Focus`,
	33: `FocusLost is sent when Focsable element loses Focus`,
	34: `Change is when a value represented by the element has been changed by the user and committed (for example, someone has typed text in a textfield and then pressed enter). This is *not* triggered when the value has not been committed; see [Input] for that. This is for Editable, Checkable, and Slidable items.`,
	35: `Input is when a value represented by the element has changed, but has not necessarily been committed (for example, this triggers each time someone presses a key in a text field). This *is* triggered when the value has not been committed; see [Change] for a version that only occurs when the value is committed. This is for Editable, Checkable, and Slidable items.`,
	36: `Show is generated by an overall Scene or Window level container when the content is first shown to the user in its final form. Listening to this event enables other elements to perform initial one-time activities on startup, in the context of a fully rendered display.`,
	37: `Close is generated by an overall Scene or Window level container when being closed (e.g., on dialog closing). This is an opportunity to save unsaved edits, for example.`,
	38: `Window reports on changes in the window position, visibility (iconify), focus changes, screen update, and closing. These are only sent once per event (Unique).`,
	39: `WindowResize happens when the window has been resized, which can happen continuously during a user resizing episode. These are not Unique events, and are compressed to minimize lag.`,
	40: `WindowPaint is sent continuously at FPS frequency (60 frames per second by default) to drive updating check on the window. It is not unique, will be compressed to keep pace with updating.`,
	41: `OS is an operating system generated event (app level typically)`,
	42: `OSOpenFiles is an event telling app to open given files`,
	43: `Custom is a user-defined event with a data any field`,
}

var _TypesMap = map[Types]string{
	0:  `UnknownType`,
	1:  `MouseDown`,
	2:  `MouseUp`,
	3:  `MouseMove`,
	4:  `MouseDrag`,
	5:  `Click`,
	6:  `DoubleClick`,
	7:  `ContextMenu`,
	8:  `LongPressStart`,
	9:  `LongPressEnd`,
	10: `MouseEnter`,
	11: `MouseLeave`,
	12: `LongHoverStart`,
	13: `LongHoverEnd`,
	14: `DragStart`,
	15: `Drop`,
	16: `DragMove`,
	17: `DragEnter`,
	18: `DragLeave`,
	19: `SlideStart`,
	20: `SlideMove`,
	21: `SlideStop`,
	22: `Scroll`,
	23: `KeyDown`,
	24: `KeyUp`,
	25: `KeyChord`,
	26: `TouchStart`,
	27: `TouchEnd`,
	28: `TouchMove`,
	29: `Magnify`,
	30: `Rotate`,
	31: `Select`,
	32: `Focus`,
	33: `FocusLost`,
	34: `Change`,
	35: `Input`,
	36: `Show`,
	37: `Close`,
	38: `Window`,
	39: `WindowResize`,
	40: `WindowPaint`,
	41: `OS`,
	42: `OSOpenFiles`,
	43: `Custom`,
}

// String returns the string representation
// of this Types value.
func (i Types) String() string {
	if str, ok := _TypesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Types value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Types) SetString(s string) error {
	if val, ok := _TypesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TypesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Types")
}

// Int64 returns the Types value as an int64.
func (i Types) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Types value from an int64.
func (i *Types) SetInt64(in int64) {
	*i = Types(in)
}

// Desc returns the description of the Types value.
func (i Types) Desc() string {
	if str, ok := _TypesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TypesValues returns all possible values
// for the type Types.
func TypesValues() []Types {
	return _TypesValues
}

// Values returns all possible values
// for the type Types.
func (i Types) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TypesValues))
	for i, d := range _TypesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Types.
func (i Types) IsValid() bool {
	_, ok := _TypesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Types) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Types) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _EventFlagsValues = []EventFlags{0, 1}

// EventFlagsN is the highest valid value
// for type EventFlags, plus one.
const EventFlagsN EventFlags = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _EventFlagsNoOp() {
	var x [1]struct{}
	_ = x[Handled-(0)]
	_ = x[Unique-(1)]
}

var _EventFlagsNameToValueMap = map[string]EventFlags{
	`Handled`: 0,
	`handled`: 0,
	`Unique`:  1,
	`unique`:  1,
}

var _EventFlagsDescMap = map[EventFlags]string{
	0: `Handled indicates that the event has been handled`,
	1: `EventUnique indicates that the event is Unique and not to be compressed with like events.`,
}

var _EventFlagsMap = map[EventFlags]string{
	0: `Handled`,
	1: `Unique`,
}

// String returns the string representation
// of this EventFlags value.
func (i EventFlags) String() string {
	str := ""
	for _, ie := range _EventFlagsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this EventFlags value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i EventFlags) BitIndexString() string {
	if str, ok := _EventFlagsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the EventFlags value from its
// string representation, and returns an
// error if the string is invalid.
func (i *EventFlags) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the EventFlags value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *EventFlags) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _EventFlagsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _EventFlagsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else if flg == "" {
			continue
		} else {
			return fmt.Errorf("%q is not a valid value for type EventFlags", flg)
		}
	}
	return nil
}

// Int64 returns the EventFlags value as an int64.
func (i EventFlags) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the EventFlags value from an int64.
func (i *EventFlags) SetInt64(in int64) {
	*i = EventFlags(in)
}

// Desc returns the description of the EventFlags value.
func (i EventFlags) Desc() string {
	if str, ok := _EventFlagsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// EventFlagsValues returns all possible values
// for the type EventFlags.
func EventFlagsValues() []EventFlags {
	return _EventFlagsValues
}

// Values returns all possible values
// for the type EventFlags.
func (i EventFlags) Values() []enums.Enum {
	res := make([]enums.Enum, len(_EventFlagsValues))
	for i, d := range _EventFlagsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type EventFlags.
func (i EventFlags) IsValid() bool {
	_, ok := _EventFlagsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i EventFlags) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *EventFlags) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i EventFlags) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *EventFlags) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _WinActionsValues = []WinActions{0, 1, 2, 3, 4, 5, 6, 7}

// WinActionsN is the highest valid value
// for type WinActions, plus one.
const WinActionsN WinActions = 8

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _WinActionsNoOp() {
	var x [1]struct{}
	_ = x[NoWinAction-(0)]
	_ = x[WinClose-(1)]
	_ = x[WinMinimize-(2)]
	_ = x[WinMove-(3)]
	_ = x[WinFocus-(4)]
	_ = x[WinFocusLost-(5)]
	_ = x[WinShow-(6)]
	_ = x[ScreenUpdate-(7)]
}

var _WinActionsNameToValueMap = map[string]WinActions{
	`NoWinAction`:  0,
	`nowinaction`:  0,
	`Close`:        1,
	`close`:        1,
	`Minimize`:     2,
	`minimize`:     2,
	`Move`:         3,
	`move`:         3,
	`Focus`:        4,
	`focus`:        4,
	`FocusLost`:    5,
	`focuslost`:    5,
	`Show`:         6,
	`show`:         6,
	`ScreenUpdate`: 7,
	`screenupdate`: 7,
}

var _WinActionsDescMap = map[WinActions]string{
	0: `NoWinAction is the zero value for special types (Resize, Paint)`,
	1: `WinClose means that the window is about to close, but has not yet closed.`,
	2: `WinMinimize means that the window has been iconified / miniaturized / is no longer visible.`,
	3: `WinMove means that the window was moved but NOT resized or changed in any other way -- does not require a redraw, but anything tracking positions will want to update.`,
	4: `WinFocus indicates that the window has been activated for receiving user input.`,
	5: `WinFocusLost indicates that the window is no longer activated for receiving input.`,
	6: `WinShow is for the WindowShow event -- sent by the system shortly after the window has opened, to ensure that full rendering is completed with the proper size, and to trigger one-time actions such as configuring the main menu after the window has opened.`,
	7: `ScreenUpdate occurs when any of the screen information is updated This event is sent to the first window on the list of active windows and it should then perform any necessary updating`,
}

var _WinActionsMap = map[WinActions]string{
	0: `NoWinAction`,
	1: `Close`,
	2: `Minimize`,
	3: `Move`,
	4: `Focus`,
	5: `FocusLost`,
	6: `Show`,
	7: `ScreenUpdate`,
}

// String returns the string representation
// of this WinActions value.
func (i WinActions) String() string {
	if str, ok := _WinActionsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the WinActions value from its
// string representation, and returns an
// error if the string is invalid.
func (i *WinActions) SetString(s string) error {
	if val, ok := _WinActionsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _WinActionsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type WinActions")
}

// Int64 returns the WinActions value as an int64.
func (i WinActions) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the WinActions value from an int64.
func (i *WinActions) SetInt64(in int64) {
	*i = WinActions(in)
}

// Desc returns the description of the WinActions value.
func (i WinActions) Desc() string {
	if str, ok := _WinActionsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// WinActionsValues returns all possible values
// for the type WinActions.
func WinActionsValues() []WinActions {
	return _WinActionsValues
}

// Values returns all possible values
// for the type WinActions.
func (i WinActions) Values() []enums.Enum {
	res := make([]enums.Enum, len(_WinActionsValues))
	for i, d := range _WinActionsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type WinActions.
func (i WinActions) IsValid() bool {
	_, ok := _WinActionsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WinActions) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WinActions) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}
