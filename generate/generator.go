// Copyright (c) 2023, The GoKi Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package generate

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"os"
	"path/filepath"
	"strings"

	"goki.dev/goki/config"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

// Generator holds the state of the generator.
// It is primarily used to buffer the output.
type Generator struct {
	Config *config.Config // The configuration information
	Buf    bytes.Buffer   // The accumulated output.
	Pkgs   []*Package     // The packages we are scanning.
	Pkg    *Package       // The packages we are currently on.
	Types  []Type         // The Ki types
}

// NewGenerator returns a new generator with the
// given configuration information.
func NewGenerator(config *config.Config) *Generator {
	return &Generator{Config: config}
}

// ParsePackage parses the single package located in the configuration directory.
func (g *Generator) ParsePackage() error {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedSyntax | packages.NeedTypesInfo,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, g.Config.Generate.Dir)
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return fmt.Errorf("expected at least 1 package, but found 0")
	}
	g.Pkgs = []*Package{}
	for _, pkg := range pkgs {
		g.AddPackage(pkg)
	}
	return nil
}

// AddPackage adds a package and its syntax files to the generator.
func (g *Generator) AddPackage(pkg *packages.Package) {
	p := &Package{
		Name:  pkg.Name,
		Defs:  pkg.TypesInfo.Defs,
		Files: make([]*File, 0),
	}
	// set the directory to the directory of the package
	if len(pkg.Syntax) > 0 {
		p.Dir = filepath.Dir(pkg.Fset.Position(pkg.Syntax[0].FileStart).Filename)
	}
	for _, file := range pkg.Syntax {
		// ignore generated code
		if ast.IsGenerated(file) {
			continue
		}
		// need to use append and 0 initial length
		// because we don't know if it has generated code
		p.Files = append(p.Files, &File{
			File: file,
			Pkg:  p,
		})
	}
	g.Pkgs = append(g.Pkgs, p)
}

// Printf prints the formatted string to the
// accumulated output in [Generator.Buf]
func (g *Generator) Printf(format string, args ...any) {
	fmt.Fprintf(&g.Buf, format, args...)
}

// PrintHeader prints the header and package clause
// to the accumulated output
func (g *Generator) PrintHeader() {
	cmdstr := filepath.Base(os.Args[0])
	if len(os.Args) > 1 {
		cmdstr += " " + strings.Join(os.Args[1:], " ")
	}
	g.Printf("// Code generated by \"%s\"; DO NOT EDIT.\n", cmdstr)
	g.Printf("\n")
	g.Printf("package %s", g.Pkg.Name)
	g.Printf("\n")
}

// Find goes through all of the declarations in the package
// and finds all types, functions, variables, and constants
// with a comment directive of ki:, gi:, or grease: labeled with enums:enum
// or enums:bitflag. It stores the resulting types in [Generator.Types].
func (g *Generator) Find() error {
	g.Types = []Type{}
	for _, file := range g.Pkg.Files {
		var terr error
		ast.Inspect(file.File, func(n ast.Node) bool {
			if terr != nil {
				return false
			}
			cont, err := g.Inspect(n)
			if err != nil {
				terr = err
			}
			return cont
		})
		if terr != nil {
			return fmt.Errorf("Find: error finding: %w", terr)
		}
	}
	return nil
}

// Format returns the contents of the Generator's buffer
// ([Generator.Buf]) with goimports applied.
func (g *Generator) Format() ([]byte, error) {
	b, err := imports.Process(filepath.Join(g.Pkg.Dir, g.Config.Generate.Dir), g.Buf.Bytes(), nil)
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		return g.Buf.Bytes(), errors.New("internal error: invalid Go generated: " + err.Error() + "; compile the package to analyze the error")
	}
	return b, nil
}

// Write formats the data in the the Generator's buffer
// ([Generator.Buf]) and writes it to the file specified by
// [Generator.Config.Output].
func (g *Generator) Write() error {
	b, ferr := g.Format()
	// we still write file even if formatting failed, as it is still useful
	// then we handle error later
	werr := os.WriteFile(filepath.Join(g.Pkg.Dir, g.Config.Generate.Output), b, 0666)
	if werr != nil {
		return fmt.Errorf("Generator.Write: error writing file: %w", werr)
	}
	if ferr != nil {
		return fmt.Errorf("Generator.Write: error formatting code: %w", ferr)
	}
	return nil
}

// Inspect looks at the given AST node and adds it
// to [Generator.Types] if it is marked with an appropriate
// comment directive. It returns whether the AST inspector should
// continue, and an error if there is one. It should only
// be called in [ast.Inspect].
func (g *Generator) Inspect(n ast.Node) (bool, error) {
	ts, ok := n.(*ast.TypeSpec)
	if !ok {
		return true, nil
	}
	typ := g.Pkg.Defs[ts.Name].Type()
	utyp := typ.Underlying()
	fmt.Println(utyp)
	return true, nil
}
