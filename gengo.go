// Copyright (c) 2023, The GoKi Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package gengo provides utilities for building code generators in Go
package gengo

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

// Load loads and returns the Go packages named by the given patterns.
// Load calls [packages.Load] and ensures that there is at least one
// package; this means that, if there is a nil error, the length
// of the resulting packages is guaranteed to be greater than zero.
func Load(cfg *packages.Config, patterns ...string) ([]*packages.Package, error) {
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		return nil, err
	}
	if len(pkgs) == 0 {
		return nil, fmt.Errorf("expected at least one package but got %d", len(pkgs))
	}
	return pkgs, nil
}

// PrintHeader prints a header to the given buffer for a generated
// file in the given package with the given imports. Imports do not
// need to be set if you are running [Imports] on the code later,
// but they should be set for any external packages that many not
// be found correctly by goimports.
func PrintHeader(buf bytes.Buffer, pkg string, imports ...string) {
	printf := func(format string, args ...any) {
		fmt.Fprintf(&buf, format, args...)
	}
	cmdstr := filepath.Base(os.Args[0])
	if len(os.Args) > 1 {
		cmdstr += " " + strings.Join(os.Args[1:], " ")
	}
	printf("// Code generated by \"%s\"; DO NOT EDIT.\n\n", cmdstr)
	printf("package %s\n", pkg)
	if len(imports) > 0 {
		printf("import (\n")
		for _, imp := range imports {
			printf("\t%q\n", imp)
		}
		printf(")\n")
	}
}
