// Code generated by "goki generate"; DO NOT EDIT.

package gi

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// MenuBarType is the [gti.Type] for [MenuBar]
var MenuBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.MenuBar",
	Doc:        "MenuBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and has convenience methods for adding menus.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MainMenu", &gti.Field{Name: "MainMenu", Type: "bool", Doc: "is this the main menu bar for a window?  controls whether displayed on macOS", Directives: gti.Directives{}}},
		{"OSMainMenus", &gti.Field{Name: "OSMainMenus", Type: "map[string]*Action", Doc: "map of main menu items for callback from OS main menu (MacOS specific)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MenuBar{},
})

// NewMenuBar adds a new [MenuBar] with
// the given name to the given parent.
func NewMenuBar(par ki.Ki, name string) *MenuBar {
	return par.NewChild(MenuBarType, name).(*MenuBar)
}

// Type returns the [*gti.Type] of [MenuBar]
func (t *MenuBar) Type() *gti.Type {
	return MenuBarType
}

// New returns a new [*MenuBar] value
func (t *MenuBar) New() ki.Ki {
	return &MenuBar{}
}

// ToolBarType is the [gti.Type] for [ToolBar]
var ToolBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ToolBar",
	Doc:        "ToolBar is a Layout (typically LayoutHoriz) that renders a gradient\nbackground and is useful for holding Actions that do things",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ToolBar{},
})

// NewToolBar adds a new [ToolBar] with
// the given name to the given parent.
func NewToolBar(par ki.Ki, name string) *ToolBar {
	return par.NewChild(ToolBarType, name).(*ToolBar)
}

// Type returns the [*gti.Type] of [ToolBar]
func (t *ToolBar) Type() *gti.Type {
	return ToolBarType
}

// New returns a new [*ToolBar] value
func (t *ToolBar) New() ki.Ki {
	return &ToolBar{}
}

// BitmapType is the [gti.Type] for [Bitmap]
var BitmapType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Bitmap",
	Doc:        "Bitmap is a Widget that is optimized to render a static bitmap image --\nit expects to be a terminal node and does NOT call rendering etc on its\nchildren.  It is particularly useful for overlays in drag-n-drop uses --\ncan grab the image of another vp and show that",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Filename", &gti.Field{Name: "Filename", Type: "FileName", Doc: "file name of image loaded -- set by OpenImage", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "image.Point", Doc: "size of the image", Directives: gti.Directives{}}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", Doc: "[view: -] the bitmap image", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Bitmap{},
})

// NewBitmap adds a new [Bitmap] with
// the given name to the given parent.
func NewBitmap(par ki.Ki, name string) *Bitmap {
	return par.NewChild(BitmapType, name).(*Bitmap)
}

// Type returns the [*gti.Type] of [Bitmap]
func (t *Bitmap) Type() *gti.Type {
	return BitmapType
}

// New returns a new [*Bitmap] value
func (t *Bitmap) New() ki.Ki {
	return &Bitmap{}
}

// ButtonBoxType is the [gti.Type] for [ButtonBox]
var ButtonBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ButtonBox",
	Doc:        "ButtonBox is a widget for containing a set of CheckBox buttons.\nIt can optionally enforce mutual excusivity (i.e., Radio Buttons).\nThe buttons are all in the Parts of the widget and the Parts layout\ndetermines how they are displayed.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Items", &gti.Field{Name: "Items", Type: "[]string", Doc: "the list of items (checbox button labels)", Directives: gti.Directives{}}},
		{"Tooltips", &gti.Field{Name: "Tooltips", Type: "[]string", Doc: "an optional list of tooltips displayed on hover for checkbox items; the indices for tooltips correspond to those for items", Directives: gti.Directives{}}},
		{"Mutex", &gti.Field{Name: "Mutex", Type: "bool", Doc: "make the items mutually exclusive -- checking one turns off all the others", Directives: gti.Directives{}}},
		{"ButtonSig", &gti.Field{Name: "ButtonSig", Type: "ki.Signal", Doc: "[view: -] signal for button box, when any button is updated -- the signal type is the index of the selected item, and the data is the label", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ButtonBox{},
})

// NewButtonBox adds a new [ButtonBox] with
// the given name to the given parent.
func NewButtonBox(par ki.Ki, name string) *ButtonBox {
	return par.NewChild(ButtonBoxType, name).(*ButtonBox)
}

// Type returns the [*gti.Type] of [ButtonBox]
func (t *ButtonBox) Type() *gti.Type {
	return ButtonBoxType
}

// New returns a new [*ButtonBox] value
func (t *ButtonBox) New() ki.Ki {
	return &ButtonBox{}
}

// ButtonBaseType is the [gti.Type] for [ButtonBase]
var ButtonBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ButtonBase",
	Doc:        "ButtonBase has common button functionality for all buttons, including\nButton, Action, MenuButton, CheckBox, etc",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "label for the button -- if blank then no label is presented", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "gicons.Icon", Doc: "[view: show-name] optional icon for the button -- different buttons can configure this in different ways relative to the text if both are present", Directives: gti.Directives{}}},
		{"Indicator", &gti.Field{Name: "Indicator", Type: "gicons.Icon", Doc: "[view: show-name] name of the menu indicator icon to present, or blank or 'nil' or 'none' -- shown automatically when there are Menu elements present unless 'none' is set", Directives: gti.Directives{}}},
		{"Shortcut", &gti.Field{Name: "Shortcut", Type: "key.Chord", Doc: "optional shortcut keyboard chord to trigger this action -- always window-wide in scope, and should generally not conflict other shortcuts (a log message will be emitted if so).  Shortcuts are processed after all other processing of keyboard input.  Use Command for Control / Meta (Mac Command key) per platform.  These are only set automatically for Menu items, NOT for items in ToolBar or buttons somewhere, but the tooltip for buttons will show the shortcut if set.", Directives: gti.Directives{}}},
		{"WasPressed", &gti.Field{Name: "WasPressed", Type: "bool", Doc: "whether the button has been pressed (typically accessed in an ButtonRelease event)", Directives: gti.Directives{}}},
		{"ButtonSig", &gti.Field{Name: "ButtonSig", Type: "ki.Signal", Doc: "[view: -] signal for button -- see ButtonSignals for the types", Directives: gti.Directives{}}},
		{"Menu", &gti.Field{Name: "Menu", Type: "Menu", Doc: "the menu items for this menu -- typically add Action elements for menus, along with separators", Directives: gti.Directives{}}},
		{"MakeMenuFunc", &gti.Field{Name: "MakeMenuFunc", Type: "MakeMenuFunc", Doc: "[view: -] set this to make a menu on demand -- if set then this button acts like a menu button", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ButtonBase{},
})

// NewButtonBase adds a new [ButtonBase] with
// the given name to the given parent.
func NewButtonBase(par ki.Ki, name string) *ButtonBase {
	return par.NewChild(ButtonBaseType, name).(*ButtonBase)
}

// Type returns the [*gti.Type] of [ButtonBase]
func (t *ButtonBase) Type() *gti.Type {
	return ButtonBaseType
}

// New returns a new [*ButtonBase] value
func (t *ButtonBase) New() ki.Ki {
	return &ButtonBase{}
}

// CheckBoxType is the [gti.Type] for [CheckBox]
var CheckBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.CheckBox",
	Doc:        "CheckBox toggles between a checked and unchecked state",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconOff", &gti.Field{Name: "IconOff", Type: "gicons.Icon", Doc: "[view: show-name] icon to use for the off, unchecked state of the icon -- plain Icon holds the On state -- can be set with icon-off property", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ButtonBase", &gti.Field{Name: "ButtonBase", Type: "ButtonBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &CheckBox{},
})

// NewCheckBox adds a new [CheckBox] with
// the given name to the given parent.
func NewCheckBox(par ki.Ki, name string) *CheckBox {
	return par.NewChild(CheckBoxType, name).(*CheckBox)
}

// Type returns the [*gti.Type] of [CheckBox]
func (t *CheckBox) Type() *gti.Type {
	return CheckBoxType
}

// New returns a new [*CheckBox] value
func (t *CheckBox) New() ki.Ki {
	return &CheckBox{}
}

// CompleteType is the [gti.Type] for [Complete]
var CompleteType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Complete",
	Doc:        "Complete holds the current completion data and functions to call for building\nthe list of possible completions and for editing text after a completion is selected",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MatchFunc", &gti.Field{Name: "MatchFunc", Type: "complete.MatchFunc", Doc: "function to get the list of possible completions", Directives: gti.Directives{}}},
		{"LookupFunc", &gti.Field{Name: "LookupFunc", Type: "complete.LookupFunc", Doc: "function to get the text to show for lookup", Directives: gti.Directives{}}},
		{"EditFunc", &gti.Field{Name: "EditFunc", Type: "complete.EditFunc", Doc: "function to edit text using the selected completion", Directives: gti.Directives{}}},
		{"Context", &gti.Field{Name: "Context", Type: "any", Doc: "the object that implements complete.Func", Directives: gti.Directives{}}},
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", Doc: "line number in source that completion is operating on, if relevant", Directives: gti.Directives{}}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", Doc: "character position in source that completion is operating on", Directives: gti.Directives{}}},
		{"Completions", &gti.Field{Name: "Completions", Type: "complete.Completions", Doc: "the list of potential completions", Directives: gti.Directives{}}},
		{"Seed", &gti.Field{Name: "Seed", Type: "string", Doc: "current completion seed", Directives: gti.Directives{}}},
		{"CompleteSig", &gti.Field{Name: "CompleteSig", Type: "ki.Signal", Doc: "[view: -] signal for complete -- see CompleteSignals for the types", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "string", Doc: "the user's completion selection'", Directives: gti.Directives{}}},
		{"Vp", &gti.Field{Name: "Vp", Type: "*Viewport", Doc: "the viewport where the current popup menu is presented", Directives: gti.Directives{}}},
		{"DelayTimer", &gti.Field{Name: "DelayTimer", Type: "*time.Timer", Doc: "", Directives: gti.Directives{}}},
		{"DelayMu", &gti.Field{Name: "DelayMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
		{"ShowMu", &gti.Field{Name: "ShowMu", Type: "sync.Mutex", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Complete{},
})

// NewComplete adds a new [Complete] with
// the given name to the given parent.
func NewComplete(par ki.Ki, name string) *Complete {
	return par.NewChild(CompleteType, name).(*Complete)
}

// Type returns the [*gti.Type] of [Complete]
func (t *Complete) Type() *gti.Type {
	return CompleteType
}

// New returns a new [*Complete] value
func (t *Complete) New() ki.Ki {
	return &Complete{}
}

// FrameType is the [gti.Type] for [Frame]
var FrameType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Frame",
	Doc:        "Frame is a Layout that renders a background according to the\nbackground-color style setting, and optional striping for grid layouts",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Stripes", &gti.Field{Name: "Stripes", Type: "Stripes", Doc: "options for striped backgrounds -- rendered as darker bands relative to background color", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Frame{},
})

// NewFrame adds a new [Frame] with
// the given name to the given parent.
func NewFrame(par ki.Ki, name string) *Frame {
	return par.NewChild(FrameType, name).(*Frame)
}

// Type returns the [*gti.Type] of [Frame]
func (t *Frame) Type() *gti.Type {
	return FrameType
}

// New returns a new [*Frame] value
func (t *Frame) New() ki.Ki {
	return &Frame{}
}

// IconType is the [gti.Type] for [Icon]
var IconType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Icon",
	Doc:        "Icon is a wrapper around a child svg.Icon SVG element.  SVG should contain no\ncolor information -- it should just be a filled shape where the fill and\nstroke colors come from the surrounding context / paint settings.  The\nrendered version is cached for a given size. Icons are always copied from\nan original source icon and then can be customized from there.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"IconNm", &gti.Field{Name: "IconNm", Type: "gicons.Icon", Doc: "icon name that has been set -- optimizes to prevent reloading of icon", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "file name for the loaded icon, if loaded", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Icon{},
})

// NewIcon adds a new [Icon] with
// the given name to the given parent.
func NewIcon(par ki.Ki, name string) *Icon {
	return par.NewChild(IconType, name).(*Icon)
}

// Type returns the [*gti.Type] of [Icon]
func (t *Icon) Type() *gti.Type {
	return IconType
}

// New returns a new [*Icon] value
func (t *Icon) New() ki.Ki {
	return &Icon{}
}

// LayoutType is the [gti.Type] for [Layout]
var LayoutType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Layout",
	Doc:        "Layout is the primary node type responsible for organizing the sizes\nand positions of child widgets. It does not render, only organize,\nso properties like background color will have no effect.\nAll arbitrary collections of widgets should generally be contained\nwithin a layout -- otherwise the parent widget must take over\nresponsibility for positioning.\nThe alignment is NOT inherited by default so must be specified per\nchild, except that the parent alignment is used within the relevant\ndimension (e.g., horizontal-align for a LayoutHoriz layout,\nto determine left, right, center, justified).\nLayouts can automatically add scrollbars depending on the Overflow\nlayout style.\nFor a Grid layout, the 'columns' property should generally be set\nto the desired number of columns, from which the number of rows\nis computed -- otherwise it uses the square root of number of\nelements.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Lay", &gti.Field{Name: "Lay", Type: "Layouts", Doc: "type of layout to use", Directives: gti.Directives{}}},
		{"Spacing", &gti.Field{Name: "Spacing", Type: "units.Value", Doc: "extra space to add between elements in the layout", Directives: gti.Directives{}}},
		{"StackTop", &gti.Field{Name: "StackTop", Type: "int", Doc: "for Stacked layout, index of node to use as the top of the stack -- only node at this index is rendered -- if not a valid index, nothing is rendered", Directives: gti.Directives{}}},
		{"StackTopOnly", &gti.Field{Name: "StackTopOnly", Type: "bool", Doc: "for stacked layout, only layout the top widget -- this is appropriate for e.g., tab layout, which does a full redraw on stack changes, but not for e.g., check boxes which don't", Directives: gti.Directives{}}},
		{"ChildSize", &gti.Field{Name: "ChildSize", Type: "mat32.Vec2", Doc: "total max size of children as laid out", Directives: gti.Directives{}}},
		{"ExtraSize", &gti.Field{Name: "ExtraSize", Type: "mat32.Vec2", Doc: "extra size in each dim due to scrollbars we add", Directives: gti.Directives{}}},
		{"HasScroll", &gti.Field{Name: "HasScroll", Type: "[2]bool", Doc: "whether scrollbar is used for given dim", Directives: gti.Directives{}}},
		{"Scrolls", &gti.Field{Name: "Scrolls", Type: "[2]*ScrollBar", Doc: "scroll bars -- we fully manage them as needed", Directives: gti.Directives{}}},
		{"GridSize", &gti.Field{Name: "GridSize", Type: "image.Point", Doc: "computed size of a grid layout based on all the constraints -- computed during GetSize pass", Directives: gti.Directives{}}},
		{"GridData", &gti.Field{Name: "GridData", Type: "[RowColN][]GridData", Doc: "grid data for rows in [0] and cols in [1]", Directives: gti.Directives{}}},
		{"FlowBreaks", &gti.Field{Name: "FlowBreaks", Type: "[]int", Doc: "line breaks for flow layout", Directives: gti.Directives{}}},
		{"NeedsRedo", &gti.Field{Name: "NeedsRedo", Type: "bool", Doc: "true if this layout got a redo = true on previous iteration -- otherwise it just skips any re-layout on subsequent iteration", Directives: gti.Directives{}}},
		{"FocusName", &gti.Field{Name: "FocusName", Type: "string", Doc: "accumulated name to search for when keys are typed", Directives: gti.Directives{}}},
		{"FocusNameTime", &gti.Field{Name: "FocusNameTime", Type: "time.Time", Doc: "time of last focus name event -- for timeout", Directives: gti.Directives{}}},
		{"FocusNameLast", &gti.Field{Name: "FocusNameLast", Type: "ki.Ki", Doc: "last element focused on -- used as a starting point if name is the same", Directives: gti.Directives{}}},
		{"ScrollsOff", &gti.Field{Name: "ScrollsOff", Type: "bool", Doc: "scrollbars have been manually turned off due to layout being invisible -- must be reactivated when re-visible", Directives: gti.Directives{}}},
		{"ScrollSig", &gti.Field{Name: "ScrollSig", Type: "ki.Signal", Doc: "[view: -] signal for layout scrolling -- sends signal whenever layout is scrolled due to user input -- signal type is dimension (mat32.X or Y) and data is new position (not delta)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Layout{},
})

// NewLayout adds a new [Layout] with
// the given name to the given parent.
func NewLayout(par ki.Ki, name string) *Layout {
	return par.NewChild(LayoutType, name).(*Layout)
}

// Type returns the [*gti.Type] of [Layout]
func (t *Layout) Type() *gti.Type {
	return LayoutType
}

// New returns a new [*Layout] value
func (t *Layout) New() ki.Ki {
	return &Layout{}
}

// StretchType is the [gti.Type] for [Stretch]
var StretchType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Stretch",
	Doc:        "Stretch adds an infinitely stretchy element for spacing out layouts\n(max-size = -1) set the width / height property to determine how much it\ntakes relative to other stretchy elements",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Stretch{},
})

// NewStretch adds a new [Stretch] with
// the given name to the given parent.
func NewStretch(par ki.Ki, name string) *Stretch {
	return par.NewChild(StretchType, name).(*Stretch)
}

// Type returns the [*gti.Type] of [Stretch]
func (t *Stretch) Type() *gti.Type {
	return StretchType
}

// New returns a new [*Stretch] value
func (t *Stretch) New() ki.Ki {
	return &Stretch{}
}

// SpaceType is the [gti.Type] for [Space]
var SpaceType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Space",
	Doc:        "Space adds a fixed sized (1 ch x 1 em by default) blank space to a layout -- set\nwidth / height property to change",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Space{},
})

// NewSpace adds a new [Space] with
// the given name to the given parent.
func NewSpace(par ki.Ki, name string) *Space {
	return par.NewChild(SpaceType, name).(*Space)
}

// Type returns the [*gti.Type] of [Space]
func (t *Space) Type() *gti.Type {
	return SpaceType
}

// New returns a new [*Space] value
func (t *Space) New() ki.Ki {
	return &Space{}
}

// SeparatorType is the [gti.Type] for [Separator]
var SeparatorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Separator",
	Doc:        "Separator draws a vertical or horizontal line",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Horiz", &gti.Field{Name: "Horiz", Type: "bool", Doc: "is this a horizontal separator -- otherwise vertical", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Separator{},
})

// NewSeparator adds a new [Separator] with
// the given name to the given parent.
func NewSeparator(par ki.Ki, name string) *Separator {
	return par.NewChild(SeparatorType, name).(*Separator)
}

// Type returns the [*gti.Type] of [Separator]
func (t *Separator) Type() *gti.Type {
	return SeparatorType
}

// New returns a new [*Separator] value
func (t *Separator) New() ki.Ki {
	return &Separator{}
}

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.ColorPrefs",
	Doc:  "ColorPrefs specify colors for all major categories of GUI elements, and are\nused in the default styles.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"HiStyle", &gti.Field{Name: "HiStyle", Type: "HiStyleName", Doc: "text highilighting style / theme", Directives: gti.Directives{}}},
		{"Font", &gti.Field{Name: "Font", Type: "color.RGBA", Doc: "default font / pen color", Directives: gti.Directives{}}},
		{"Background", &gti.Field{Name: "Background", Type: "color.RGBA", Doc: "default background color", Directives: gti.Directives{}}},
		{"Shadow", &gti.Field{Name: "Shadow", Type: "color.RGBA", Doc: "color for shadows -- should generally be a darker shade of the background color", Directives: gti.Directives{}}},
		{"Border", &gti.Field{Name: "Border", Type: "color.RGBA", Doc: "default border color, for button, frame borders, etc", Directives: gti.Directives{}}},
		{"Control", &gti.Field{Name: "Control", Type: "color.RGBA", Doc: "default main color for controls: buttons, etc", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "color.RGBA", Doc: "color for icons or other solidly-colored, small elements", Directives: gti.Directives{}}},
		{"Select", &gti.Field{Name: "Select", Type: "color.RGBA", Doc: "color for selected elements", Directives: gti.Directives{}}},
		{"Highlight", &gti.Field{Name: "Highlight", Type: "color.RGBA", Doc: "color for highlight background", Directives: gti.Directives{}}},
		{"Link", &gti.Field{Name: "Link", Type: "color.RGBA", Doc: "color for links in text etc", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.EditorPrefs",
	Doc:  "EditorPrefs contains editor preferences.  It can also be set\nfrom ki.Props style properties.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TabSize", &gti.Field{Name: "TabSize", Type: "int", Doc: "size of a tab, in chars -- also determines indent level for space indent", Directives: gti.Directives{}}},
		{"SpaceIndent", &gti.Field{Name: "SpaceIndent", Type: "bool", Doc: "use spaces for indentation, otherwise tabs", Directives: gti.Directives{}}},
		{"WordWrap", &gti.Field{Name: "WordWrap", Type: "bool", Doc: "wrap lines at word boundaries -- otherwise long lines scroll off the end", Directives: gti.Directives{}}},
		{"LineNos", &gti.Field{Name: "LineNos", Type: "bool", Doc: "show line numbers", Directives: gti.Directives{}}},
		{"Completion", &gti.Field{Name: "Completion", Type: "bool", Doc: "use the completion system to suggest options while typing", Directives: gti.Directives{}}},
		{"SpellCorrect", &gti.Field{Name: "SpellCorrect", Type: "bool", Doc: "suggest corrections for unknown words while typing", Directives: gti.Directives{}}},
		{"AutoIndent", &gti.Field{Name: "AutoIndent", Type: "bool", Doc: "automatically indent lines when enter, tab, }, etc pressed", Directives: gti.Directives{}}},
		{"EmacsUndo", &gti.Field{Name: "EmacsUndo", Type: "bool", Doc: "use emacs-style undo, where after a non-undo command, all the current undo actions are added to the undo stack, such that a subsequent undo is actually a redo", Directives: gti.Directives{}}},
		{"DepthColor", &gti.Field{Name: "DepthColor", Type: "bool", Doc: "colorize the background according to nesting depth", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name: "goki.dev/gi/v2/gi.FavPathItem",
	Doc:  "FavPathItem represents one item in a favorite path list, for display of\nfavorites.  Is an ordered list instead of a map because user can organize\nin order",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ic", &gti.Field{Name: "Ic", Type: "gicons.Icon", Doc: "icon for item", Directives: gti.Directives{}}},
		{"Name", &gti.Field{Name: "Name", Type: "string", Doc: "name of the favorite item", Directives: gti.Directives{}}},
		{"Path", &gti.Field{Name: "Path", Type: "string", Doc: "[tableview: -select]", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SliderBaseType is the [gti.Type] for [SliderBase]
var SliderBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SliderBase",
	Doc:        "SliderBase has common slider functionality -- two major modes: ValThumb =\nfalse is a slider with a fixed-size thumb knob, while = true has a thumb\nthat represents a value, as in a scrollbar, and the scrolling range is size\n- thumbsize",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"EmitValue", &gti.Field{Name: "EmitValue", Type: "float32", Doc: "previous emitted value - don't re-emit if it is the same", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "float32", Doc: "size of the slide box in the relevant dimension -- range of motion -- exclusive of spacing", Directives: gti.Directives{}}},
		{"ThSize", &gti.Field{Name: "ThSize", Type: "float32", Doc: "computed size of the thumb -- if ValThumb then this is auto-sized based on ThumbVal and is subtracted from Size in computing Value -- this is the display size version subject to SliderMinThumbSize", Directives: gti.Directives{}}},
		{"ThSizeReal", &gti.Field{Name: "ThSizeReal", Type: "float32", Doc: "computed size of the thumb, without any SliderMinThumbSize limitation -- use this for more accurate calculations of true value", Directives: gti.Directives{}}},
		{"ThumbSize", &gti.Field{Name: "ThumbSize", Type: "units.Value", Doc: "styled fixed size of the thumb", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"Icon", &gti.Field{Name: "Icon", Type: "gicons.Icon", Doc: "[view: show-name] optional icon for the dragging knob", Directives: gti.Directives{}}},
		{"ValThumb", &gti.Field{Name: "ValThumb", Type: "bool", Doc: "if true, has a proportionally-sized thumb knob reflecting another value -- e.g., the amount visible in a scrollbar, and thumb is completely inside Size -- otherwise ThumbSize affects Size so that full Size range can be traversed", Directives: gti.Directives{}}},
		{"ThumbVal", &gti.Field{Name: "ThumbVal", Type: "float32", Doc: "value that the thumb represents, in the same units", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "float32", Doc: "logical position of the slider relative to Size", Directives: gti.Directives{}}},
		{"DragPos", &gti.Field{Name: "DragPos", Type: "float32", Doc: "underlying drag position of slider -- not subject to snapping", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which the slider slides", Directives: gti.Directives{}}},
		{"Tracking", &gti.Field{Name: "Tracking", Type: "bool", Doc: "if true, will send continuous updates of value changes as user moves the slider -- otherwise only at the end -- see TrackThr for a threshold on amount of change", Directives: gti.Directives{}}},
		{"TrackThr", &gti.Field{Name: "TrackThr", Type: "float32", Doc: "threshold for amount of change in scroll value before emitting a signal in Tracking mode", Directives: gti.Directives{}}},
		{"Snap", &gti.Field{Name: "Snap", Type: "bool", Doc: "snap the values to Step size increments", Directives: gti.Directives{}}},
		{"Off", &gti.Field{Name: "Off", Type: "bool", Doc: "can turn off e.g., scrollbar rendering with this flag -- just prevents rendering", Directives: gti.Directives{}}},
		{"StyleBox", &gti.Field{Name: "StyleBox", Type: "gist.Style", Doc: "an additional style object that is used for styling the overall box around the slider; it should be set in the StyleFuncs, just the like the main style object is; it typically has no border and a white/black background; it needs a background to allow local re-rendering", Directives: gti.Directives{}}},
		{"ValueColor", &gti.Field{Name: "ValueColor", Type: "gist.ColorSpec", Doc: "the background color that is used for styling the selected value section of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"ThumbColor", &gti.Field{Name: "ThumbColor", Type: "gist.ColorSpec", Doc: "the background color that is used for styling the thumb (handle) of the slider; it should be set in the StyleFuncs, just like the main style object is", Directives: gti.Directives{}}},
		{"State", &gti.Field{Name: "State", Type: "SliderStates", Doc: "state of slider", Directives: gti.Directives{}}},
		{"StateStyles", &gti.Field{Name: "StateStyles", Type: "[SliderStatesN]gist.Style", Doc: "styles for different states of the slider, one for each state -- everything inherits from the base Style which is styled first according to the user-set styles, and then subsequent style settings can override that", Directives: gti.Directives{}}},
		{"SliderSig", &gti.Field{Name: "SliderSig", Type: "ki.Signal", Doc: "[view: -] signal for slider -- see SliderSignals for the types", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SliderBase{},
})

// NewSliderBase adds a new [SliderBase] with
// the given name to the given parent.
func NewSliderBase(par ki.Ki, name string) *SliderBase {
	return par.NewChild(SliderBaseType, name).(*SliderBase)
}

// Type returns the [*gti.Type] of [SliderBase]
func (t *SliderBase) Type() *gti.Type {
	return SliderBaseType
}

// New returns a new [*SliderBase] value
func (t *SliderBase) New() ki.Ki {
	return &SliderBase{}
}

// SliderType is the [gti.Type] for [Slider]
var SliderType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Slider",
	Doc:        "Slider is a standard value slider with a fixed-sized thumb knob -- if an\nIcon is set, it is used for the knob of the slider",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Slider{},
})

// NewSlider adds a new [Slider] with
// the given name to the given parent.
func NewSlider(par ki.Ki, name string) *Slider {
	return par.NewChild(SliderType, name).(*Slider)
}

// Type returns the [*gti.Type] of [Slider]
func (t *Slider) Type() *gti.Type {
	return SliderType
}

// New returns a new [*Slider] value
func (t *Slider) New() ki.Ki {
	return &Slider{}
}

// ScrollBarType is the [gti.Type] for [ScrollBar]
var ScrollBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ScrollBar",
	Doc:        "ScrollBar has a proportional thumb size reflecting amount of content visible",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ScrollBar{},
})

// NewScrollBar adds a new [ScrollBar] with
// the given name to the given parent.
func NewScrollBar(par ki.Ki, name string) *ScrollBar {
	return par.NewChild(ScrollBarType, name).(*ScrollBar)
}

// Type returns the [*gti.Type] of [ScrollBar]
func (t *ScrollBar) Type() *gti.Type {
	return ScrollBarType
}

// New returns a new [*ScrollBar] value
func (t *ScrollBar) New() ki.Ki {
	return &ScrollBar{}
}

// ProgressBarType is the [gti.Type] for [ProgressBar]
var ProgressBarType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.ProgressBar",
	Doc:        "ProgressBar is a progress bar that fills up bar as progress continues.\nCall Start with a maximum value to work toward, and ProgStep each time\na progress step has been accomplished -- increments the ProgCur by one\nand display is updated every ProgInc such steps.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ProgMax", &gti.Field{Name: "ProgMax", Type: "int", Doc: "maximum amount of progress to be achieved", Directives: gti.Directives{}}},
		{"ProgInc", &gti.Field{Name: "ProgInc", Type: "int", Doc: "progress increment when display is updated -- automatically computed from ProgMax at Start but can be overwritten", Directives: gti.Directives{}}},
		{"ProgCur", &gti.Field{Name: "ProgCur", Type: "int", Doc: "current progress level", Directives: gti.Directives{}}},
		{"ProgMu", &gti.Field{Name: "ProgMu", Type: "sync.Mutex", Doc: "mutex for updating progress", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ScrollBar", &gti.Field{Name: "ScrollBar", Type: "ScrollBar", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ProgressBar{},
})

// NewProgressBar adds a new [ProgressBar] with
// the given name to the given parent.
func NewProgressBar(par ki.Ki, name string) *ProgressBar {
	return par.NewChild(ProgressBarType, name).(*ProgressBar)
}

// Type returns the [*gti.Type] of [ProgressBar]
func (t *ProgressBar) Type() *gti.Type {
	return ProgressBarType
}

// New returns a new [*ProgressBar] value
func (t *ProgressBar) New() ki.Ki {
	return &ProgressBar{}
}

// SpellType is the [gti.Type] for [Spell]
var SpellType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Spell",
	Doc:        "Spell",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SrcLn", &gti.Field{Name: "SrcLn", Type: "int", Doc: "line number in source that spelling is operating on, if relevant", Directives: gti.Directives{}}},
		{"SrcCh", &gti.Field{Name: "SrcCh", Type: "int", Doc: "character position in source that spelling is operating on (start of word to be corrected)", Directives: gti.Directives{}}},
		{"Suggest", &gti.Field{Name: "Suggest", Type: "[]string", Doc: "list of suggested corrections", Directives: gti.Directives{}}},
		{"Word", &gti.Field{Name: "Word", Type: "string", Doc: "word being checked", Directives: gti.Directives{}}},
		{"LastLearned", &gti.Field{Name: "LastLearned", Type: "string", Doc: "last word learned -- can be undone -- stored in lowercase format", Directives: gti.Directives{}}},
		{"SpellSig", &gti.Field{Name: "SpellSig", Type: "ki.Signal", Doc: "[view: -] signal for Spell -- see SpellSignals for the types", Directives: gti.Directives{}}},
		{"Correction", &gti.Field{Name: "Correction", Type: "string", Doc: "the user's correction selection'", Directives: gti.Directives{}}},
		{"Vp", &gti.Field{Name: "Vp", Type: "*Viewport", Doc: "the viewport where the current popup menu is presented", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Spell{},
})

// NewSpell adds a new [Spell] with
// the given name to the given parent.
func NewSpell(par ki.Ki, name string) *Spell {
	return par.NewChild(SpellType, name).(*Spell)
}

// Type returns the [*gti.Type] of [Spell]
func (t *Spell) Type() *gti.Type {
	return SpellType
}

// New returns a new [*Spell] value
func (t *Spell) New() ki.Ki {
	return &Spell{}
}

// SpinBoxType is the [gti.Type] for [SpinBox]
var SpinBoxType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SpinBox",
	Doc:        "SpinBox combines a TextField with up / down buttons for incrementing /\ndecrementing values -- all configured within the Parts of the widget",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Value", &gti.Field{Name: "Value", Type: "float32", Doc: "current value", Directives: gti.Directives{}}},
		{"HasMin", &gti.Field{Name: "HasMin", Type: "bool", Doc: "is there a minimum value to enforce", Directives: gti.Directives{}}},
		{"Min", &gti.Field{Name: "Min", Type: "float32", Doc: "minimum value in range", Directives: gti.Directives{}}},
		{"HasMax", &gti.Field{Name: "HasMax", Type: "bool", Doc: "is there a maximumvalue to enforce", Directives: gti.Directives{}}},
		{"Max", &gti.Field{Name: "Max", Type: "float32", Doc: "maximum value in range", Directives: gti.Directives{}}},
		{"Step", &gti.Field{Name: "Step", Type: "float32", Doc: "smallest step size to increment", Directives: gti.Directives{}}},
		{"PageStep", &gti.Field{Name: "PageStep", Type: "float32", Doc: "larger PageUp / Dn step size", Directives: gti.Directives{}}},
		{"Prec", &gti.Field{Name: "Prec", Type: "int", Doc: "specifies the precision of decimal places (total, not after the decimal point) to use in representing the number -- this helps to truncate small weird floating point values in the nether regions", Directives: gti.Directives{}}},
		{"Format", &gti.Field{Name: "Format", Type: "string", Doc: "prop = format -- format string for printing the value -- blank defaults to %g.  If decimal based (ends in d, b, c, o, O, q, x, X, or U) then value is converted to decimal prior to printing", Directives: gti.Directives{}}},
		{"UpIcon", &gti.Field{Name: "UpIcon", Type: "gicons.Icon", Doc: "[view: show-name] icon to use for up button -- defaults to gicons.KeyboardArrowUp", Directives: gti.Directives{}}},
		{"DownIcon", &gti.Field{Name: "DownIcon", Type: "gicons.Icon", Doc: "[view: show-name] icon to use for down button -- defaults to gicons.KeyboardArrowDown", Directives: gti.Directives{}}},
		{"SpinBoxSig", &gti.Field{Name: "SpinBoxSig", Type: "ki.Signal", Doc: "[view: -] signal for spin box -- has no signal types, just emitted when the value changes", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SpinBox{},
})

// NewSpinBox adds a new [SpinBox] with
// the given name to the given parent.
func NewSpinBox(par ki.Ki, name string) *SpinBox {
	return par.NewChild(SpinBoxType, name).(*SpinBox)
}

// Type returns the [*gti.Type] of [SpinBox]
func (t *SpinBox) Type() *gti.Type {
	return SpinBoxType
}

// New returns a new [*SpinBox] value
func (t *SpinBox) New() ki.Ki {
	return &SpinBox{}
}

// SplitViewType is the [gti.Type] for [SplitView]
var SplitViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.SplitView",
	Doc:        "SplitView allocates a fixed proportion of space to each child, along given\ndimension, always using only the available space given to it by its parent\n(i.e., it will force its children, which should be layouts (typically\nFrame's), to have their own scroll bars as necessary).  It should\ngenerally be used as a main outer-level structure within a window,\nproviding a framework for inner elements -- it allows individual child\nelements to update independently and thus is important for speeding update\nperformance.  It uses the Widget Parts to hold the splitter widgets\nseparately from the children that contain the rest of the scenegraph to be\ndisplayed within each region.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"HandleSize", &gti.Field{Name: "HandleSize", Type: "units.Value", Doc: "size of the handle region in the middle of each split region, where the splitter can be dragged -- other-dimension size is 2x of this", Directives: gti.Directives{}}},
		{"Splits", &gti.Field{Name: "Splits", Type: "[]float32", Doc: "proportion (0-1 normalized, enforced) of space allocated to each element -- can enter 0 to collapse a given element", Directives: gti.Directives{}}},
		{"SavedSplits", &gti.Field{Name: "SavedSplits", Type: "[]float32", Doc: "A saved version of the splits which can be restored -- for dynamic collapse / expand operations", Directives: gti.Directives{}}},
		{"Dim", &gti.Field{Name: "Dim", Type: "mat32.Dims", Doc: "dimension along which to split the space", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SplitView{},
})

// NewSplitView adds a new [SplitView] with
// the given name to the given parent.
func NewSplitView(par ki.Ki, name string) *SplitView {
	return par.NewChild(SplitViewType, name).(*SplitView)
}

// Type returns the [*gti.Type] of [SplitView]
func (t *SplitView) Type() *gti.Type {
	return SplitViewType
}

// New returns a new [*SplitView] value
func (t *SplitView) New() ki.Ki {
	return &SplitView{}
}

// SplitterType is the [gti.Type] for [Splitter]
var SplitterType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Splitter",
	Doc:        "Splitter provides the splitter handle and line separating two elements in a\nSplitView, with draggable resizing of the splitter -- parent is Parts\nlayout of the SplitView -- based on SliderBase",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SplitterNo", &gti.Field{Name: "SplitterNo", Type: "int", Doc: "splitter number this one is", Directives: gti.Directives{}}},
		{"OrigWinBBox", &gti.Field{Name: "OrigWinBBox", Type: "image.Rectangle", Doc: "copy of the win bbox, used for translating mouse events when the bbox is restricted to the slider itself", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SliderBase", &gti.Field{Name: "SliderBase", Type: "SliderBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Splitter{},
})

// NewSplitter adds a new [Splitter] with
// the given name to the given parent.
func NewSplitter(par ki.Ki, name string) *Splitter {
	return par.NewChild(SplitterType, name).(*Splitter)
}

// Type returns the [*gti.Type] of [Splitter]
func (t *Splitter) Type() *gti.Type {
	return SplitterType
}

// New returns a new [*Splitter] value
func (t *Splitter) New() ki.Ki {
	return &Splitter{}
}

// EditorType is the [gti.Type] for [Editor]
var EditorType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.Editor",
	Doc:        "Editor supports editing of SVG elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Trans", &gti.Field{Name: "Trans", Type: "mat32.Vec2", Doc: "view translation offset (from dragging)", Directives: gti.Directives{}}},
		{"Scale", &gti.Field{Name: "Scale", Type: "float32", Doc: "view scaling (from zooming)", Directives: gti.Directives{}}},
		{"SetDragCursor", &gti.Field{Name: "SetDragCursor", Type: "bool", Doc: "[view: -] has dragging cursor been set yet?", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "WidgetBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Editor{},
})

// NewEditor adds a new [Editor] with
// the given name to the given parent.
func NewEditor(par ki.Ki, name string) *Editor {
	return par.NewChild(EditorType, name).(*Editor)
}

// Type returns the [*gti.Type] of [Editor]
func (t *Editor) Type() *gti.Type {
	return EditorType
}

// New returns a new [*Editor] value
func (t *Editor) New() ki.Ki {
	return &Editor{}
}

// TabViewType is the [gti.Type] for [TabView]
var TabViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.TabView",
	Doc:        "TabView switches among child widgets via tabs.  The selected widget gets\nthe full allocated space avail after the tabs are accounted for.  The\nTabView is just a Vertical layout that manages two child widgets: a\nHorizFlow Layout for the tabs (which can flow across multiple rows as\nneeded) and a Stacked Frame that actually contains all the children, and\nprovides scrollbars as needed to any content within.  Typically should have\nmax stretch and a set preferred size, so it expands.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MaxChars", &gti.Field{Name: "MaxChars", Type: "int", Doc: "maximum number of characters to include in tab label -- elides labels that are longer than that", Directives: gti.Directives{}}},
		{"TabViewSig", &gti.Field{Name: "TabViewSig", Type: "ki.Signal", Doc: "signal for tab widget -- see TabViewSignals for the types", Directives: gti.Directives{}}},
		{"NewTabButton", &gti.Field{Name: "NewTabButton", Type: "bool", Doc: "show a new tab button at right of list of tabs", Directives: gti.Directives{}}},
		{"NoDeleteTabs", &gti.Field{Name: "NoDeleteTabs", Type: "bool", Doc: "if true, tabs are not user-deleteable", Directives: gti.Directives{}}},
		{"NewTabType", &gti.Field{Name: "NewTabType", Type: "reflect.Type", Doc: "type of widget to create in a new tab via new tab button -- Frame by default", Directives: gti.Directives{}}},
		{"Mu", &gti.Field{Name: "Mu", Type: "sync.Mutex", Doc: "[view: -] mutex protecting updates to tabs -- tabs can be driven programmatically and via user input so need extra protection", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "Layout", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &TabView{},
})

// NewTabView adds a new [TabView] with
// the given name to the given parent.
func NewTabView(par ki.Ki, name string) *TabView {
	return par.NewChild(TabViewType, name).(*TabView)
}

// Type returns the [*gti.Type] of [TabView]
func (t *TabView) Type() *gti.Type {
	return TabViewType
}

// New returns a new [*TabView] value
func (t *TabView) New() ki.Ki {
	return &TabView{}
}

// WidgetBaseType is the [gti.Type] for [WidgetBase]
var WidgetBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi/v2/gi.WidgetBase",
	Doc:        "WidgetBase is the base type for all Widget Node2D elements, which are\nmanaged by a containing Layout, and use all 5 rendering passes.  All\nelemental widgets must support the Inactive and Selected states in a\nreasonable way (Selected only essential when also Inactive), so they can\nfunction appropriately in a chooser (e.g., SliceView or TableView) -- this\nincludes toggling selection on left mouse press.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Class", &gti.Field{Name: "Class", Type: "string", Doc: "user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard", Directives: gti.Directives{}}},
		{"CSS", &gti.Field{Name: "CSS", Type: "ki.Props", Doc: "cascading style sheet at this level -- these styles apply here and to everything below, until superceded -- use .class and #name Props elements to apply entire styles to given elements, and type for element type", Directives: gti.Directives{}}},
		{"CSSAgg", &gti.Field{Name: "CSSAgg", Type: "ki.Props", Doc: "[view: no-inline] aggregated css properties from all higher nodes down to me", Directives: gti.Directives{}}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", Doc: "raw original 2D bounding box for the object within its parent viewport -- used for computing VpBBox and WinBBox -- this is not updated by Move2D, whereas VpBBox etc are", Directives: gti.Directives{}}},
		{"ObjBBox", &gti.Field{Name: "ObjBBox", Type: "image.Rectangle", Doc: "full object bbox -- this is BBox + Move2D delta, but NOT intersected with parent's parBBox -- used for computing color gradients or other object-specific geometry computations", Directives: gti.Directives{}}},
		{"VpBBox", &gti.Field{Name: "VpBBox", Type: "image.Rectangle", Doc: "2D bounding box for region occupied within immediate parent Viewport object that we render onto -- these are the pixels we draw into, filtered through parent bounding boxes -- used for render Bounds clipping", Directives: gti.Directives{}}},
		{"WinBBox", &gti.Field{Name: "WinBBox", Type: "image.Rectangle", Doc: "2D bounding box for region occupied within parent Window object, projected all the way up to that -- these are the coordinates where we receive events, relative to the window", Directives: gti.Directives{}}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting access to the WinBBox, which is used for event delegation and could also be updated in another thread", Directives: gti.Directives{}}},
		{"Tooltip", &gti.Field{Name: "Tooltip", Type: "string", Doc: "text for tooltip for this widget -- can use HTML formatting", Directives: gti.Directives{}}},
		{"Stylers", &gti.Field{Name: "Stylers", Type: "[]Styler", Doc: "a slice of stylers that are called in sequential descending order (so the first added styler is called last and thus overrides all other functions) to style the element; these should be set using AddStyler, which can be called by end-user and internal code", Directives: gti.Directives{}}},
		{"OverrideStyle", &gti.Field{Name: "OverrideStyle", Type: "bool", Doc: "override the computed styles and allow directly editing Style", Directives: gti.Directives{}}},
		{"Style", &gti.Field{Name: "Style", Type: "gist.Style", Doc: "styling settings for this widget -- set in SetSetStyle during an initialization step, and when the structure changes; they are determined by, in increasing priority order, the default values, the ki node properties, and the StyleFunc (the recommended way to set styles is through the StyleFunc -- setting this field directly outside of that will have no effect unless OverrideStyle is on)", Directives: gti.Directives{}}},
		{"Parts", &gti.Field{Name: "Parts", Type: "*Layout", Doc: "a separate tree of sub-widgets that implement discrete parts of a widget -- positions are always relative to the parent widget -- fully managed by the widget and not saved", Directives: gti.Directives{}}},
		{"LayState", &gti.Field{Name: "LayState", Type: "LayoutState", Doc: "all the layout state information for this item", Directives: gti.Directives{}}},
		{"WidgetSig", &gti.Field{Name: "WidgetSig", Type: "ki.Signal", Doc: "[view: -] general widget signals supported by all widgets, including select, focus, and context menu (right mouse button) events, which can be used by views and other compound widgets", Directives: gti.Directives{}}},
		{"CtxtMenuFunc", &gti.Field{Name: "CtxtMenuFunc", Type: "CtxtMenuFunc", Doc: "[view: -] optional context menu function called by MakeContextMenu AFTER any native items are added -- this function can decide where to insert new elements -- typically add a separator to disambiguate", Directives: gti.Directives{}}},
		{"StyMu", &gti.Field{Name: "StyMu", Type: "sync.RWMutex", Doc: "[view: -] mutex protecting updates to the style", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &WidgetBase{},
})

// NewWidgetBase adds a new [WidgetBase] with
// the given name to the given parent.
func NewWidgetBase(par ki.Ki, name string) *WidgetBase {
	return par.NewChild(WidgetBaseType, name).(*WidgetBase)
}

// Type returns the [*gti.Type] of [WidgetBase]
func (t *WidgetBase) Type() *gti.Type {
	return WidgetBaseType
}

// New returns a new [*WidgetBase] value
func (t *WidgetBase) New() ki.Ki {
	return &WidgetBase{}
}
