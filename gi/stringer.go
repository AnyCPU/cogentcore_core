// Code generated by "stringer -output stringer.go -type=ActionTypes,ButtonFlags,ButtonSignals,ButtonTypes,ComboBoxTypes,CompleteSignals,DialogState,EventPris,DNDStages,Stripes,KeyFuns,LabelTypes,Layouts,RowCol,NodeFlags,FocusChanges,Densities,SliderSignals,SliderStates,SpellSignals,TabViewSignals,TextFieldTypes,TextFieldSignals,TextFieldStates,VpFlags,WidgetSignals,WinFlags"; DO NOT EDIT.

package gi

import (
	"errors"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ActionStandalone-0]
	_ = x[ActionParts-1]
	_ = x[ActionMenu-2]
	_ = x[ActionMenuBar-3]
	_ = x[ActionToolBar-4]
	_ = x[ActionTypesN-5]
}

const _ActionTypes_name = "ActionStandaloneActionPartsActionMenuActionMenuBarActionToolBarActionTypesN"

var _ActionTypes_index = [...]uint8{0, 16, 27, 37, 50, 63, 75}

func (i ActionTypes) String() string {
	if i < 0 || i >= ActionTypes(len(_ActionTypes_index)-1) {
		return "ActionTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ActionTypes_name[_ActionTypes_index[i]:_ActionTypes_index[i+1]]
}

func (i *ActionTypes) FromString(s string) error {
	for j := 0; j < len(_ActionTypes_index)-1; j++ {
		if s == _ActionTypes_name[_ActionTypes_index[j]:_ActionTypes_index[j+1]] {
			*i = ActionTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ActionTypes")
}

var _ActionTypes_descMap = map[ActionTypes]string{
	0: `ActionStandalone is a default, standalone action that is not part of a menu, menubar, toolbar, or other element`,
	1: `ActionParts is an action that is part of another element (like a clear button in a textfield)`,
	2: `ActionMenu is an action contained within a popup menu`,
	3: `ActionMenuBar is an action contained within a menu bar`,
	4: `ActionToolBar is an action contained within a toolbar`,
	5: ``,
}

func (i ActionTypes) Desc() string {
	if str, ok := _ActionTypes_descMap[i]; ok {
		return str
	}
	return "ActionTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ButtonFlagCheckable-27]
	_ = x[ButtonFlagChecked-28]
	_ = x[ButtonFlagMenu-29]
	_ = x[ButtonFlagsN-30]
}

const _ButtonFlags_name = "ButtonFlagCheckableButtonFlagCheckedButtonFlagMenuButtonFlagsN"

var _ButtonFlags_index = [...]uint8{0, 19, 36, 50, 62}

func (i ButtonFlags) String() string {
	i -= 27
	if i < 0 || i >= ButtonFlags(len(_ButtonFlags_index)-1) {
		return "ButtonFlags(" + strconv.FormatInt(int64(i+27), 10) + ")"
	}
	return _ButtonFlags_name[_ButtonFlags_index[i]:_ButtonFlags_index[i+1]]
}

func StringToButtonFlags(s string) (ButtonFlags, error) {
	for i := 0; i < len(_ButtonFlags_index)-1; i++ {
		if s == _ButtonFlags_name[_ButtonFlags_index[i]:_ButtonFlags_index[i+1]] {
			return ButtonFlags(i + 27), nil
		}
	}
	return 0, errors.New("String: " + s + " is not a valid option for type: ButtonFlags")
}

var _ButtonFlags_descMap = map[ButtonFlags]string{
	27: `button is checkable -- enables display of check control`,
	28: `button is checked`,
	29: `Menu flag means that the button is a menu item`,
	30: ``,
}

func (i ButtonFlags) Desc() string {
	if str, ok := _ButtonFlags_descMap[i]; ok {
		return str
	}
	return "ButtonFlags(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ButtonClicked-0]
	_ = x[ButtonPressed-1]
	_ = x[ButtonReleased-2]
	_ = x[ButtonToggled-3]
	_ = x[ButtonSignalsN-4]
}

const _ButtonSignals_name = "ButtonClickedButtonPressedButtonReleasedButtonToggledButtonSignalsN"

var _ButtonSignals_index = [...]uint8{0, 13, 26, 40, 53, 67}

func (i ButtonSignals) String() string {
	if i < 0 || i >= ButtonSignals(len(_ButtonSignals_index)-1) {
		return "ButtonSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ButtonSignals_name[_ButtonSignals_index[i]:_ButtonSignals_index[i+1]]
}

func (i *ButtonSignals) FromString(s string) error {
	for j := 0; j < len(_ButtonSignals_index)-1; j++ {
		if s == _ButtonSignals_name[_ButtonSignals_index[j]:_ButtonSignals_index[j+1]] {
			*i = ButtonSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ButtonSignals")
}

var _ButtonSignals_descMap = map[ButtonSignals]string{
	0: `ButtonClicked is the main signal to check for normal button activation -- button pressed down and up`,
	1: `Pressed means button pushed down but not yet up`,
	2: `Released means mouse button was released - typically look at ButtonClicked instead of this one`,
	3: `Toggled means the checked / unchecked state was toggled -- only sent for buttons with Checkable flag set`,
	4: ``,
}

func (i ButtonSignals) Desc() string {
	if str, ok := _ButtonSignals_descMap[i]; ok {
		return str
	}
	return "ButtonSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ButtonFilled-0]
	_ = x[ButtonTonal-1]
	_ = x[ButtonElevated-2]
	_ = x[ButtonOutlined-3]
	_ = x[ButtonText-4]
	_ = x[ButtonTypesN-5]
}

const _ButtonTypes_name = "ButtonFilledButtonTonalButtonElevatedButtonOutlinedButtonTextButtonTypesN"

var _ButtonTypes_index = [...]uint8{0, 12, 23, 37, 51, 61, 73}

func (i ButtonTypes) String() string {
	if i < 0 || i >= ButtonTypes(len(_ButtonTypes_index)-1) {
		return "ButtonTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ButtonTypes_name[_ButtonTypes_index[i]:_ButtonTypes_index[i+1]]
}

func (i *ButtonTypes) FromString(s string) error {
	for j := 0; j < len(_ButtonTypes_index)-1; j++ {
		if s == _ButtonTypes_name[_ButtonTypes_index[j]:_ButtonTypes_index[j+1]] {
			*i = ButtonTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ButtonTypes")
}

var _ButtonTypes_descMap = map[ButtonTypes]string{
	0: `ButtonFilled is a filled button with a contrasting background color. It should be used for prominent actions, typically those that are the final in a sequence. It is equivalent to Material Design&#39;s filled button.`,
	1: `ButtonTonal is a filled button, similar to [ButtonFilled]. It is used for the same purposes, but it has a lighter background color and less emphasis. It is equivalent to Material Design&#39;s filled tonal button.`,
	2: `ButtonElevated is an elevated button with a light background color and a shadow. It is equivalent to Material Design&#39;s elevated button.`,
	3: `ButtonOutlined is an outlined button that is used for secondary actions that are still important. It is equivalent to Material Design&#39;s outlined button.`,
	4: `ButtonText is a low-importance button with only text and/or an icon and no border, background color, or shadow. They should only be used for low emphasis actions, and you must ensure they stand out from the surrounding context sufficiently. It is equivalent to Material Design&#39;s text and icon buttons.`,
	5: ``,
}

func (i ButtonTypes) Desc() string {
	if str, ok := _ButtonTypes_descMap[i]; ok {
		return str
	}
	return "ButtonTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ComboBoxFilled-0]
	_ = x[ComboBoxOutlined-1]
	_ = x[ComboBoxTypesN-2]
}

const _ComboBoxTypes_name = "ComboBoxFilledComboBoxOutlinedComboBoxTypesN"

var _ComboBoxTypes_index = [...]uint8{0, 14, 30, 44}

func (i ComboBoxTypes) String() string {
	if i < 0 || i >= ComboBoxTypes(len(_ComboBoxTypes_index)-1) {
		return "ComboBoxTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ComboBoxTypes_name[_ComboBoxTypes_index[i]:_ComboBoxTypes_index[i+1]]
}

func (i *ComboBoxTypes) FromString(s string) error {
	for j := 0; j < len(_ComboBoxTypes_index)-1; j++ {
		if s == _ComboBoxTypes_name[_ComboBoxTypes_index[j]:_ComboBoxTypes_index[j+1]] {
			*i = ComboBoxTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ComboBoxTypes")
}

var _ComboBoxTypes_descMap = map[ComboBoxTypes]string{
	0: `ComboBoxFilled represents a filled ComboBox with a background color and a bottom border`,
	1: `ComboBoxOutlined represents an outlined ComboBox with a border on all sides and no background color`,
	2: ``,
}

func (i ComboBoxTypes) Desc() string {
	if str, ok := _ComboBoxTypes_descMap[i]; ok {
		return str
	}
	return "ComboBoxTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[CompleteSelect-0]
	_ = x[CompleteExtend-1]
}

const _CompleteSignals_name = "CompleteSelectCompleteExtend"

var _CompleteSignals_index = [...]uint8{0, 14, 28}

func (i CompleteSignals) String() string {
	if i < 0 || i >= CompleteSignals(len(_CompleteSignals_index)-1) {
		return "CompleteSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _CompleteSignals_name[_CompleteSignals_index[i]:_CompleteSignals_index[i+1]]
}

func (i *CompleteSignals) FromString(s string) error {
	for j := 0; j < len(_CompleteSignals_index)-1; j++ {
		if s == _CompleteSignals_name[_CompleteSignals_index[j]:_CompleteSignals_index[j+1]] {
			*i = CompleteSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: CompleteSignals")
}

var _CompleteSignals_descMap = map[CompleteSignals]string{
	0: `CompleteSelect means the user chose one of the possible completions`,
	1: `CompleteExtend means user has requested that the seed extend if all completions have a common prefix longer than current seed`,
}

func (i CompleteSignals) Desc() string {
	if str, ok := _CompleteSignals_descMap[i]; ok {
		return str
	}
	return "CompleteSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[DialogExists-0]
	_ = x[DialogOpenModal-1]
	_ = x[DialogOpenModeless-2]
	_ = x[DialogAccepted-3]
	_ = x[DialogCanceled-4]
	_ = x[DialogStateN-5]
}

const _DialogState_name = "DialogExistsDialogOpenModalDialogOpenModelessDialogAcceptedDialogCanceledDialogStateN"

var _DialogState_index = [...]uint8{0, 12, 27, 45, 59, 73, 85}

func (i DialogState) String() string {
	if i < 0 || i >= DialogState(len(_DialogState_index)-1) {
		return "DialogState(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _DialogState_name[_DialogState_index[i]:_DialogState_index[i+1]]
}

func (i *DialogState) FromString(s string) error {
	for j := 0; j < len(_DialogState_index)-1; j++ {
		if s == _DialogState_name[_DialogState_index[j]:_DialogState_index[j+1]] {
			*i = DialogState(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: DialogState")
}

var _DialogState_descMap = map[DialogState]string{
	0: `DialogExists is the existential state -- struct exists and is likely being constructed.`,
	1: `DialogOpenModal means dialog is open in a modal state, blocking all other input.`,
	2: `DialogOpenModeless means dialog is open in a modeless state, allowing other input.`,
	3: `DialogAccepted means Ok was pressed -- dialog accepted.`,
	4: `DialogCanceled means Cancel was pressed -- button canceled.`,
	5: ``,
}

func (i DialogState) Desc() string {
	if str, ok := _DialogState_descMap[i]; ok {
		return str
	}
	return "DialogState(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[HiPri-0]
	_ = x[RegPri-1]
	_ = x[LowPri-2]
	_ = x[LowRawPri-3]
	_ = x[EventPrisN-4]
	_ = x[AllPris - -1]
}

const _EventPris_name = "AllPrisHiPriRegPriLowPriLowRawPriEventPrisN"

var _EventPris_index = [...]uint8{0, 7, 12, 18, 24, 33, 43}

func (i EventPris) String() string {
	i -= -1
	if i < 0 || i >= EventPris(len(_EventPris_index)-1) {
		return "EventPris(" + strconv.FormatInt(int64(i+-1), 10) + ")"
	}
	return _EventPris_name[_EventPris_index[i]:_EventPris_index[i+1]]
}

func StringToEventPris(s string) (EventPris, error) {
	for i := 0; i < len(_EventPris_index)-1; i++ {
		if s == _EventPris_name[_EventPris_index[i]:_EventPris_index[i+1]] {
			return EventPris(i + -1), nil
		}
	}
	return 0, errors.New("String: " + s + " is not a valid option for type: EventPris")
}

var _EventPris_descMap = map[EventPris]string{
	-1: `AllPris = -1 = all priorities (for delete cases only)`,
	0:  `HiPri = high priority -- event receivers processed first -- can be used to override default behavior`,
	1:  `RegPri = default regular priority -- most should be here`,
	2:  `LowPri = low priority -- processed last -- typically for containers / dialogs etc`,
	3:  `LowRawPri = unfiltered (raw) low priority -- ignores whether the event was already processed.`,
	4:  ``,
}

func (i EventPris) Desc() string {
	if str, ok := _EventPris_descMap[i]; ok {
		return str
	}
	return "EventPris(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[DNDNotStarted-0]
	_ = x[DNDStartSent-1]
	_ = x[DNDStarted-2]
	_ = x[DNDDropped-3]
	_ = x[DNDStagesN-4]
}

const _DNDStages_name = "DNDNotStartedDNDStartSentDNDStartedDNDDroppedDNDStagesN"

var _DNDStages_index = [...]uint8{0, 13, 25, 35, 45, 55}

func (i DNDStages) String() string {
	if i < 0 || i >= DNDStages(len(_DNDStages_index)-1) {
		return "DNDStages(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _DNDStages_name[_DNDStages_index[i]:_DNDStages_index[i+1]]
}

func (i *DNDStages) FromString(s string) error {
	for j := 0; j < len(_DNDStages_index)-1; j++ {
		if s == _DNDStages_name[_DNDStages_index[j]:_DNDStages_index[j+1]] {
			*i = DNDStages(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: DNDStages")
}

var _DNDStages_descMap = map[DNDStages]string{
	0: `DNDNotStarted = nothing happening`,
	1: `DNDStartSent means that the Start event was sent out, but receiver has not yet started the DND on its end by calling StartDragNDrop`,
	2: `DNDStarted means that a node called StartDragNDrop`,
	3: `DNDDropped means that drop event has been sent`,
	4: ``,
}

func (i DNDStages) Desc() string {
	if str, ok := _DNDStages_descMap[i]; ok {
		return str
	}
	return "DNDStages(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[NoStripes-0]
	_ = x[RowStripes-1]
	_ = x[ColStripes-2]
	_ = x[StripesN-3]
}

const _Stripes_name = "NoStripesRowStripesColStripesStripesN"

var _Stripes_index = [...]uint8{0, 9, 19, 29, 37}

func (i Stripes) String() string {
	if i < 0 || i >= Stripes(len(_Stripes_index)-1) {
		return "Stripes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Stripes_name[_Stripes_index[i]:_Stripes_index[i+1]]
}

func (i *Stripes) FromString(s string) error {
	for j := 0; j < len(_Stripes_index)-1; j++ {
		if s == _Stripes_name[_Stripes_index[j]:_Stripes_index[j+1]] {
			*i = Stripes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: Stripes")
}

var _Stripes_descMap = map[Stripes]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i Stripes) Desc() string {
	if str, ok := _Stripes_descMap[i]; ok {
		return str
	}
	return "Stripes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[KeyFunNil-0]
	_ = x[KeyFunMoveUp-1]
	_ = x[KeyFunMoveDown-2]
	_ = x[KeyFunMoveRight-3]
	_ = x[KeyFunMoveLeft-4]
	_ = x[KeyFunPageUp-5]
	_ = x[KeyFunPageDown-6]
	_ = x[KeyFunHome-7]
	_ = x[KeyFunEnd-8]
	_ = x[KeyFunDocHome-9]
	_ = x[KeyFunDocEnd-10]
	_ = x[KeyFunWordRight-11]
	_ = x[KeyFunWordLeft-12]
	_ = x[KeyFunFocusNext-13]
	_ = x[KeyFunFocusPrev-14]
	_ = x[KeyFunEnter-15]
	_ = x[KeyFunAccept-16]
	_ = x[KeyFunCancelSelect-17]
	_ = x[KeyFunSelectMode-18]
	_ = x[KeyFunSelectAll-19]
	_ = x[KeyFunAbort-20]
	_ = x[KeyFunCopy-21]
	_ = x[KeyFunCut-22]
	_ = x[KeyFunPaste-23]
	_ = x[KeyFunPasteHist-24]
	_ = x[KeyFunBackspace-25]
	_ = x[KeyFunBackspaceWord-26]
	_ = x[KeyFunDelete-27]
	_ = x[KeyFunDeleteWord-28]
	_ = x[KeyFunKill-29]
	_ = x[KeyFunDuplicate-30]
	_ = x[KeyFunTranspose-31]
	_ = x[KeyFunTransposeWord-32]
	_ = x[KeyFunUndo-33]
	_ = x[KeyFunRedo-34]
	_ = x[KeyFunInsert-35]
	_ = x[KeyFunInsertAfter-36]
	_ = x[KeyFunZoomOut-37]
	_ = x[KeyFunZoomIn-38]
	_ = x[KeyFunPrefs-39]
	_ = x[KeyFunRefresh-40]
	_ = x[KeyFunRecenter-41]
	_ = x[KeyFunComplete-42]
	_ = x[KeyFunLookup-43]
	_ = x[KeyFunSearch-44]
	_ = x[KeyFunFind-45]
	_ = x[KeyFunReplace-46]
	_ = x[KeyFunJump-47]
	_ = x[KeyFunHistPrev-48]
	_ = x[KeyFunHistNext-49]
	_ = x[KeyFunMenu-50]
	_ = x[KeyFunWinFocusNext-51]
	_ = x[KeyFunWinClose-52]
	_ = x[KeyFunWinSnapshot-53]
	_ = x[KeyFunGoGiEditor-54]
	_ = x[KeyFunMenuNew-55]
	_ = x[KeyFunMenuNewAlt1-56]
	_ = x[KeyFunMenuNewAlt2-57]
	_ = x[KeyFunMenuOpen-58]
	_ = x[KeyFunMenuOpenAlt1-59]
	_ = x[KeyFunMenuOpenAlt2-60]
	_ = x[KeyFunMenuSave-61]
	_ = x[KeyFunMenuSaveAs-62]
	_ = x[KeyFunMenuSaveAlt-63]
	_ = x[KeyFunMenuCloseAlt1-64]
	_ = x[KeyFunMenuCloseAlt2-65]
	_ = x[KeyFunsN-66]
}

const _KeyFuns_name = "KeyFunNilKeyFunMoveUpKeyFunMoveDownKeyFunMoveRightKeyFunMoveLeftKeyFunPageUpKeyFunPageDownKeyFunHomeKeyFunEndKeyFunDocHomeKeyFunDocEndKeyFunWordRightKeyFunWordLeftKeyFunFocusNextKeyFunFocusPrevKeyFunEnterKeyFunAcceptKeyFunCancelSelectKeyFunSelectModeKeyFunSelectAllKeyFunAbortKeyFunCopyKeyFunCutKeyFunPasteKeyFunPasteHistKeyFunBackspaceKeyFunBackspaceWordKeyFunDeleteKeyFunDeleteWordKeyFunKillKeyFunDuplicateKeyFunTransposeKeyFunTransposeWordKeyFunUndoKeyFunRedoKeyFunInsertKeyFunInsertAfterKeyFunZoomOutKeyFunZoomInKeyFunPrefsKeyFunRefreshKeyFunRecenterKeyFunCompleteKeyFunLookupKeyFunSearchKeyFunFindKeyFunReplaceKeyFunJumpKeyFunHistPrevKeyFunHistNextKeyFunMenuKeyFunWinFocusNextKeyFunWinCloseKeyFunWinSnapshotKeyFunGoGiEditorKeyFunMenuNewKeyFunMenuNewAlt1KeyFunMenuNewAlt2KeyFunMenuOpenKeyFunMenuOpenAlt1KeyFunMenuOpenAlt2KeyFunMenuSaveKeyFunMenuSaveAsKeyFunMenuSaveAltKeyFunMenuCloseAlt1KeyFunMenuCloseAlt2KeyFunsN"

var _KeyFuns_index = [...]uint16{0, 9, 21, 35, 50, 64, 76, 90, 100, 109, 122, 134, 149, 163, 178, 193, 204, 216, 234, 250, 265, 276, 286, 295, 306, 321, 336, 355, 367, 383, 393, 408, 423, 442, 452, 462, 474, 491, 504, 516, 527, 540, 554, 568, 580, 592, 602, 615, 625, 639, 653, 663, 681, 695, 712, 728, 741, 758, 775, 789, 807, 825, 839, 855, 872, 891, 910, 918}

func (i KeyFuns) String() string {
	if i < 0 || i >= KeyFuns(len(_KeyFuns_index)-1) {
		return "KeyFuns(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _KeyFuns_name[_KeyFuns_index[i]:_KeyFuns_index[i+1]]
}

func (i *KeyFuns) FromString(s string) error {
	for j := 0; j < len(_KeyFuns_index)-1; j++ {
		if s == _KeyFuns_name[_KeyFuns_index[j]:_KeyFuns_index[j+1]] {
			*i = KeyFuns(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: KeyFuns")
}

var _KeyFuns_descMap = map[KeyFuns]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  `KeyFunPageRight KeyFunPageLeft`,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
	20: ``,
	21: `KeyFunEditItem`,
	22: ``,
	23: ``,
	24: ``,
	25: ``,
	26: ``,
	27: ``,
	28: ``,
	29: ``,
	30: ``,
	31: ``,
	32: ``,
	33: ``,
	34: ``,
	35: ``,
	36: ``,
	37: ``,
	38: ``,
	39: ``,
	40: ``,
	41: ``,
	42: ``,
	43: ``,
	44: ``,
	45: ``,
	46: ``,
	47: ``,
	48: ``,
	49: ``,
	50: ``,
	51: ``,
	52: ``,
	53: ``,
	54: ``,
	55: `Below are menu specific functions -- use these as shortcuts for menu actions allows uniqueness of mapping and easy customization of all key actions`,
	56: ``,
	57: ``,
	58: ``,
	59: ``,
	60: ``,
	61: ``,
	62: ``,
	63: ``,
	64: ``,
	65: ``,
	66: ``,
}

func (i KeyFuns) Desc() string {
	if str, ok := _KeyFuns_descMap[i]; ok {
		return str
	}
	return "KeyFuns(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[LabelDisplayLarge-0]
	_ = x[LabelDisplayMedium-1]
	_ = x[LabelDisplaySmall-2]
	_ = x[LabelHeadlineLarge-3]
	_ = x[LabelHeadlineMedium-4]
	_ = x[LabelHeadlineSmall-5]
	_ = x[LabelTitleLarge-6]
	_ = x[LabelTitleMedium-7]
	_ = x[LabelTitleSmall-8]
	_ = x[LabelBodyLarge-9]
	_ = x[LabelBodyMedium-10]
	_ = x[LabelBodySmall-11]
	_ = x[LabelLabelLarge-12]
	_ = x[LabelLabelMedium-13]
	_ = x[LabelLabelSmall-14]
	_ = x[LabelTypesN-15]
}

const _LabelTypes_name = "LabelDisplayLargeLabelDisplayMediumLabelDisplaySmallLabelHeadlineLargeLabelHeadlineMediumLabelHeadlineSmallLabelTitleLargeLabelTitleMediumLabelTitleSmallLabelBodyLargeLabelBodyMediumLabelBodySmallLabelLabelLargeLabelLabelMediumLabelLabelSmallLabelTypesN"

var _LabelTypes_index = [...]uint8{0, 17, 35, 52, 70, 89, 107, 122, 138, 153, 167, 182, 196, 211, 227, 242, 253}

func (i LabelTypes) String() string {
	if i < 0 || i >= LabelTypes(len(_LabelTypes_index)-1) {
		return "LabelTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _LabelTypes_name[_LabelTypes_index[i]:_LabelTypes_index[i+1]]
}

func (i *LabelTypes) FromString(s string) error {
	for j := 0; j < len(_LabelTypes_index)-1; j++ {
		if s == _LabelTypes_name[_LabelTypes_index[j]:_LabelTypes_index[j+1]] {
			*i = LabelTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: LabelTypes")
}

var _LabelTypes_descMap = map[LabelTypes]string{
	0:  `LabelDisplayLarge is a large, short, and important display label with a default font size of 57px.`,
	1:  `LabelDisplayMedium is a medium-sized, short, and important display label with a default font size of 45px.`,
	2:  `LabelDisplaySmall is a small, short, and important display label with a default font size of 36px.`,
	3:  `LabelHeadlineLarge is a large, high-emphasis headline label with a default font size of 32px.`,
	4:  `LabelHeadlineMedium is a medium-sized, high-emphasis headline label with a default font size of 28px.`,
	5:  `LabelHeadlineSmall is a small, high-emphasis headline label with a default font size of 24px.`,
	6:  `LabelTitleLarge is a large, medium-emphasis title label with a default font size of 22px.`,
	7:  `LabelTitleMedium is a medium-sized, medium-emphasis title label with a default font size of 16px.`,
	8:  `LabelTitleSmall is a small, medium-emphasis title label with a default font size of 14px.`,
	9:  `LabelBodyLarge is a large body label used for longer passages of text with a default font size of 16px.`,
	10: `LabelBodyMedium is a medium-sized body label used for longer passages of text with a default font size of 14px.`,
	11: `LabelBodySmall is a small body label used for longer passages of text with a default font size of 12px.`,
	12: `LabelLabelLarge is a large label used for label text (like a caption or the text inside a button) with a default font size of 14px.`,
	13: `LabelLabelMedium is a medium-sized label used for label text (like a caption or the text inside a button) with a default font size of 12px.`,
	14: `LabelLabelSmall is a small label used for label text (like a caption or the text inside a button) with a default font size of 11px.`,
	15: ``,
}

func (i LabelTypes) Desc() string {
	if str, ok := _LabelTypes_descMap[i]; ok {
		return str
	}
	return "LabelTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[LayoutHoriz-0]
	_ = x[LayoutVert-1]
	_ = x[LayoutGrid-2]
	_ = x[LayoutHorizFlow-3]
	_ = x[LayoutVertFlow-4]
	_ = x[LayoutStacked-5]
	_ = x[LayoutNil-6]
	_ = x[LayoutsN-7]
}

const _Layouts_name = "LayoutHorizLayoutVertLayoutGridLayoutHorizFlowLayoutVertFlowLayoutStackedLayoutNilLayoutsN"

var _Layouts_index = [...]uint8{0, 11, 21, 31, 46, 60, 73, 82, 90}

func (i Layouts) String() string {
	if i < 0 || i >= Layouts(len(_Layouts_index)-1) {
		return "Layouts(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Layouts_name[_Layouts_index[i]:_Layouts_index[i+1]]
}

func (i *Layouts) FromString(s string) error {
	for j := 0; j < len(_Layouts_index)-1; j++ {
		if s == _Layouts_name[_Layouts_index[j]:_Layouts_index[j+1]] {
			*i = Layouts(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: Layouts")
}

var _Layouts_descMap = map[Layouts]string{
	0: `LayoutHoriz arranges items horizontally across a row`,
	1: `LayoutVert arranges items vertically in a column`,
	2: `LayoutGrid arranges items according to a regular grid`,
	3: `LayoutHorizFlow arranges items horizontally across a row, overflowing vertically as needed. Ballpark target width or height props should be set to generate initial first-pass sizing estimates.`,
	4: `LayoutVertFlow arranges items vertically within a column, overflowing horizontally as needed. Ballpark target width or height props should be set to generate initial first-pass sizing estimates.`,
	5: `LayoutStacked arranges items stacked on top of each other -- Top index indicates which to show -- overall size accommodates largest in each dimension`,
	6: `LayoutNil is a nil layout -- doesn&#39;t do anything -- for cases when a parent wants to take over the job of the layout`,
	7: ``,
}

func (i Layouts) Desc() string {
	if str, ok := _Layouts_descMap[i]; ok {
		return str
	}
	return "Layouts(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[Row-0]
	_ = x[Col-1]
	_ = x[RowColN-2]
}

const _RowCol_name = "RowColRowColN"

var _RowCol_index = [...]uint8{0, 3, 6, 13}

func (i RowCol) String() string {
	if i < 0 || i >= RowCol(len(_RowCol_index)-1) {
		return "RowCol(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _RowCol_name[_RowCol_index[i]:_RowCol_index[i+1]]
}

func (i *RowCol) FromString(s string) error {
	for j := 0; j < len(_RowCol_index)-1; j++ {
		if s == _RowCol_name[_RowCol_index[j]:_RowCol_index[j+1]] {
			*i = RowCol(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: RowCol")
}

var _RowCol_descMap = map[RowCol]string{
	0: ``,
	1: ``,
	2: ``,
}

func (i RowCol) Desc() string {
	if str, ok := _RowCol_descMap[i]; ok {
		return str
	}
	return "RowCol(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[NoLayout-11]
	_ = x[EventsConnected-12]
	_ = x[CanFocus-13]
	_ = x[HasFocus-14]
	_ = x[FullReRender-15]
	_ = x[NeedsStyle-16]
	_ = x[ReRenderAnchor-17]
	_ = x[Invisible-18]
	_ = x[Disabled-19]
	_ = x[Selected-20]
	_ = x[Hovered-21]
	_ = x[Active-22]
	_ = x[MouseHasEntered-23]
	_ = x[DNDHasEntered-24]
	_ = x[NodeDragging-25]
	_ = x[InstaDrag-26]
	_ = x[NodeFlagsN-27]
	_ = x[TextFieldFocusActive-27]
}

const _NodeFlags_name = "NoLayoutEventsConnectedCanFocusHasFocusFullReRenderNeedsStyleReRenderAnchorInvisibleDisabledSelectedHoveredActiveMouseHasEnteredDNDHasEnteredNodeDraggingInstaDragNodeFlagsN"

var _NodeFlags_index = [...]uint8{0, 8, 23, 31, 39, 51, 61, 75, 84, 92, 100, 107, 113, 128, 141, 153, 162, 172}

func (i NodeFlags) String() string {
	i -= 11
	if i < 0 || i >= NodeFlags(len(_NodeFlags_index)-1) {
		return "NodeFlags(" + strconv.FormatInt(int64(i+11), 10) + ")"
	}
	return _NodeFlags_name[_NodeFlags_index[i]:_NodeFlags_index[i+1]]
}

func StringToNodeFlags(s string) (NodeFlags, error) {
	for i := 0; i < len(_NodeFlags_index)-1; i++ {
		if s == _NodeFlags_name[_NodeFlags_index[i]:_NodeFlags_index[i+1]] {
			return NodeFlags(i + 11), nil
		}
	}
	return 0, errors.New("String: " + s + " is not a valid option for type: NodeFlags")
}

var _NodeFlags_descMap = map[NodeFlags]string{
	11: `NoLayout means that this node does not participate in the layout process (Size, Layout, Move) -- set by e.g., SVG nodes`,
	12: `EventsConnected: this node has been connected to receive events from the window -- to optimize event processing, connections are typically only established for visible nodes during render, and disconnected when not visible`,
	13: `CanFocus: can this node accept focus to receive keyboard input events -- set by default for typical nodes that do so, but can be overridden, including by the style &#39;can-focus&#39; property`,
	14: `HasFocus: does this node currently have the focus for keyboard input events? use tab / alt tab and clicking events to update focus -- see interface on Window`,
	15: `FullReRender indicates that a full re-render is required due to nature of update event -- otherwise default is local re-render -- used internally for nodes to determine what to do on the ReRender step`,
	16: `NeedsStyle indicates that a node needs to be styled again before being rendered.`,
	17: `ReRenderAnchor: this node has a static size, and repaints its background -- any children under it that need to dynamically resize on a ReRender (Update) can refer the update up to rerendering this node, instead of going further up the tree -- e.g., true of Frame&#39;s within a SplitView`,
	18: `Invisible means that the node has been marked as invisible by a parent that has switch-like powers (e.g., layout stacked / tabview or splitter panel that has been collapsed). This flag is propagated down to all child nodes, and rendering or other interaction / update routines should not run when this flag is set (PushBounds does this for most cases). However, it IS a good idea to have styling, layout etc all take place as normal, so that when the flag is cleared, rendering can proceed directly.`,
	19: `Disabled disables all interaction with the user or other nodes; nodes should indicate this disabled state in an appropriate way, and each node should interpret events appropriately based on this state`,
	20: `Selected indicates that this node has been selected by the user -- widely supported across different nodes`,
	21: `Hovered indicates that the node is being hovered over by a mouse cursor or has been long-pressed on mobile`,
	22: `Active indicates that this node is currently being interacted with (typically pressed down) by the user`,
	23: `MouseHasEntered indicates that the MouseFocusEvent Enter was previously registered on this node`,
	24: `DNDHasEntered indicates that the DNDFocusEvent Enter was previously registered on this node`,
	25: `NodeDragging indicates this node is currently dragging -- win.Dragging set to this node`,
	26: `InstaDrag indicates this node should start dragging immediately when clicked -- otherwise there is a time-and-distance threshold to the start of dragging -- use this for controls that are small and are primarily about dragging (e.g., the Splitter handle)`,
	27: `can extend node flags from here`,
}

func (i NodeFlags) Desc() string {
	if str, ok := _NodeFlags_descMap[i]; ok {
		return str
	}
	return "NodeFlags(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[FocusLost-0]
	_ = x[FocusGot-1]
	_ = x[FocusInactive-2]
	_ = x[FocusActive-3]
	_ = x[FocusChangesN-4]
}

const _FocusChanges_name = "FocusLostFocusGotFocusInactiveFocusActiveFocusChangesN"

var _FocusChanges_index = [...]uint8{0, 9, 17, 30, 41, 54}

func (i FocusChanges) String() string {
	if i < 0 || i >= FocusChanges(len(_FocusChanges_index)-1) {
		return "FocusChanges(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FocusChanges_name[_FocusChanges_index[i]:_FocusChanges_index[i+1]]
}

func (i *FocusChanges) FromString(s string) error {
	for j := 0; j < len(_FocusChanges_index)-1; j++ {
		if s == _FocusChanges_name[_FocusChanges_index[j]:_FocusChanges_index[j+1]] {
			*i = FocusChanges(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FocusChanges")
}

var _FocusChanges_descMap = map[FocusChanges]string{
	0: `FocusLost means that keyboard focus is on a different widget (typically) and this one lost focus`,
	1: `FocusGot means that this widget just got keyboard focus`,
	2: `FocusInactive means that although this widget retains keyboard focus (nobody else has it), the user has clicked on something else and therefore the focus should be considered inactive (distracted), and any changes should be applied as this other action could result in closing of a dialog etc. Keyboard events will still be sent to the focus widget, but it is up to the widget if or how to process them (e.g., it could reactivate on its own).`,
	3: `FocusActive means that the user has moved the mouse back into the focused widget to resume active keyboard focus.`,
	4: ``,
}

func (i FocusChanges) Desc() string {
	if str, ok := _FocusChanges_descMap[i]; ok {
		return str
	}
	return "FocusChanges(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[DensityCompact-0]
	_ = x[DensityMedium-1]
	_ = x[DensitySpread-2]
	_ = x[DensitiesN-3]
}

const _Densities_name = "DensityCompactDensityMediumDensitySpreadDensitiesN"

var _Densities_index = [...]uint8{0, 14, 27, 40, 50}

func (i Densities) String() string {
	if i < 0 || i >= Densities(len(_Densities_index)-1) {
		return "Densities(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Densities_name[_Densities_index[i]:_Densities_index[i+1]]
}

func (i *Densities) FromString(s string) error {
	for j := 0; j < len(_Densities_index)-1; j++ {
		if s == _Densities_name[_Densities_index[j]:_Densities_index[j+1]] {
			*i = Densities(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: Densities")
}

var _Densities_descMap = map[Densities]string{
	0: `DensityCompact represents a compact density with minimal whitespace`,
	1: `DensityMedium represents a medium density with medium whitespace`,
	2: `DensitySpread represents a spread-out density with a lot of whitespace`,
	3: ``,
}

func (i Densities) Desc() string {
	if str, ok := _Densities_descMap[i]; ok {
		return str
	}
	return "Densities(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[SliderValueChanged-0]
	_ = x[SliderPressed-1]
	_ = x[SliderReleased-2]
	_ = x[SliderMoved-3]
	_ = x[SliderSignalsN-4]
}

const _SliderSignals_name = "SliderValueChangedSliderPressedSliderReleasedSliderMovedSliderSignalsN"

var _SliderSignals_index = [...]uint8{0, 18, 31, 45, 56, 70}

func (i SliderSignals) String() string {
	if i < 0 || i >= SliderSignals(len(_SliderSignals_index)-1) {
		return "SliderSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _SliderSignals_name[_SliderSignals_index[i]:_SliderSignals_index[i+1]]
}

func (i *SliderSignals) FromString(s string) error {
	for j := 0; j < len(_SliderSignals_index)-1; j++ {
		if s == _SliderSignals_name[_SliderSignals_index[j]:_SliderSignals_index[j+1]] {
			*i = SliderSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: SliderSignals")
}

var _SliderSignals_descMap = map[SliderSignals]string{
	0: `SliderValueChanged indicates that the value has changed -- if tracking is enabled, then this tracks online changes -- otherwise only at the end. The data on the signal is the float32 Value.`,
	1: `SliderPressed means slider was pushed down but not yet up.`,
	2: `SliderReleased means the slider has been released after being pressed.`,
	3: `SliderMoved means the slider position has moved (low level move event).`,
	4: ``,
}

func (i SliderSignals) Desc() string {
	if str, ok := _SliderSignals_descMap[i]; ok {
		return str
	}
	return "SliderSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[SliderActive-0]
	_ = x[SliderInactive-1]
	_ = x[SliderHover-2]
	_ = x[SliderFocus-3]
	_ = x[SliderDown-4]
	_ = x[SliderSelected-5]
	_ = x[SliderValue-6]
	_ = x[SliderBox-7]
	_ = x[SliderStatesN-8]
}

const _SliderStates_name = "SliderActiveSliderInactiveSliderHoverSliderFocusSliderDownSliderSelectedSliderValueSliderBoxSliderStatesN"

var _SliderStates_index = [...]uint8{0, 12, 26, 37, 48, 58, 72, 83, 92, 105}

func (i SliderStates) String() string {
	if i < 0 || i >= SliderStates(len(_SliderStates_index)-1) {
		return "SliderStates(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _SliderStates_name[_SliderStates_index[i]:_SliderStates_index[i+1]]
}

func (i *SliderStates) FromString(s string) error {
	for j := 0; j < len(_SliderStates_index)-1; j++ {
		if s == _SliderStates_name[_SliderStates_index[j]:_SliderStates_index[j+1]] {
			*i = SliderStates(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: SliderStates")
}

var _SliderStates_descMap = map[SliderStates]string{
	0: `normal state -- there but not being interacted with`,
	1: `inactive -- not responsive`,
	2: `mouse is hovering over the slider`,
	3: `slider is the focus -- will respond to keyboard input`,
	4: `slider is currently being pressed down`,
	5: `slider has been selected`,
	6: `use background-color here to fill in selected value of slider`,
	7: `these styles define the overall box around slider -- typically no border and a white background -- needs a background to allow local re-rendering`,
	8: `total number of slider states`,
}

func (i SliderStates) Desc() string {
	if str, ok := _SliderStates_descMap[i]; ok {
		return str
	}
	return "SliderStates(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[SpellSelect-0]
	_ = x[SpellIgnore-1]
}

const _SpellSignals_name = "SpellSelectSpellIgnore"

var _SpellSignals_index = [...]uint8{0, 11, 22}

func (i SpellSignals) String() string {
	if i < 0 || i >= SpellSignals(len(_SpellSignals_index)-1) {
		return "SpellSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _SpellSignals_name[_SpellSignals_index[i]:_SpellSignals_index[i+1]]
}

func (i *SpellSignals) FromString(s string) error {
	for j := 0; j < len(_SpellSignals_index)-1; j++ {
		if s == _SpellSignals_name[_SpellSignals_index[j]:_SpellSignals_index[j+1]] {
			*i = SpellSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: SpellSignals")
}

var _SpellSignals_descMap = map[SpellSignals]string{
	0: `SpellSelect means the user chose one of the possible corrections`,
	1: `SpellIgnore signals the user chose ignore so clear the tag`,
}

func (i SpellSignals) Desc() string {
	if str, ok := _SpellSignals_descMap[i]; ok {
		return str
	}
	return "SpellSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TabSelected-0]
	_ = x[TabAdded-1]
	_ = x[TabDeleted-2]
	_ = x[TabViewSignalsN-3]
}

const _TabViewSignals_name = "TabSelectedTabAddedTabDeletedTabViewSignalsN"

var _TabViewSignals_index = [...]uint8{0, 11, 19, 29, 44}

func (i TabViewSignals) String() string {
	if i < 0 || i >= TabViewSignals(len(_TabViewSignals_index)-1) {
		return "TabViewSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TabViewSignals_name[_TabViewSignals_index[i]:_TabViewSignals_index[i+1]]
}

func (i *TabViewSignals) FromString(s string) error {
	for j := 0; j < len(_TabViewSignals_index)-1; j++ {
		if s == _TabViewSignals_name[_TabViewSignals_index[j]:_TabViewSignals_index[j+1]] {
			*i = TabViewSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TabViewSignals")
}

var _TabViewSignals_descMap = map[TabViewSignals]string{
	0: `TabSelected indicates tab was selected -- data is the tab index`,
	1: `TabAdded indicates tab was added -- data is the tab index`,
	2: `TabDeleted indicates tab was deleted -- data is the tab name`,
	3: ``,
}

func (i TabViewSignals) Desc() string {
	if str, ok := _TabViewSignals_descMap[i]; ok {
		return str
	}
	return "TabViewSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TextFieldFilled-0]
	_ = x[TextFieldOutlined-1]
	_ = x[TextFieldTypesN-2]
}

const _TextFieldTypes_name = "TextFieldFilledTextFieldOutlinedTextFieldTypesN"

var _TextFieldTypes_index = [...]uint8{0, 15, 32, 47}

func (i TextFieldTypes) String() string {
	if i < 0 || i >= TextFieldTypes(len(_TextFieldTypes_index)-1) {
		return "TextFieldTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextFieldTypes_name[_TextFieldTypes_index[i]:_TextFieldTypes_index[i+1]]
}

func (i *TextFieldTypes) FromString(s string) error {
	for j := 0; j < len(_TextFieldTypes_index)-1; j++ {
		if s == _TextFieldTypes_name[_TextFieldTypes_index[j]:_TextFieldTypes_index[j+1]] {
			*i = TextFieldTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextFieldTypes")
}

var _TextFieldTypes_descMap = map[TextFieldTypes]string{
	0: `TextFieldFilled represents a filled TextField with a background color and a bottom border`,
	1: `TextFieldOutlined represents an outlined TextField with a border on all sides and no background color`,
	2: ``,
}

func (i TextFieldTypes) Desc() string {
	if str, ok := _TextFieldTypes_descMap[i]; ok {
		return str
	}
	return "TextFieldTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TextFieldDone-0]
	_ = x[TextFieldDeFocused-1]
	_ = x[TextFieldSelected-2]
	_ = x[TextFieldCleared-3]
	_ = x[TextFieldInsert-4]
	_ = x[TextFieldBackspace-5]
	_ = x[TextFieldDelete-6]
	_ = x[TextFieldSignalsN-7]
}

const _TextFieldSignals_name = "TextFieldDoneTextFieldDeFocusedTextFieldSelectedTextFieldClearedTextFieldInsertTextFieldBackspaceTextFieldDeleteTextFieldSignalsN"

var _TextFieldSignals_index = [...]uint8{0, 13, 31, 48, 64, 79, 97, 112, 129}

func (i TextFieldSignals) String() string {
	if i < 0 || i >= TextFieldSignals(len(_TextFieldSignals_index)-1) {
		return "TextFieldSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextFieldSignals_name[_TextFieldSignals_index[i]:_TextFieldSignals_index[i+1]]
}

func (i *TextFieldSignals) FromString(s string) error {
	for j := 0; j < len(_TextFieldSignals_index)-1; j++ {
		if s == _TextFieldSignals_name[_TextFieldSignals_index[j]:_TextFieldSignals_index[j+1]] {
			*i = TextFieldSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextFieldSignals")
}

var _TextFieldSignals_descMap = map[TextFieldSignals]string{
	0: `TextFieldDone is main signal -- return or tab was pressed and the edit was intentionally completed. data is the text.`,
	1: `TextFieldDeFocused means that the user has transitioned focus away from the text field due to interactions elsewhere, and any ongoing changes have been applied and the editor is no longer active. data is the text. If you have a button that performs the same action as pressing enter in a textfield, then pressing that button will trigger a TextFieldDeFocused event, for any active edits. Otherwise, you probably want to respond to both TextFieldDone and TextFieldDeFocused as &#34;apply&#34; events that trigger actions associated with the field.`,
	2: `TextFieldSelected means that some text was selected (for Inactive state, selection is via WidgetSig)`,
	3: `TextFieldCleared means the clear button was clicked`,
	4: `TextFieldInsert is emitted when a character is inserted into the textfield`,
	5: `TextFieldBackspace is emitted when a character before cursor is deleted`,
	6: `TextFieldDelete is emitted when a character after cursor is deleted`,
	7: ``,
}

func (i TextFieldSignals) Desc() string {
	if str, ok := _TextFieldSignals_descMap[i]; ok {
		return str
	}
	return "TextFieldSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[TextFieldActive-0]
	_ = x[TextFieldInactive-1]
	_ = x[TextFieldFocus-2]
	_ = x[TextFieldSel-3]
	_ = x[TextFieldStatesN-4]
}

const _TextFieldStates_name = "TextFieldActiveTextFieldInactiveTextFieldFocusTextFieldSelTextFieldStatesN"

var _TextFieldStates_index = [...]uint8{0, 15, 32, 46, 58, 74}

func (i TextFieldStates) String() string {
	if i < 0 || i >= TextFieldStates(len(_TextFieldStates_index)-1) {
		return "TextFieldStates(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextFieldStates_name[_TextFieldStates_index[i]:_TextFieldStates_index[i+1]]
}

func (i *TextFieldStates) FromString(s string) error {
	for j := 0; j < len(_TextFieldStates_index)-1; j++ {
		if s == _TextFieldStates_name[_TextFieldStates_index[j]:_TextFieldStates_index[j+1]] {
			*i = TextFieldStates(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextFieldStates")
}

var _TextFieldStates_descMap = map[TextFieldStates]string{
	0: `normal state -- there but not being interacted with`,
	1: `inactive -- not editable`,
	2: `textfield is the focus -- will respond to keyboard input`,
	3: `selected -- for inactive state, can select entire element`,
	4: ``,
}

func (i TextFieldStates) Desc() string {
	if str, ok := _TextFieldStates_descMap[i]; ok {
		return str
	}
	return "TextFieldStates(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[VpFlagPopup-27]
	_ = x[VpFlagMenu-28]
	_ = x[VpFlagCompleter-29]
	_ = x[VpFlagCorrector-30]
	_ = x[VpFlagTooltip-31]
	_ = x[VpFlagPopupDestroyAll-32]
	_ = x[VpFlagSVG-33]
	_ = x[VpFlagUpdatingNode-34]
	_ = x[VpFlagNeedsFullRender-35]
	_ = x[VpFlagDoingFullRender-36]
	_ = x[VpFlagPrefSizing-37]
	_ = x[VpFlagsN-38]
}

const _VpFlags_name = "VpFlagPopupVpFlagMenuVpFlagCompleterVpFlagCorrectorVpFlagTooltipVpFlagPopupDestroyAllVpFlagSVGVpFlagUpdatingNodeVpFlagNeedsFullRenderVpFlagDoingFullRenderVpFlagPrefSizingVpFlagsN"

var _VpFlags_index = [...]uint8{0, 11, 21, 36, 51, 64, 85, 94, 112, 133, 154, 170, 178}

func (i VpFlags) String() string {
	i -= 27
	if i < 0 || i >= VpFlags(len(_VpFlags_index)-1) {
		return "VpFlags(" + strconv.FormatInt(int64(i+27), 10) + ")"
	}
	return _VpFlags_name[_VpFlags_index[i]:_VpFlags_index[i+1]]
}

func StringToVpFlags(s string) (VpFlags, error) {
	for i := 0; i < len(_VpFlags_index)-1; i++ {
		if s == _VpFlags_name[_VpFlags_index[i]:_VpFlags_index[i+1]] {
			return VpFlags(i + 27), nil
		}
	}
	return 0, errors.New("String: " + s + " is not a valid option for type: VpFlags")
}

var _VpFlags_descMap = map[VpFlags]string{
	27: `VpFlagPopup means viewport is a popup (menu or dialog) -- does not obey parent bounds (otherwise does)`,
	28: `VpFlagMenu means viewport is serving as a popup menu -- affects how window processes clicks`,
	29: `VpFlagCompleter means viewport is serving as a popup menu for code completion -- only applies if the VpFlagMenu is also set`,
	30: `VpFlagCorrector means viewport is serving as a popup menu for spelling correction -- only applies if the VpFlagMenu is also set`,
	31: `VpFlagTooltip means viewport is serving as a tooltip`,
	32: `VpFlagPopupDestroyAll means that if this is a popup, then destroy all the children when it is deleted -- otherwise children below the main layout under the vp will not be destroyed -- it is up to the caller to manage those (typically these are reusable assets)`,
	33: `VpFlagSVG means that this viewport is an SVG viewport -- SVG elements look for this for re-rendering`,
	34: `VpFlagUpdatingNode means that this viewport is currently handling the update of a node, and is under the UpdtMu mutex lock. This can be checked to see about whether to add another update or not.`,
	35: `VpFlagNeedsFullRender means that this viewport needs to do a full render -- this is set during signal processing and will preempt other lower-level updates etc.`,
	36: `VpFlagDoingFullRender means that this viewport is currently doing a full render -- can be used by elements to drive deep rebuild in case underlying data has changed.`,
	37: `VpFlagPrefSizing means that this viewport is currently doing a PrefSize computation to compute the size of the viewport (for sizing window for example) -- affects layout size computation only for Over`,
	38: ``,
}

func (i VpFlags) Desc() string {
	if str, ok := _VpFlags_descMap[i]; ok {
		return str
	}
	return "VpFlags(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[WidgetSelected-0]
	_ = x[WidgetFocused-1]
	_ = x[WidgetContextMenu-2]
	_ = x[WidgetSignalsN-3]
}

const _WidgetSignals_name = "WidgetSelectedWidgetFocusedWidgetContextMenuWidgetSignalsN"

var _WidgetSignals_index = [...]uint8{0, 14, 27, 44, 58}

func (i WidgetSignals) String() string {
	if i < 0 || i >= WidgetSignals(len(_WidgetSignals_index)-1) {
		return "WidgetSignals(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _WidgetSignals_name[_WidgetSignals_index[i]:_WidgetSignals_index[i+1]]
}

func (i *WidgetSignals) FromString(s string) error {
	for j := 0; j < len(_WidgetSignals_index)-1; j++ {
		if s == _WidgetSignals_name[_WidgetSignals_index[j]:_WidgetSignals_index[j+1]] {
			*i = WidgetSignals(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: WidgetSignals")
}

var _WidgetSignals_descMap = map[WidgetSignals]string{
	0: `WidgetSelected is triggered when a widget is selected, typically via left mouse button click (see EmitSelectedSignal) -- is NOT contingent on actual IsSelected status -- just reports the click event. The data is the index of the selected item for multi-item widgets (-1 = none / unselected)`,
	1: `WidgetFocused is triggered when a widget receives keyboard focus (see EmitFocusedSignal -- call in FocusChanged2D for gotFocus`,
	2: `WidgetContextMenu is triggered when a widget receives a right-mouse-button press, BEFORE generating and displaying the context menu, so that relevant state can be updated etc (see EmitContextMenuSignal)`,
	3: ``,
}

func (i WidgetSignals) Desc() string {
	if str, ok := _WidgetSignals_descMap[i]; ok {
		return str
	}
	return "WidgetSignals(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[WinFlagHasGeomPrefs-27]
	_ = x[WinFlagUpdating-28]
	_ = x[WinFlagIsClosing-29]
	_ = x[WinFlagIsResizing-30]
	_ = x[WinFlagGotPaint-31]
	_ = x[WinFlagGotFocus-32]
	_ = x[WinFlagSentShow-33]
	_ = x[WinFlagGoLoop-34]
	_ = x[WinFlagStopEventLoop-35]
	_ = x[WinFlagDoFullRender-36]
	_ = x[WinFlagFocusActive-37]
	_ = x[WinFlagSelectionMode-38]
	_ = x[WinFlagsN-39]
}

const _WinFlags_name = "WinFlagHasGeomPrefsWinFlagUpdatingWinFlagIsClosingWinFlagIsResizingWinFlagGotPaintWinFlagGotFocusWinFlagSentShowWinFlagGoLoopWinFlagStopEventLoopWinFlagDoFullRenderWinFlagFocusActiveWinFlagSelectionModeWinFlagsN"

var _WinFlags_index = [...]uint8{0, 19, 34, 50, 67, 82, 97, 112, 125, 145, 164, 182, 202, 211}

func (i WinFlags) String() string {
	i -= 27
	if i < 0 || i >= WinFlags(len(_WinFlags_index)-1) {
		return "WinFlags(" + strconv.FormatInt(int64(i+27), 10) + ")"
	}
	return _WinFlags_name[_WinFlags_index[i]:_WinFlags_index[i+1]]
}

func StringToWinFlags(s string) (WinFlags, error) {
	for i := 0; i < len(_WinFlags_index)-1; i++ {
		if s == _WinFlags_name[_WinFlags_index[i]:_WinFlags_index[i+1]] {
			return WinFlags(i + 27), nil
		}
	}
	return 0, errors.New("String: " + s + " is not a valid option for type: WinFlags")
}

var _WinFlags_descMap = map[WinFlags]string{
	27: `WinFlagHasGeomPrefs indicates if this window has WinGeomPrefs setting that sized it -- affects whether other default geom should be applied.`,
	28: `WinFlagUpdating is atomic flag around global updating -- routines can check IsWinUpdating and bail`,
	29: `WinFlagIsClosing is atomic flag indicating window is closing`,
	30: `WinFlagIsResizing is atomic flag indicating window is resizing`,
	31: `WinFlagGotPaint have we received our first paint event yet? ignore other window events before this point`,
	32: `WinFlagGotFocus indicates that have we received OSWin focus`,
	33: `WinFlagSentShow have we sent the show event yet? Only ever sent ONCE`,
	34: `WinFlagGoLoop true if we are running from GoStartEventLoop -- requires a WinWait.Done at end`,
	35: `WinFlagStopEventLoop is set when event loop stop is requested`,
	36: `WinFlagDoFullRender is set at event loop startup to trigger a full render once the window is properly shown`,
	37: `WinFlagFocusActive indicates if widget focus is currently in an active state or not`,
	38: `WinSelectionMode indicates that the window is in GoGi inspect editor edit mode`,
	39: ``,
}

func (i WinFlags) Desc() string {
	if str, ok := _WinFlags_descMap[i]; ok {
		return str
	}
	return "WinFlags(" + strconv.FormatInt(int64(i), 10) + ")"
}
