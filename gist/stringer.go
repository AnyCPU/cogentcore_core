// Code generated by "stringer -output stringer.go -type=BorderStyles,ColorSchemeTypes,ColorSources,FontStyles,FontWeights,FontStretch,TextDecorations,BaselineShifts,FontVariants,Align,Overflow,FillRules,VectorEffects,LineCaps,LineJoins,UnicodeBidi,TextDirections,TextAnchors,WhiteSpaces"; DO NOT EDIT.

package gist

import (
	"errors"
	"strconv"
)

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[BorderSolid-0]
	_ = x[BorderDotted-1]
	_ = x[BorderDashed-2]
	_ = x[BorderDouble-3]
	_ = x[BorderGroove-4]
	_ = x[BorderRidge-5]
	_ = x[BorderInset-6]
	_ = x[BorderOutset-7]
	_ = x[BorderNone-8]
	_ = x[BorderHidden-9]
	_ = x[BorderN-10]
}

const _BorderStyles_name = "BorderSolidBorderDottedBorderDashedBorderDoubleBorderGrooveBorderRidgeBorderInsetBorderOutsetBorderNoneBorderHiddenBorderN"

var _BorderStyles_index = [...]uint8{0, 11, 23, 35, 47, 59, 70, 81, 93, 103, 115, 122}

func (i BorderStyles) String() string {
	if i < 0 || i >= BorderStyles(len(_BorderStyles_index)-1) {
		return "BorderStyles(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _BorderStyles_name[_BorderStyles_index[i]:_BorderStyles_index[i+1]]
}

func (i *BorderStyles) FromString(s string) error {
	for j := 0; j < len(_BorderStyles_index)-1; j++ {
		if s == _BorderStyles_name[_BorderStyles_index[j]:_BorderStyles_index[j+1]] {
			*i = BorderStyles(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: BorderStyles")
}

var _BorderStyles_descMap = map[BorderStyles]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
}

func (i BorderStyles) Desc() string {
	if str, ok := _BorderStyles_descMap[i]; ok {
		return str
	}
	return "BorderStyles(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ColorSchemeLight-0]
	_ = x[ColorSchemeDark-1]
	_ = x[ColorSchemesN-2]
}

const _ColorSchemeTypes_name = "ColorSchemeLightColorSchemeDarkColorSchemesN"

var _ColorSchemeTypes_index = [...]uint8{0, 16, 31, 44}

func (i ColorSchemeTypes) String() string {
	if i < 0 || i >= ColorSchemeTypes(len(_ColorSchemeTypes_index)-1) {
		return "ColorSchemeTypes(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ColorSchemeTypes_name[_ColorSchemeTypes_index[i]:_ColorSchemeTypes_index[i+1]]
}

func (i *ColorSchemeTypes) FromString(s string) error {
	for j := 0; j < len(_ColorSchemeTypes_index)-1; j++ {
		if s == _ColorSchemeTypes_name[_ColorSchemeTypes_index[j]:_ColorSchemeTypes_index[j+1]] {
			*i = ColorSchemeTypes(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ColorSchemeTypes")
}

var _ColorSchemeTypes_descMap = map[ColorSchemeTypes]string{
	0: `ColorSchemeLight is a light color scheme`,
	1: `ColorSchemeDark is a dark color scheme`,
	2: ``,
}

func (i ColorSchemeTypes) Desc() string {
	if str, ok := _ColorSchemeTypes_descMap[i]; ok {
		return str
	}
	return "ColorSchemeTypes(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[SolidColor-0]
	_ = x[LinearGradient-1]
	_ = x[RadialGradient-2]
	_ = x[ColorSourcesN-3]
}

const _ColorSources_name = "SolidColorLinearGradientRadialGradientColorSourcesN"

var _ColorSources_index = [...]uint8{0, 10, 24, 38, 51}

func (i ColorSources) String() string {
	if i < 0 || i >= ColorSources(len(_ColorSources_index)-1) {
		return "ColorSources(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _ColorSources_name[_ColorSources_index[i]:_ColorSources_index[i+1]]
}

func (i *ColorSources) FromString(s string) error {
	for j := 0; j < len(_ColorSources_index)-1; j++ {
		if s == _ColorSources_name[_ColorSources_index[j]:_ColorSources_index[j+1]] {
			*i = ColorSources(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: ColorSources")
}

var _ColorSources_descMap = map[ColorSources]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i ColorSources) Desc() string {
	if str, ok := _ColorSources_descMap[i]; ok {
		return str
	}
	return "ColorSources(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[FontNormal-0]
	_ = x[FontItalic-1]
	_ = x[FontOblique-2]
	_ = x[FontStylesN-3]
}

const _FontStyles_name = "FontNormalFontItalicFontObliqueFontStylesN"

var _FontStyles_index = [...]uint8{0, 10, 20, 31, 42}

func (i FontStyles) String() string {
	if i < 0 || i >= FontStyles(len(_FontStyles_index)-1) {
		return "FontStyles(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FontStyles_name[_FontStyles_index[i]:_FontStyles_index[i+1]]
}

func (i *FontStyles) FromString(s string) error {
	for j := 0; j < len(_FontStyles_index)-1; j++ {
		if s == _FontStyles_name[_FontStyles_index[j]:_FontStyles_index[j+1]] {
			*i = FontStyles(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FontStyles")
}

var _FontStyles_descMap = map[FontStyles]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i FontStyles) Desc() string {
	if str, ok := _FontStyles_descMap[i]; ok {
		return str
	}
	return "FontStyles(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[WeightNormal-0]
	_ = x[Weight100-1]
	_ = x[WeightThin-2]
	_ = x[Weight200-3]
	_ = x[WeightExtraLight-4]
	_ = x[Weight300-5]
	_ = x[WeightLight-6]
	_ = x[Weight400-7]
	_ = x[Weight500-8]
	_ = x[WeightMedium-9]
	_ = x[Weight600-10]
	_ = x[WeightSemiBold-11]
	_ = x[Weight700-12]
	_ = x[WeightBold-13]
	_ = x[Weight800-14]
	_ = x[WeightExtraBold-15]
	_ = x[Weight900-16]
	_ = x[WeightBlack-17]
	_ = x[WeightBolder-18]
	_ = x[WeightLighter-19]
	_ = x[FontWeightsN-20]
}

const _FontWeights_name = "WeightNormalWeight100WeightThinWeight200WeightExtraLightWeight300WeightLightWeight400Weight500WeightMediumWeight600WeightSemiBoldWeight700WeightBoldWeight800WeightExtraBoldWeight900WeightBlackWeightBolderWeightLighterFontWeightsN"

var _FontWeights_index = [...]uint8{0, 12, 21, 31, 40, 56, 65, 76, 85, 94, 106, 115, 129, 138, 148, 157, 172, 181, 192, 204, 217, 229}

func (i FontWeights) String() string {
	if i < 0 || i >= FontWeights(len(_FontWeights_index)-1) {
		return "FontWeights(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FontWeights_name[_FontWeights_index[i]:_FontWeights_index[i+1]]
}

func (i *FontWeights) FromString(s string) error {
	for j := 0; j < len(_FontWeights_index)-1; j++ {
		if s == _FontWeights_name[_FontWeights_index[j]:_FontWeights_index[j+1]] {
			*i = FontWeights(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FontWeights")
}

var _FontWeights_descMap = map[FontWeights]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
	20: ``,
}

func (i FontWeights) Desc() string {
	if str, ok := _FontWeights_descMap[i]; ok {
		return str
	}
	return "FontWeights(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[FontStrNormal-0]
	_ = x[FontStrUltraCondensed-1]
	_ = x[FontStrExtraCondensed-2]
	_ = x[FontStrSemiCondensed-3]
	_ = x[FontStrSemiExpanded-4]
	_ = x[FontStrExtraExpanded-5]
	_ = x[FontStrUltraExpanded-6]
	_ = x[FontStrCondensed-7]
	_ = x[FontStrExpanded-8]
	_ = x[FontStrNarrower-9]
	_ = x[FontStrWider-10]
	_ = x[FontStretchN-11]
}

const _FontStretch_name = "FontStrNormalFontStrUltraCondensedFontStrExtraCondensedFontStrSemiCondensedFontStrSemiExpandedFontStrExtraExpandedFontStrUltraExpandedFontStrCondensedFontStrExpandedFontStrNarrowerFontStrWiderFontStretchN"

var _FontStretch_index = [...]uint8{0, 13, 34, 55, 75, 94, 114, 134, 150, 165, 180, 192, 204}

func (i FontStretch) String() string {
	if i < 0 || i >= FontStretch(len(_FontStretch_index)-1) {
		return "FontStretch(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FontStretch_name[_FontStretch_index[i]:_FontStretch_index[i+1]]
}

func (i *FontStretch) FromString(s string) error {
	for j := 0; j < len(_FontStretch_index)-1; j++ {
		if s == _FontStretch_name[_FontStretch_index[j]:_FontStretch_index[j+1]] {
			*i = FontStretch(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FontStretch")
}

var _FontStretch_descMap = map[FontStretch]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
}

func (i FontStretch) Desc() string {
	if str, ok := _FontStretch_descMap[i]; ok {
		return str
	}
	return "FontStretch(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[DecoNone-0]
	_ = x[DecoUnderline-1]
	_ = x[DecoOverline-2]
	_ = x[DecoLineThrough-3]
	_ = x[DecoBlink-4]
	_ = x[DecoDottedUnderline-5]
	_ = x[DecoParaStart-6]
	_ = x[DecoSuper-7]
	_ = x[DecoSub-8]
	_ = x[DecoBackgroundColor-9]
	_ = x[TextDecorationsN-10]
}

const _TextDecorations_name = "DecoNoneDecoUnderlineDecoOverlineDecoLineThroughDecoBlinkDecoDottedUnderlineDecoParaStartDecoSuperDecoSubDecoBackgroundColorTextDecorationsN"

var _TextDecorations_index = [...]uint8{0, 8, 21, 33, 48, 57, 76, 89, 98, 105, 124, 140}

func (i TextDecorations) String() string {
	if i < 0 || i >= TextDecorations(len(_TextDecorations_index)-1) {
		return "TextDecorations(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextDecorations_name[_TextDecorations_index[i]:_TextDecorations_index[i+1]]
}

func (i *TextDecorations) FromString(s string) error {
	for j := 0; j < len(_TextDecorations_index)-1; j++ {
		if s == _TextDecorations_name[_TextDecorations_index[j]:_TextDecorations_index[j+1]] {
			*i = TextDecorations(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextDecorations")
}

var _TextDecorations_descMap = map[TextDecorations]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  `Blink is not currently supported (and probably a bad idea generally ;)`,
	5:  `DottedUnderline is used for abbr tag -- otherwise not a standard text-decoration option afaik`,
	6:  `DecoParaStart at start of a SpanRender indicates that it should be styled as the start of a new paragraph and not just the start of a new line`,
	7:  `DecoSuper indicates super-scripted text`,
	8:  `DecoSub indicates sub-scripted text`,
	9:  `DecoBackgroundColor indicates that a bg color has been set -- for use in optimizing rendering`,
	10: ``,
}

func (i TextDecorations) Desc() string {
	if str, ok := _TextDecorations_descMap[i]; ok {
		return str
	}
	return "TextDecorations(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[ShiftBaseline-0]
	_ = x[ShiftSuper-1]
	_ = x[ShiftSub-2]
	_ = x[BaselineShiftsN-3]
}

const _BaselineShifts_name = "ShiftBaselineShiftSuperShiftSubBaselineShiftsN"

var _BaselineShifts_index = [...]uint8{0, 13, 23, 31, 46}

func (i BaselineShifts) String() string {
	if i < 0 || i >= BaselineShifts(len(_BaselineShifts_index)-1) {
		return "BaselineShifts(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _BaselineShifts_name[_BaselineShifts_index[i]:_BaselineShifts_index[i+1]]
}

func (i *BaselineShifts) FromString(s string) error {
	for j := 0; j < len(_BaselineShifts_index)-1; j++ {
		if s == _BaselineShifts_name[_BaselineShifts_index[j]:_BaselineShifts_index[j+1]] {
			*i = BaselineShifts(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: BaselineShifts")
}

var _BaselineShifts_descMap = map[BaselineShifts]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i BaselineShifts) Desc() string {
	if str, ok := _BaselineShifts_descMap[i]; ok {
		return str
	}
	return "BaselineShifts(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[FontVarNormal-0]
	_ = x[FontVarSmallCaps-1]
	_ = x[FontVariantsN-2]
}

const _FontVariants_name = "FontVarNormalFontVarSmallCapsFontVariantsN"

var _FontVariants_index = [...]uint8{0, 13, 29, 42}

func (i FontVariants) String() string {
	if i < 0 || i >= FontVariants(len(_FontVariants_index)-1) {
		return "FontVariants(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FontVariants_name[_FontVariants_index[i]:_FontVariants_index[i+1]]
}

func (i *FontVariants) FromString(s string) error {
	for j := 0; j < len(_FontVariants_index)-1; j++ {
		if s == _FontVariants_name[_FontVariants_index[j]:_FontVariants_index[j+1]] {
			*i = FontVariants(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FontVariants")
}

var _FontVariants_descMap = map[FontVariants]string{
	0: ``,
	1: ``,
	2: ``,
}

func (i FontVariants) Desc() string {
	if str, ok := _FontVariants_descMap[i]; ok {
		return str
	}
	return "FontVariants(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[AlignLeft-0]
	_ = x[AlignTop-1]
	_ = x[AlignCenter-2]
	_ = x[AlignMiddle-3]
	_ = x[AlignRight-4]
	_ = x[AlignBottom-5]
	_ = x[AlignBaseline-6]
	_ = x[AlignJustify-7]
	_ = x[AlignSpaceAround-8]
	_ = x[AlignFlexStart-9]
	_ = x[AlignFlexEnd-10]
	_ = x[AlignTextTop-11]
	_ = x[AlignTextBottom-12]
	_ = x[AlignSub-13]
	_ = x[AlignSuper-14]
	_ = x[AlignN-15]
}

const _Align_name = "AlignLeftAlignTopAlignCenterAlignMiddleAlignRightAlignBottomAlignBaselineAlignJustifyAlignSpaceAroundAlignFlexStartAlignFlexEndAlignTextTopAlignTextBottomAlignSubAlignSuperAlignN"

var _Align_index = [...]uint8{0, 9, 17, 28, 39, 49, 60, 73, 85, 101, 115, 127, 139, 154, 162, 172, 178}

func (i Align) String() string {
	if i < 0 || i >= Align(len(_Align_index)-1) {
		return "Align(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Align_name[_Align_index[i]:_Align_index[i+1]]
}

func (i *Align) FromString(s string) error {
	for j := 0; j < len(_Align_index)-1; j++ {
		if s == _Align_name[_Align_index[j]:_Align_index[j+1]] {
			*i = Align(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: Align")
}

var _Align_descMap = map[Align]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  `middle = vertical version of center`,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  `same as CSS space-between`,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: `align to subscript`,
	14: `align to superscript`,
	15: ``,
}

func (i Align) Desc() string {
	if str, ok := _Align_descMap[i]; ok {
		return str
	}
	return "Align(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[OverflowAuto-0]
	_ = x[OverflowScroll-1]
	_ = x[OverflowVisible-2]
	_ = x[OverflowHidden-3]
	_ = x[OverflowN-4]
}

const _Overflow_name = "OverflowAutoOverflowScrollOverflowVisibleOverflowHiddenOverflowN"

var _Overflow_index = [...]uint8{0, 12, 26, 41, 55, 64}

func (i Overflow) String() string {
	if i < 0 || i >= Overflow(len(_Overflow_index)-1) {
		return "Overflow(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Overflow_name[_Overflow_index[i]:_Overflow_index[i+1]]
}

func (i *Overflow) FromString(s string) error {
	for j := 0; j < len(_Overflow_index)-1; j++ {
		if s == _Overflow_name[_Overflow_index[j]:_Overflow_index[j+1]] {
			*i = Overflow(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: Overflow")
}

var _Overflow_descMap = map[Overflow]string{
	0: `OverflowAuto automatically determines if scrollbars should be added to show the overflow. Scrollbars are added only if the actual content size is greater than the currently available size. Typically, an outer-most Layout will scale up and add scrollbars to accommodate the Min needs of its child elements, so if you want to have scrollbars show up on inner elements, they need to have a style setting that restricts their Min size, but also allows them to stretch so they use whatever space they are allocated.`,
	1: `OverflowScroll means add scrollbars when necessary, and is essentially identical to Auto. However, only during Viewport PrefSize call, the actual content size is used -- otherwise it behaves just like Auto.`,
	2: `OverflowVisible makes the overflow visible -- this is generally unsafe and not very feasible and will be ignored as long as possible. Currently it falls back on Auto, but could go to Hidden if that works better overall.`,
	3: `OverflowHidden hides the overflow and doesn&#39;t present scrollbars (supported).`,
	4: ``,
}

func (i Overflow) Desc() string {
	if str, ok := _Overflow_descMap[i]; ok {
		return str
	}
	return "Overflow(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[FillRuleNonZero-0]
	_ = x[FillRuleEvenOdd-1]
	_ = x[FillRulesN-2]
}

const _FillRules_name = "FillRuleNonZeroFillRuleEvenOddFillRulesN"

var _FillRules_index = [...]uint8{0, 15, 30, 40}

func (i FillRules) String() string {
	if i < 0 || i >= FillRules(len(_FillRules_index)-1) {
		return "FillRules(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _FillRules_name[_FillRules_index[i]:_FillRules_index[i+1]]
}

func (i *FillRules) FromString(s string) error {
	for j := 0; j < len(_FillRules_index)-1; j++ {
		if s == _FillRules_name[_FillRules_index[j]:_FillRules_index[j+1]] {
			*i = FillRules(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: FillRules")
}

var _FillRules_descMap = map[FillRules]string{
	0: ``,
	1: ``,
	2: ``,
}

func (i FillRules) Desc() string {
	if str, ok := _FillRules_descMap[i]; ok {
		return str
	}
	return "FillRules(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[VecEffNone-0]
	_ = x[VecEffNonScalingStroke-1]
	_ = x[VecEffN-2]
}

const _VectorEffects_name = "VecEffNoneVecEffNonScalingStrokeVecEffN"

var _VectorEffects_index = [...]uint8{0, 10, 32, 39}

func (i VectorEffects) String() string {
	if i < 0 || i >= VectorEffects(len(_VectorEffects_index)-1) {
		return "VectorEffects(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _VectorEffects_name[_VectorEffects_index[i]:_VectorEffects_index[i+1]]
}

func (i *VectorEffects) FromString(s string) error {
	for j := 0; j < len(_VectorEffects_index)-1; j++ {
		if s == _VectorEffects_name[_VectorEffects_index[j]:_VectorEffects_index[j+1]] {
			*i = VectorEffects(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: VectorEffects")
}

var _VectorEffects_descMap = map[VectorEffects]string{
	0: ``,
	1: `VecEffNonScalingStroke means that the stroke width is not affected by transform properties`,
	2: ``,
}

func (i VectorEffects) Desc() string {
	if str, ok := _VectorEffects_descMap[i]; ok {
		return str
	}
	return "VectorEffects(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[LineCapButt-0]
	_ = x[LineCapRound-1]
	_ = x[LineCapSquare-2]
	_ = x[LineCapCubic-3]
	_ = x[LineCapQuadratic-4]
	_ = x[LineCapsN-5]
}

const _LineCaps_name = "LineCapButtLineCapRoundLineCapSquareLineCapCubicLineCapQuadraticLineCapsN"

var _LineCaps_index = [...]uint8{0, 11, 23, 36, 48, 64, 73}

func (i LineCaps) String() string {
	if i < 0 || i >= LineCaps(len(_LineCaps_index)-1) {
		return "LineCaps(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _LineCaps_name[_LineCaps_index[i]:_LineCaps_index[i+1]]
}

func (i *LineCaps) FromString(s string) error {
	for j := 0; j < len(_LineCaps_index)-1; j++ {
		if s == _LineCaps_name[_LineCaps_index[j]:_LineCaps_index[j+1]] {
			*i = LineCaps(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: LineCaps")
}

var _LineCaps_descMap = map[LineCaps]string{
	0: ``,
	1: ``,
	2: ``,
	3: `rasterx extension`,
	4: `rasterx extension`,
	5: ``,
}

func (i LineCaps) Desc() string {
	if str, ok := _LineCaps_descMap[i]; ok {
		return str
	}
	return "LineCaps(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[LineJoinMiter-0]
	_ = x[LineJoinMiterClip-1]
	_ = x[LineJoinRound-2]
	_ = x[LineJoinBevel-3]
	_ = x[LineJoinArcs-4]
	_ = x[LineJoinArcsClip-5]
	_ = x[LineJoinsN-6]
}

const _LineJoins_name = "LineJoinMiterLineJoinMiterClipLineJoinRoundLineJoinBevelLineJoinArcsLineJoinArcsClipLineJoinsN"

var _LineJoins_index = [...]uint8{0, 13, 30, 43, 56, 68, 84, 94}

func (i LineJoins) String() string {
	if i < 0 || i >= LineJoins(len(_LineJoins_index)-1) {
		return "LineJoins(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _LineJoins_name[_LineJoins_index[i]:_LineJoins_index[i+1]]
}

func (i *LineJoins) FromString(s string) error {
	for j := 0; j < len(_LineJoins_index)-1; j++ {
		if s == _LineJoins_name[_LineJoins_index[j]:_LineJoins_index[j+1]] {
			*i = LineJoins(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: LineJoins")
}

var _LineJoins_descMap = map[LineJoins]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: `rasterx extension`,
	6: ``,
}

func (i LineJoins) Desc() string {
	if str, ok := _LineJoins_descMap[i]; ok {
		return str
	}
	return "LineJoins(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[BidiNormal-0]
	_ = x[BidiEmbed-1]
	_ = x[BidiBidiOverride-2]
	_ = x[UnicodeBidiN-3]
}

const _UnicodeBidi_name = "BidiNormalBidiEmbedBidiBidiOverrideUnicodeBidiN"

var _UnicodeBidi_index = [...]uint8{0, 10, 19, 35, 47}

func (i UnicodeBidi) String() string {
	if i < 0 || i >= UnicodeBidi(len(_UnicodeBidi_index)-1) {
		return "UnicodeBidi(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _UnicodeBidi_name[_UnicodeBidi_index[i]:_UnicodeBidi_index[i+1]]
}

func (i *UnicodeBidi) FromString(s string) error {
	for j := 0; j < len(_UnicodeBidi_index)-1; j++ {
		if s == _UnicodeBidi_name[_UnicodeBidi_index[j]:_UnicodeBidi_index[j+1]] {
			*i = UnicodeBidi(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: UnicodeBidi")
}

var _UnicodeBidi_descMap = map[UnicodeBidi]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i UnicodeBidi) Desc() string {
	if str, ok := _UnicodeBidi_descMap[i]; ok {
		return str
	}
	return "UnicodeBidi(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[LRTB-0]
	_ = x[RLTB-1]
	_ = x[TBRL-2]
	_ = x[LR-3]
	_ = x[RL-4]
	_ = x[TB-5]
	_ = x[LTR-6]
	_ = x[RTL-7]
	_ = x[TextDirectionsN-8]
}

const _TextDirections_name = "LRTBRLTBTBRLLRRLTBLTRRTLTextDirectionsN"

var _TextDirections_index = [...]uint8{0, 4, 8, 12, 14, 16, 18, 21, 24, 39}

func (i TextDirections) String() string {
	if i < 0 || i >= TextDirections(len(_TextDirections_index)-1) {
		return "TextDirections(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextDirections_name[_TextDirections_index[i]:_TextDirections_index[i+1]]
}

func (i *TextDirections) FromString(s string) error {
	for j := 0; j < len(_TextDirections_index)-1; j++ {
		if s == _TextDirections_name[_TextDirections_index[j]:_TextDirections_index[j+1]] {
			*i = TextDirections(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextDirections")
}

var _TextDirections_descMap = map[TextDirections]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
	8: ``,
}

func (i TextDirections) Desc() string {
	if str, ok := _TextDirections_descMap[i]; ok {
		return str
	}
	return "TextDirections(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[AnchorStart-0]
	_ = x[AnchorMiddle-1]
	_ = x[AnchorEnd-2]
	_ = x[TextAnchorsN-3]
}

const _TextAnchors_name = "AnchorStartAnchorMiddleAnchorEndTextAnchorsN"

var _TextAnchors_index = [...]uint8{0, 11, 23, 32, 44}

func (i TextAnchors) String() string {
	if i < 0 || i >= TextAnchors(len(_TextAnchors_index)-1) {
		return "TextAnchors(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _TextAnchors_name[_TextAnchors_index[i]:_TextAnchors_index[i+1]]
}

func (i *TextAnchors) FromString(s string) error {
	for j := 0; j < len(_TextAnchors_index)-1; j++ {
		if s == _TextAnchors_name[_TextAnchors_index[j]:_TextAnchors_index[j+1]] {
			*i = TextAnchors(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: TextAnchors")
}

var _TextAnchors_descMap = map[TextAnchors]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

func (i TextAnchors) Desc() string {
	if str, ok := _TextAnchors_descMap[i]; ok {
		return str
	}
	return "TextAnchors(" + strconv.FormatInt(int64(i), 10) + ")"
}
func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[WhiteSpaceNormal-0]
	_ = x[WhiteSpaceNowrap-1]
	_ = x[WhiteSpacePre-2]
	_ = x[WhiteSpacePreLine-3]
	_ = x[WhiteSpacePreWrap-4]
	_ = x[WhiteSpacesN-5]
}

const _WhiteSpaces_name = "WhiteSpaceNormalWhiteSpaceNowrapWhiteSpacePreWhiteSpacePreLineWhiteSpacePreWrapWhiteSpacesN"

var _WhiteSpaces_index = [...]uint8{0, 16, 32, 45, 62, 79, 91}

func (i WhiteSpaces) String() string {
	if i < 0 || i >= WhiteSpaces(len(_WhiteSpaces_index)-1) {
		return "WhiteSpaces(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _WhiteSpaces_name[_WhiteSpaces_index[i]:_WhiteSpaces_index[i+1]]
}

func (i *WhiteSpaces) FromString(s string) error {
	for j := 0; j < len(_WhiteSpaces_index)-1; j++ {
		if s == _WhiteSpaces_name[_WhiteSpaces_index[j]:_WhiteSpaces_index[j+1]] {
			*i = WhiteSpaces(j)
			return nil
		}
	}
	return errors.New("String: " + s + " is not a valid option for type: WhiteSpaces")
}

var _WhiteSpaces_descMap = map[WhiteSpaces]string{
	0: `WhiteSpaceNormal means that all white space is collapsed to a single space, and text wraps when necessary`,
	1: `WhiteSpaceNowrap means that sequences of whitespace will collapse into a single whitespace. Text will never wrap to the next line. The text continues on the same line until a &lt;br&gt; tag is encountered`,
	2: `WhiteSpacePre means that whitespace is preserved by the browser. Text will only wrap on line breaks. Acts like the &lt;pre&gt; tag in HTML. This invokes a different hand-written parser because the default golang parser automatically throws away whitespace`,
	3: `WhiteSpacePreLine means that sequences of whitespace will collapse into a single whitespace. Text will wrap when necessary, and on line breaks`,
	4: `WhiteSpacePreWrap means that whitespace is preserved by the browser. Text will wrap when necessary, and on line breaks`,
	5: ``,
}

func (i WhiteSpaces) Desc() string {
	if str, ok := _WhiteSpaces_descMap[i]; ok {
		return str
	}
	return "WhiteSpaces(" + strconv.FormatInt(int64(i), 10) + ")"
}
