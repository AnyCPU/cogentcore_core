// Code generated by "core generate"; DO NOT EDIT.

package giv

import (
	"image"

	"cogentcore.org/core/events/key"
	"cogentcore.org/core/fi"
	"cogentcore.org/core/core"
	"cogentcore.org/core/gti"
	"cogentcore.org/core/icons"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/mat32"
	"cogentcore.org/core/units"
)

// ArgViewType is the [gti.Type] for [ArgView]
var ArgViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.ArgView", IDName: "arg-view", Doc: "ArgView represents a slice of reflect.Value's and associated names, for the\npurpose of supplying arguments to methods called via the MethodView\nframework.", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Args", Doc: "Args are the args that we are a view onto"}}, Instance: &ArgView{}})

// NewArgView adds a new [ArgView] with the given name to the given parent:
// ArgView represents a slice of reflect.Value's and associated names, for the
// purpose of supplying arguments to methods called via the MethodView
// framework.
func NewArgView(parent tree.Node, name ...string) *ArgView {
	return parent.NewChild(ArgViewType, name...).(*ArgView)
}

// NodeType returns the [*gti.Type] of [ArgView]
func (t *ArgView) NodeType() *gti.Type { return ArgViewType }

// New returns a new [*ArgView] value
func (t *ArgView) New() tree.Node { return &ArgView{} }

// SetArgs sets the [ArgView.Args]:
// Args are the args that we are a view onto
func (t *ArgView) SetArgs(v ...Value) *ArgView { t.Args = v; return t }

// SetTooltip sets the [ArgView.Tooltip]
func (t *ArgView) SetTooltip(v string) *ArgView { t.Tooltip = v; return t }

// ColorViewType is the [gti.Type] for [ColorView]
var ColorViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.ColorView", IDName: "color-view", Doc: "ColorView shows a color, using sliders or numbers to set values.", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Color", Doc: "the color that we view"}}, Instance: &ColorView{}})

// NewColorView adds a new [ColorView] with the given name to the given parent:
// ColorView shows a color, using sliders or numbers to set values.
func NewColorView(parent tree.Node, name ...string) *ColorView {
	return parent.NewChild(ColorViewType, name...).(*ColorView)
}

// NodeType returns the [*gti.Type] of [ColorView]
func (t *ColorView) NodeType() *gti.Type { return ColorViewType }

// New returns a new [*ColorView] value
func (t *ColorView) New() tree.Node { return &ColorView{} }

// SetTooltip sets the [ColorView.Tooltip]
func (t *ColorView) SetTooltip(v string) *ColorView { t.Tooltip = v; return t }

// FileViewType is the [gti.Type] for [FileView]
var FileViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.FileView", IDName: "file-view", Doc: "FileView is a viewer onto files -- core of the file chooser dialog", Methods: []gti.Method{{Name: "UpdateFilesAction", Doc: "UpdateFilesAction updates the list of files and other views for the current path.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "AddPathToFavs", Doc: "AddPathToFavs adds the current path to favorites", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "DirPathUp", Doc: "DirPathUp moves up one directory in the path", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "NewFolder", Doc: "NewFolder creates a new folder with the given name in the current directory.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"name"}, Returns: []string{"error"}}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "DirPath", Doc: "path to directory of files to display"}, {Name: "CurrentSelectedFile", Doc: "currently selected file"}, {Name: "Ext", Doc: "target extension(s) (comma separated if multiple, including initial .), if any"}, {Name: "FilterFunc", Doc: "optional styling function"}, {Name: "ExtMap", Doc: "map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value"}, {Name: "Files", Doc: "files for current directory"}, {Name: "SelectedIndex", Doc: "index of currently-selected file in Files list (-1 if none)"}, {Name: "Watcher", Doc: "change notify for current dir"}, {Name: "DoneWatcher", Doc: "channel to close watcher watcher"}, {Name: "UpdateMu", Doc: "UpdateFiles mutex"}, {Name: "PrevPath", Doc: "Previous path that was processed via UpdateFiles"}}, Instance: &FileView{}})

// NewFileView adds a new [FileView] with the given name to the given parent:
// FileView is a viewer onto files -- core of the file chooser dialog
func NewFileView(parent tree.Node, name ...string) *FileView {
	return parent.NewChild(FileViewType, name...).(*FileView)
}

// NodeType returns the [*gti.Type] of [FileView]
func (t *FileView) NodeType() *gti.Type { return FileViewType }

// New returns a new [*FileView] value
func (t *FileView) New() tree.Node { return &FileView{} }

// SetFilterFunc sets the [FileView.FilterFunc]:
// optional styling function
func (t *FileView) SetFilterFunc(v FileViewFilterFunc) *FileView { t.FilterFunc = v; return t }

// SetExtMap sets the [FileView.ExtMap]:
// map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value
func (t *FileView) SetExtMap(v map[string]string) *FileView { t.ExtMap = v; return t }

// SetFiles sets the [FileView.Files]:
// files for current directory
func (t *FileView) SetFiles(v ...*fi.FileInfo) *FileView { t.Files = v; return t }

// SetTooltip sets the [FileView.Tooltip]
func (t *FileView) SetTooltip(v string) *FileView { t.Tooltip = v; return t }

// FuncButtonType is the [gti.Type] for [FuncButton]
var FuncButtonType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.FuncButton", IDName: "func-button", Doc: "FuncButton is a button that is set up to call a function when it\nis pressed, using a dialog to prompt the user for any arguments.\nAlso, it automatically sets various properties of the button like\nthe name, text, tooltip, and icon based on the properties of the\nfunction, using reflect and gti. The function must be registered\nwith gti to get documentation information, but that is not required;\nadd a `//gti:add` comment directive and run `core generate`\nif you want tooltips. If the function is a method, both the method and\nits receiver type must be added to gti to get documentation.", Directives: []gti.Directive{{Tool: "core", Directive: "no-new"}}, Embeds: []gti.Field{{Name: "Button"}}, Fields: []gti.Field{{Name: "Func", Doc: "Func is the [gti.Func] associated with this button.\nThis function can also be a method, but it must be\nconverted to a [gti.Func] first. It should typically\nbe set using [FuncButton.SetFunc]."}, {Name: "ReflectFunc", Doc: "ReflectFunc is the [reflect.Value] of the function or\nmethod associated with this button. It should typically\nbet set using [FuncButton.SetFunc]."}, {Name: "Args", Doc: "Args are the [Value] objects associated with the\narguments of the function. They are automatically set in\n[SetFunc], but they can be customized to configure\ndefault values and other options."}, {Name: "Returns", Doc: "Returns are the [Value] objects associated with the\nreturn values of the function. They are automatically\nset in [SetFunc], but they can be customized to configure\ndefault values and other options. The [reflect.Value]s of\nthe [Value] objects are not set until the function is\ncalled, and are thus not typically applicable to access."}, {Name: "Confirm", Doc: "Confirm is whether to prompt the user for confirmation\nbefore calling the function."}, {Name: "ShowReturn", Doc: "ShowReturn is whether to display the return values of\nthe function (and a success message if there are none).\nThe way that the return values are shown is determined\nby ShowReturnAsDialog. Non-nil error return values will\nalways be shown, even if ShowReturn is set to false."}, {Name: "ShowReturnAsDialog", Doc: "ShowReturnAsDialog, if and only if ShowReturn is true,\nindicates to show the return values of the function in\na dialog, instead of in a snackbar, as they are by default.\nIf there are multiple return values from the function, or if\none of them is a complex type (pointer, struct, slice,\narray, map), then ShowReturnAsDialog will\nautomatically be set to true."}, {Name: "NewWindow", Doc: "NewWindow makes the ReturnDialog a NewWindow dialog\n(if supported by platform)."}, {Name: "WarnUnadded", Doc: "WarnUnadded is whether to log warnings when a function that\nhas not been added to gti is used. It is on by default and\nmust be set before [FuncButton.SetFunc] is called for it to\nhave any effect."}, {Name: "Context", Doc: "Context is used for opening Dialogs if non-nil."}, {Name: "AfterFunc", Doc: "AfterFunc is an optional function called after the funcbutton\nfunction is executed"}}, Instance: &FuncButton{}})

// NodeType returns the [*gti.Type] of [FuncButton]
func (t *FuncButton) NodeType() *gti.Type { return FuncButtonType }

// New returns a new [*FuncButton] value
func (t *FuncButton) New() tree.Node { return &FuncButton{} }

// SetConfirm sets the [FuncButton.Confirm]:
// Confirm is whether to prompt the user for confirmation
// before calling the function.
func (t *FuncButton) SetConfirm(v bool) *FuncButton { t.Confirm = v; return t }

// SetShowReturn sets the [FuncButton.ShowReturn]:
// ShowReturn is whether to display the return values of
// the function (and a success message if there are none).
// The way that the return values are shown is determined
// by ShowReturnAsDialog. Non-nil error return values will
// always be shown, even if ShowReturn is set to false.
func (t *FuncButton) SetShowReturn(v bool) *FuncButton { t.ShowReturn = v; return t }

// SetShowReturnAsDialog sets the [FuncButton.ShowReturnAsDialog]:
// ShowReturnAsDialog, if and only if ShowReturn is true,
// indicates to show the return values of the function in
// a dialog, instead of in a snackbar, as they are by default.
// If there are multiple return values from the function, or if
// one of them is a complex type (pointer, struct, slice,
// array, map), then ShowReturnAsDialog will
// automatically be set to true.
func (t *FuncButton) SetShowReturnAsDialog(v bool) *FuncButton { t.ShowReturnAsDialog = v; return t }

// SetNewWindow sets the [FuncButton.NewWindow]:
// NewWindow makes the ReturnDialog a NewWindow dialog
// (if supported by platform).
func (t *FuncButton) SetNewWindow(v bool) *FuncButton { t.NewWindow = v; return t }

// SetWarnUnadded sets the [FuncButton.WarnUnadded]:
// WarnUnadded is whether to log warnings when a function that
// has not been added to gti is used. It is on by default and
// must be set before [FuncButton.SetFunc] is called for it to
// have any effect.
func (t *FuncButton) SetWarnUnadded(v bool) *FuncButton { t.WarnUnadded = v; return t }

// SetContext sets the [FuncButton.Context]:
// Context is used for opening Dialogs if non-nil.
func (t *FuncButton) SetContext(v core.Widget) *FuncButton { t.Context = v; return t }

// SetAfterFunc sets the [FuncButton.AfterFunc]:
// AfterFunc is an optional function called after the funcbutton
// function is executed
func (t *FuncButton) SetAfterFunc(v func()) *FuncButton { t.AfterFunc = v; return t }

// SetTooltip sets the [FuncButton.Tooltip]
func (t *FuncButton) SetTooltip(v string) *FuncButton { t.Tooltip = v; return t }

// SetType sets the [FuncButton.Type]
func (t *FuncButton) SetType(v core.ButtonTypes) *FuncButton { t.Type = v; return t }

// SetIcon sets the [FuncButton.Icon]
func (t *FuncButton) SetIcon(v icons.Icon) *FuncButton { t.Icon = v; return t }

// SetIndicator sets the [FuncButton.Indicator]
func (t *FuncButton) SetIndicator(v icons.Icon) *FuncButton { t.Indicator = v; return t }

// SetShortcut sets the [FuncButton.Shortcut]
func (t *FuncButton) SetShortcut(v key.Chord) *FuncButton { t.Shortcut = v; return t }

// SetMenu sets the [FuncButton.Menu]
func (t *FuncButton) SetMenu(v func(m *core.Scene)) *FuncButton { t.Menu = v; return t }

// InspectorType is the [gti.Type] for [Inspector]
var InspectorType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.Inspector", IDName: "inspector", Doc: "Inspector represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame with an optional title, and a button\nbox at the bottom where methods can be invoked", Methods: []gti.Method{{Name: "Save", Doc: "Save saves tree to current filename, in a standard JSON-formatted file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Returns: []string{"error"}}, {Name: "SaveAs", Doc: "SaveAs saves tree to given filename, in a standard JSON-formatted file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Open", Doc: "Open opens tree from given filename, in a standard JSON-formatted file", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "ToggleSelectionMode", Doc: "ToggleSelectionMode toggles the editor between selection mode or not.\nIn selection mode, bounding boxes are rendered around each Widget,\nand clicking on a Widget pulls it up in the inspector.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "InspectApp", Doc: "InspectApp displays the underlying operating system app", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "KiRoot", Doc: "root of tree being edited"}, {Name: "Changed", Doc: "has the root changed via gui actions?  updated from treeview and structview for changes"}, {Name: "Filename", Doc: "current filename for saving / loading"}}, Instance: &Inspector{}})

// NewInspector adds a new [Inspector] with the given name to the given parent:
// Inspector represents a struct, creating a property editor of the fields --
// constructs Children widgets to show the field names and editor fields for
// each field, within an overall frame with an optional title, and a button
// box at the bottom where methods can be invoked
func NewInspector(parent tree.Node, name ...string) *Inspector {
	return parent.NewChild(InspectorType, name...).(*Inspector)
}

// NodeType returns the [*gti.Type] of [Inspector]
func (t *Inspector) NodeType() *gti.Type { return InspectorType }

// New returns a new [*Inspector] value
func (t *Inspector) New() tree.Node { return &Inspector{} }

// SetKiRoot sets the [Inspector.KiRoot]:
// root of tree being edited
func (t *Inspector) SetKiRoot(v tree.Node) *Inspector { t.KiRoot = v; return t }

// SetFilename sets the [Inspector.Filename]:
// current filename for saving / loading
func (t *Inspector) SetFilename(v core.Filename) *Inspector { t.Filename = v; return t }

// SetTooltip sets the [Inspector.Tooltip]
func (t *Inspector) SetTooltip(v string) *Inspector { t.Tooltip = v; return t }

// MapViewType is the [gti.Type] for [MapView]
var MapViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.MapView", IDName: "map-view", Doc: "MapView represents a map, creating a property editor of the values --\nconstructs Children widgets to show the key / value pairs, within an\noverall frame.", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Map", Doc: "the map that we are a view onto"}, {Name: "MapValView", Doc: "Value for the map itself, if this was created within value view framework; otherwise nil"}, {Name: "Changed", Doc: "has the map been edited?"}, {Name: "Keys", Doc: "Value representations of the map keys"}, {Name: "Values", Doc: "Value representations of the map values"}, {Name: "SortVals", Doc: "sort by values instead of keys"}, {Name: "NCols", Doc: "the number of columns in the map; do not set externally;\ngenerally only access internally"}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view.\nDisplayed as extra contextual information in view dialog windows."}}, Instance: &MapView{}})

// NewMapView adds a new [MapView] with the given name to the given parent:
// MapView represents a map, creating a property editor of the values --
// constructs Children widgets to show the key / value pairs, within an
// overall frame.
func NewMapView(parent tree.Node, name ...string) *MapView {
	return parent.NewChild(MapViewType, name...).(*MapView)
}

// NodeType returns the [*gti.Type] of [MapView]
func (t *MapView) NodeType() *gti.Type { return MapViewType }

// New returns a new [*MapView] value
func (t *MapView) New() tree.Node { return &MapView{} }

// SetMapValView sets the [MapView.MapValView]:
// Value for the map itself, if this was created within value view framework; otherwise nil
func (t *MapView) SetMapValView(v Value) *MapView { t.MapValView = v; return t }

// SetSortVals sets the [MapView.SortVals]:
// sort by values instead of keys
func (t *MapView) SetSortVals(v bool) *MapView { t.SortVals = v; return t }

// SetViewPath sets the [MapView.ViewPath]:
// a record of parent View names that have led up to this view.
// Displayed as extra contextual information in view dialog windows.
func (t *MapView) SetViewPath(v string) *MapView { t.ViewPath = v; return t }

// SetTooltip sets the [MapView.Tooltip]
func (t *MapView) SetTooltip(v string) *MapView { t.Tooltip = v; return t }

// MapViewInlineType is the [gti.Type] for [MapViewInline]
var MapViewInlineType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.MapViewInline", IDName: "map-view-inline", Doc: "MapViewInline represents a map as a single line widget,\nfor smaller maps and those explicitly marked inline.", Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Map", Doc: "the map that we are a view onto"}, {Name: "MapValue", Doc: "MapValue is the Value for the map itself\nif this was created within the Value framework.\nOtherwise, it is nil."}, {Name: "Changed", Doc: "has the map been edited?"}, {Name: "Keys", Doc: "Value representations of the map keys"}, {Name: "Values", Doc: "Value representations of the fields"}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows"}, {Name: "ConfigSize", Doc: "size of map when gui configed"}}, Instance: &MapViewInline{}})

// NewMapViewInline adds a new [MapViewInline] with the given name to the given parent:
// MapViewInline represents a map as a single line widget,
// for smaller maps and those explicitly marked inline.
func NewMapViewInline(parent tree.Node, name ...string) *MapViewInline {
	return parent.NewChild(MapViewInlineType, name...).(*MapViewInline)
}

// NodeType returns the [*gti.Type] of [MapViewInline]
func (t *MapViewInline) NodeType() *gti.Type { return MapViewInlineType }

// New returns a new [*MapViewInline] value
func (t *MapViewInline) New() tree.Node { return &MapViewInline{} }

// SetViewPath sets the [MapViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *MapViewInline) SetViewPath(v string) *MapViewInline { t.ViewPath = v; return t }

// SetTooltip sets the [MapViewInline.Tooltip]
func (t *MapViewInline) SetTooltip(v string) *MapViewInline { t.Tooltip = v; return t }

// SliceViewType is the [gti.Type] for [SliceView]
var SliceViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.SliceView", IDName: "slice-view", Doc: "SliceView represents a slice, creating an interactive viewer / editor of the\nelements as rows in a table.  Widgets to show the index / value pairs, within an\noverall frame.\nSet to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.", Embeds: []gti.Field{{Name: "SliceViewBase"}}, Fields: []gti.Field{{Name: "StyleFunc", Doc: "optional styling function"}}, Instance: &SliceView{}})

// NewSliceView adds a new [SliceView] with the given name to the given parent:
// SliceView represents a slice, creating an interactive viewer / editor of the
// elements as rows in a table.  Widgets to show the index / value pairs, within an
// overall frame.
// Set to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected
// signals when selection is updated.
func NewSliceView(parent tree.Node, name ...string) *SliceView {
	return parent.NewChild(SliceViewType, name...).(*SliceView)
}

// NodeType returns the [*gti.Type] of [SliceView]
func (t *SliceView) NodeType() *gti.Type { return SliceViewType }

// New returns a new [*SliceView] value
func (t *SliceView) New() tree.Node { return &SliceView{} }

// SetStyleFunc sets the [SliceView.StyleFunc]:
// optional styling function
func (t *SliceView) SetStyleFunc(v SliceViewStyleFunc) *SliceView { t.StyleFunc = v; return t }

// SetTooltip sets the [SliceView.Tooltip]
func (t *SliceView) SetTooltip(v string) *SliceView { t.Tooltip = v; return t }

// SetMinRows sets the [SliceView.MinRows]
func (t *SliceView) SetMinRows(v int) *SliceView { t.MinRows = v; return t }

// SetViewPath sets the [SliceView.ViewPath]
func (t *SliceView) SetViewPath(v string) *SliceView { t.ViewPath = v; return t }

// SetSelectedValue sets the [SliceView.SelectedValue]
func (t *SliceView) SetSelectedValue(v any) *SliceView { t.SelectedValue = v; return t }

// SetSelectedIndex sets the [SliceView.SelectedIndex]
func (t *SliceView) SetSelectedIndex(v int) *SliceView { t.SelectedIndex = v; return t }

// SetInitSelectedIndex sets the [SliceView.InitSelectedIndex]
func (t *SliceView) SetInitSelectedIndex(v int) *SliceView { t.InitSelectedIndex = v; return t }

// SliceViewBaseType is the [gti.Type] for [SliceViewBase]
var SliceViewBaseType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.SliceViewBase", IDName: "slice-view-base", Doc: "SliceViewBase is the base for SliceView and TableView and any other viewers\nof array-like data.  It automatically computes the number of rows that fit\nwithin its allocated space, and manages the offset view window into the full\nlist of items, and supports row selection, copy / paste, Drag-n-Drop, etc.\nSet to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected\nsignals when selection is updated.", Methods: []gti.Method{{Name: "CopyIndexes", Doc: "CopyIndexes copies selected idxs to goosi.Clipboard, optionally resetting the selection", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"reset"}}, {Name: "DeleteIndexes", Doc: "DeleteIndexes deletes all selected indexes", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "CutIndexes", Doc: "CutIndexes copies selected indexes to goosi.Clipboard and deletes selected indexes", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "PasteIndex", Doc: "PasteIndex pastes clipboard at given idx", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"idx"}}, {Name: "Duplicate", Doc: "Duplicate copies selected items and inserts them after current selection --\nreturn idx of start of duplicates if successful, else -1", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Returns: []string{"int"}}}, Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Slice", Doc: "the slice that we are a view onto -- must be a pointer to that slice"}, {Name: "MinRows", Doc: "MinRows specifies the minimum number of rows to display, to ensure\nat least this amount is displayed."}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows"}, {Name: "ViewMu", Doc: "optional mutex that, if non-nil, will be used around any updates that\nread / modify the underlying Slice data.\nCan be used to protect against random updating if your code has specific\nupdate points that can be likewise protected with this same mutex."}, {Name: "Changed", Doc: "Changed indicates whether the underlying slice\nhas been edited in any way"}, {Name: "SelectedValue", Doc: "current selection value -- initially select this value if set"}, {Name: "SelectedIndex", Doc: "index of currently selected item"}, {Name: "InitSelectedIndex", Doc: "index of row to select at start"}, {Name: "SelectedIndexes", Doc: "list of currently-selected slice indexes"}, {Name: "LastClick", Doc: "LastClick is the last row that has been clicked on.\nThis is used to prevent erroneous double click events\nfrom being sent when the user clicks on multiple different\nrows in quick succession."}, {Name: "NormalCursor", Doc: "NormalCursor is the cached cursor to display when there\nis no row being hovered."}, {Name: "CurrentCursor", Doc: "CurrentCursor is the cached cursor that should currently be\ndisplayed."}, {Name: "SliceNPVal", Doc: "non-ptr reflect.Value of the slice"}, {Name: "SliceValue", Doc: "Value for the slice itself, if this was created within value view framework -- otherwise nil"}, {Name: "Values", Doc: "Value representations of the slice values"}, {Name: "HoverRow", Doc: "currently-hovered row"}, {Name: "DraggedIndexes", Doc: "list of currently-dragged indexes"}, {Name: "VisRows", Doc: "total number of rows visible in allocated display size"}, {Name: "StartIndex", Doc: "starting slice index of visible rows"}, {Name: "SliceSize", Doc: "size of slice"}, {Name: "ConfigIter", Doc: "iteration through the configuration process, reset when a new slice type is set"}, {Name: "TmpIndex", Doc: "temp idx state for e.g., dnd"}, {Name: "ElVal", Doc: "ElVal is a Value representation of the underlying element type\nwhich is used whenever there are no slice elements available"}, {Name: "MaxWidth", Doc: "maximum width of value column in chars, if string"}}, Instance: &SliceViewBase{}})

// NewSliceViewBase adds a new [SliceViewBase] with the given name to the given parent:
// SliceViewBase is the base for SliceView and TableView and any other viewers
// of array-like data.  It automatically computes the number of rows that fit
// within its allocated space, and manages the offset view window into the full
// list of items, and supports row selection, copy / paste, Drag-n-Drop, etc.
// Set to ReadOnly for select-only mode, which emits WidgetSig WidgetSelected
// signals when selection is updated.
func NewSliceViewBase(parent tree.Node, name ...string) *SliceViewBase {
	return parent.NewChild(SliceViewBaseType, name...).(*SliceViewBase)
}

// NodeType returns the [*gti.Type] of [SliceViewBase]
func (t *SliceViewBase) NodeType() *gti.Type { return SliceViewBaseType }

// New returns a new [*SliceViewBase] value
func (t *SliceViewBase) New() tree.Node { return &SliceViewBase{} }

// SetMinRows sets the [SliceViewBase.MinRows]:
// MinRows specifies the minimum number of rows to display, to ensure
// at least this amount is displayed.
func (t *SliceViewBase) SetMinRows(v int) *SliceViewBase { t.MinRows = v; return t }

// SetViewPath sets the [SliceViewBase.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *SliceViewBase) SetViewPath(v string) *SliceViewBase { t.ViewPath = v; return t }

// SetSelectedValue sets the [SliceViewBase.SelectedValue]:
// current selection value -- initially select this value if set
func (t *SliceViewBase) SetSelectedValue(v any) *SliceViewBase { t.SelectedValue = v; return t }

// SetSelectedIndex sets the [SliceViewBase.SelectedIndex]:
// index of currently selected item
func (t *SliceViewBase) SetSelectedIndex(v int) *SliceViewBase { t.SelectedIndex = v; return t }

// SetInitSelectedIndex sets the [SliceViewBase.InitSelectedIndex]:
// index of row to select at start
func (t *SliceViewBase) SetInitSelectedIndex(v int) *SliceViewBase { t.InitSelectedIndex = v; return t }

// SetTooltip sets the [SliceViewBase.Tooltip]
func (t *SliceViewBase) SetTooltip(v string) *SliceViewBase { t.Tooltip = v; return t }

// SliceViewGridType is the [gti.Type] for [SliceViewGrid]
var SliceViewGridType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.SliceViewGrid", IDName: "slice-view-grid", Doc: "SliceViewGrid handles the resizing logic for SliceView, TableView.", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "MinRows", Doc: "MinRows is set from parent SV"}, {Name: "RowHeight", Doc: "height of a single row, computed during layout"}, {Name: "VisRows", Doc: "total number of rows visible in allocated display size"}, {Name: "BgStripe", Doc: "Various computed backgrounds"}, {Name: "BgSelect", Doc: "Various computed backgrounds"}, {Name: "BgSelectStripe", Doc: "Various computed backgrounds"}, {Name: "BgHover", Doc: "Various computed backgrounds"}, {Name: "BgHoverStripe", Doc: "Various computed backgrounds"}, {Name: "BgHoverSelect", Doc: "Various computed backgrounds"}, {Name: "BgHoverSelectStripe", Doc: "Various computed backgrounds"}, {Name: "LastBackground", Doc: "LastBackground is the background for which modified\nbackgrounds were computed -- don't update if same"}}, Instance: &SliceViewGrid{}})

// NewSliceViewGrid adds a new [SliceViewGrid] with the given name to the given parent:
// SliceViewGrid handles the resizing logic for SliceView, TableView.
func NewSliceViewGrid(parent tree.Node, name ...string) *SliceViewGrid {
	return parent.NewChild(SliceViewGridType, name...).(*SliceViewGrid)
}

// NodeType returns the [*gti.Type] of [SliceViewGrid]
func (t *SliceViewGrid) NodeType() *gti.Type { return SliceViewGridType }

// New returns a new [*SliceViewGrid] value
func (t *SliceViewGrid) New() tree.Node { return &SliceViewGrid{} }

// SetLastBackground sets the [SliceViewGrid.LastBackground]:
// LastBackground is the background for which modified
// backgrounds were computed -- don't update if same
func (t *SliceViewGrid) SetLastBackground(v image.Image) *SliceViewGrid {
	t.LastBackground = v
	return t
}

// SetTooltip sets the [SliceViewGrid.Tooltip]
func (t *SliceViewGrid) SetTooltip(v string) *SliceViewGrid { t.Tooltip = v; return t }

// SliceViewInlineType is the [gti.Type] for [SliceViewInline]
var SliceViewInlineType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.SliceViewInline", IDName: "slice-view-inline", Doc: "SliceViewInline represents a slice as a single line widget,\nfor smaller slices and those explicitly marked inline.", Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Slice", Doc: "the slice that we are a view onto"}, {Name: "SliceValue", Doc: "SliceValue is the Value for the slice itself\nif this was created within the Value framework.\nOtherwise, it is nil."}, {Name: "IsArray", Doc: "whether the slice is actually an array -- no modifications"}, {Name: "IsFixedLen", Doc: "whether the slice has a fixed-len flag on it"}, {Name: "Changed", Doc: "has the slice been edited?"}, {Name: "Values", Doc: "Value representations of the fields"}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows"}, {Name: "ConfigSize", Doc: "size of map when gui was configured"}}, Instance: &SliceViewInline{}})

// NewSliceViewInline adds a new [SliceViewInline] with the given name to the given parent:
// SliceViewInline represents a slice as a single line widget,
// for smaller slices and those explicitly marked inline.
func NewSliceViewInline(parent tree.Node, name ...string) *SliceViewInline {
	return parent.NewChild(SliceViewInlineType, name...).(*SliceViewInline)
}

// NodeType returns the [*gti.Type] of [SliceViewInline]
func (t *SliceViewInline) NodeType() *gti.Type { return SliceViewInlineType }

// New returns a new [*SliceViewInline] value
func (t *SliceViewInline) New() tree.Node { return &SliceViewInline{} }

// SetViewPath sets the [SliceViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *SliceViewInline) SetViewPath(v string) *SliceViewInline { t.ViewPath = v; return t }

// SetTooltip sets the [SliceViewInline.Tooltip]
func (t *SliceViewInline) SetTooltip(v string) *SliceViewInline { t.Tooltip = v; return t }

// StructViewType is the [gti.Type] for [StructView]
var StructViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.StructView", IDName: "struct-view", Doc: "StructView represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame.", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Struct", Doc: "the struct that we are a view onto"}, {Name: "StructValue", Doc: "StructValue is the Value for the struct itself\nif this was created within the Value framework.\nOtherwise, it is nil."}, {Name: "FieldViews", Doc: "Value representations of the fields"}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows"}, {Name: "IsShouldShower", Doc: "IsShouldShower is whether the struct implements [gi.ShouldShower], which results\nin additional updating being done at certain points."}, {Name: "TypeFieldTags", Doc: "extra tags by field name -- from type properties"}}, Instance: &StructView{}})

// NewStructView adds a new [StructView] with the given name to the given parent:
// StructView represents a struct, creating a property editor of the fields --
// constructs Children widgets to show the field names and editor fields for
// each field, within an overall frame.
func NewStructView(parent tree.Node, name ...string) *StructView {
	return parent.NewChild(StructViewType, name...).(*StructView)
}

// NodeType returns the [*gti.Type] of [StructView]
func (t *StructView) NodeType() *gti.Type { return StructViewType }

// New returns a new [*StructView] value
func (t *StructView) New() tree.Node { return &StructView{} }

// SetViewPath sets the [StructView.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *StructView) SetViewPath(v string) *StructView { t.ViewPath = v; return t }

// SetTooltip sets the [StructView.Tooltip]
func (t *StructView) SetTooltip(v string) *StructView { t.Tooltip = v; return t }

// StructViewInlineType is the [gti.Type] for [StructViewInline]
var StructViewInlineType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.StructViewInline", IDName: "struct-view-inline", Doc: "StructViewInline represents a struct as a single line widget,\nfor smaller structs and those explicitly marked inline.", Embeds: []gti.Field{{Name: "Layout"}}, Fields: []gti.Field{{Name: "Struct", Doc: "the struct that we are a view onto"}, {Name: "StructValue", Doc: "Value for the struct itself, if this was created within value view framework -- otherwise nil"}, {Name: "AddButton", Doc: "if true, add an edit button at the end"}, {Name: "FieldViews", Doc: "Value representations of the fields"}, {Name: "ViewPath", Doc: "a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows"}, {Name: "IsShouldShower", Doc: "IsShouldShower is whether the struct implements [gi.ShouldShower], which results\nin additional updating being done at certain points."}}, Instance: &StructViewInline{}})

// NewStructViewInline adds a new [StructViewInline] with the given name to the given parent:
// StructViewInline represents a struct as a single line widget,
// for smaller structs and those explicitly marked inline.
func NewStructViewInline(parent tree.Node, name ...string) *StructViewInline {
	return parent.NewChild(StructViewInlineType, name...).(*StructViewInline)
}

// NodeType returns the [*gti.Type] of [StructViewInline]
func (t *StructViewInline) NodeType() *gti.Type { return StructViewInlineType }

// New returns a new [*StructViewInline] value
func (t *StructViewInline) New() tree.Node { return &StructViewInline{} }

// SetAddButton sets the [StructViewInline.AddButton]:
// if true, add an edit button at the end
func (t *StructViewInline) SetAddButton(v bool) *StructViewInline { t.AddButton = v; return t }

// SetFieldViews sets the [StructViewInline.FieldViews]:
// Value representations of the fields
func (t *StructViewInline) SetFieldViews(v ...Value) *StructViewInline { t.FieldViews = v; return t }

// SetViewPath sets the [StructViewInline.ViewPath]:
// a record of parent View names that have led up to this view -- displayed as extra contextual information in view dialog windows
func (t *StructViewInline) SetViewPath(v string) *StructViewInline { t.ViewPath = v; return t }

// SetTooltip sets the [StructViewInline.Tooltip]
func (t *StructViewInline) SetTooltip(v string) *StructViewInline { t.Tooltip = v; return t }

// TableViewType is the [gti.Type] for [TableView]
var TableViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.TableView", IDName: "table-view", Doc: "TableView represents a slice-of-structs as a table, where the fields are\nthe columns, within an overall frame.  It is a full-featured editor with\nmultiple-selection, cut-and-paste, and drag-and-drop.\nIf ReadOnly, it functions as a mutually-exclusive item\nselector, highlighting the selected row and emitting a Selected action.", Embeds: []gti.Field{{Name: "SliceViewBase"}}, Fields: []gti.Field{{Name: "StyleFunc", Doc: "optional styling function"}, {Name: "SelectedField", Doc: "current selection field -- initially select value in this field"}, {Name: "SortIndex", Doc: "current sort index"}, {Name: "SortDesc", Doc: "whether current sort order is descending"}, {Name: "StruType", Doc: "struct type for each row"}, {Name: "VisFields", Doc: "the visible fields"}, {Name: "NVisFields", Doc: "number of visible fields"}, {Name: "HeaderWidths", Doc: "HeaderWidths has number of characters in each header, per visfields"}, {Name: "ColMaxWidths", Doc: "ColMaxWidths records maximum width in chars of string type fields"}}, Instance: &TableView{}})

// NewTableView adds a new [TableView] with the given name to the given parent:
// TableView represents a slice-of-structs as a table, where the fields are
// the columns, within an overall frame.  It is a full-featured editor with
// multiple-selection, cut-and-paste, and drag-and-drop.
// If ReadOnly, it functions as a mutually-exclusive item
// selector, highlighting the selected row and emitting a Selected action.
func NewTableView(parent tree.Node, name ...string) *TableView {
	return parent.NewChild(TableViewType, name...).(*TableView)
}

// NodeType returns the [*gti.Type] of [TableView]
func (t *TableView) NodeType() *gti.Type { return TableViewType }

// New returns a new [*TableView] value
func (t *TableView) New() tree.Node { return &TableView{} }

// SetStyleFunc sets the [TableView.StyleFunc]:
// optional styling function
func (t *TableView) SetStyleFunc(v TableViewStyleFunc) *TableView { t.StyleFunc = v; return t }

// SetSelectedField sets the [TableView.SelectedField]:
// current selection field -- initially select value in this field
func (t *TableView) SetSelectedField(v string) *TableView { t.SelectedField = v; return t }

// SetSortIndex sets the [TableView.SortIndex]:
// current sort index
func (t *TableView) SetSortIndex(v int) *TableView { t.SortIndex = v; return t }

// SetSortDesc sets the [TableView.SortDesc]:
// whether current sort order is descending
func (t *TableView) SetSortDesc(v bool) *TableView { t.SortDesc = v; return t }

// SetTooltip sets the [TableView.Tooltip]
func (t *TableView) SetTooltip(v string) *TableView { t.Tooltip = v; return t }

// SetMinRows sets the [TableView.MinRows]
func (t *TableView) SetMinRows(v int) *TableView { t.MinRows = v; return t }

// SetViewPath sets the [TableView.ViewPath]
func (t *TableView) SetViewPath(v string) *TableView { t.ViewPath = v; return t }

// SetSelectedValue sets the [TableView.SelectedValue]
func (t *TableView) SetSelectedValue(v any) *TableView { t.SelectedValue = v; return t }

// SetSelectedIndex sets the [TableView.SelectedIndex]
func (t *TableView) SetSelectedIndex(v int) *TableView { t.SelectedIndex = v; return t }

// SetInitSelectedIndex sets the [TableView.InitSelectedIndex]
func (t *TableView) SetInitSelectedIndex(v int) *TableView { t.InitSelectedIndex = v; return t }

// TimeViewType is the [gti.Type] for [TimeView]
var TimeViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.TimeView", IDName: "time-view", Doc: "TimeView is a view for selecting a time", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Time", Doc: "the time that we are viewing"}, {Name: "Hour", Doc: "the raw input hour"}, {Name: "PM", Doc: "whether we are in PM mode (so we have to add 12h to everything)"}}, Instance: &TimeView{}})

// NewTimeView adds a new [TimeView] with the given name to the given parent:
// TimeView is a view for selecting a time
func NewTimeView(parent tree.Node, name ...string) *TimeView {
	return parent.NewChild(TimeViewType, name...).(*TimeView)
}

// NodeType returns the [*gti.Type] of [TimeView]
func (t *TimeView) NodeType() *gti.Type { return TimeViewType }

// New returns a new [*TimeView] value
func (t *TimeView) New() tree.Node { return &TimeView{} }

// SetTooltip sets the [TimeView.Tooltip]
func (t *TimeView) SetTooltip(v string) *TimeView { t.Tooltip = v; return t }

// DateViewType is the [gti.Type] for [DateView]
var DateViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.DateView", IDName: "date-view", Doc: "DateView is a view for selecting a date", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Time", Doc: "the time that we are viewing"}, {Name: "ConfigTime", Doc: "ConfigTime is the time that was configured"}}, Instance: &DateView{}})

// NewDateView adds a new [DateView] with the given name to the given parent:
// DateView is a view for selecting a date
func NewDateView(parent tree.Node, name ...string) *DateView {
	return parent.NewChild(DateViewType, name...).(*DateView)
}

// NodeType returns the [*gti.Type] of [DateView]
func (t *DateView) NodeType() *gti.Type { return DateViewType }

// New returns a new [*DateView] value
func (t *DateView) New() tree.Node { return &DateView{} }

// SetTooltip sets the [DateView.Tooltip]
func (t *DateView) SetTooltip(v string) *DateView { t.Tooltip = v; return t }

// TreeTableViewType is the [gti.Type] for [TreeTableView]
var TreeTableViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.TreeTableView", IDName: "tree-table-view", Doc: "TreeTableView combines a [TreeView] and [TableView].", Embeds: []gti.Field{{Name: "Frame"}}, Fields: []gti.Field{{Name: "Tree", Doc: "Tree is the tree view component of the tree table view."}, {Name: "Table", Doc: "Table is the table view component of the tree table view."}}, Instance: &TreeTableView{}})

// NewTreeTableView adds a new [TreeTableView] with the given name to the given parent:
// TreeTableView combines a [TreeView] and [TableView].
func NewTreeTableView(parent tree.Node, name ...string) *TreeTableView {
	return parent.NewChild(TreeTableViewType, name...).(*TreeTableView)
}

// NodeType returns the [*gti.Type] of [TreeTableView]
func (t *TreeTableView) NodeType() *gti.Type { return TreeTableViewType }

// New returns a new [*TreeTableView] value
func (t *TreeTableView) New() tree.Node { return &TreeTableView{} }

// SetTooltip sets the [TreeTableView.Tooltip]
func (t *TreeTableView) SetTooltip(v string) *TreeTableView { t.Tooltip = v; return t }

// TreeViewType is the [gti.Type] for [TreeView]
var TreeViewType = gti.AddType(&gti.Type{Name: "cogentcore.org/core/giv.TreeView", IDName: "tree-view", Doc: "TreeView provides a graphical representation of a tree structure,\nproviding full navigation and manipulation abilities.\n\nIt does not handle layout by itself, so if you want it to scroll\nseparately from the rest of the surrounding context, use [NewTreeViewFrame].\n\nIf the SyncNode field is non-nil, typically via\nSyncRootNode method, then the TreeView mirrors another\nKi tree structure, and tree editing functions apply to\nthe source tree first, and then to the TreeView by sync.\n\nOtherwise, data can be directly encoded in a TreeView\nderived type, to represent any kind of tree structure\nand associated data.\n\nStandard events.Event are sent to any listeners, including\nSelect, Change, and DoubleClick.  The selected nodes\nare in the root SelectedNodes list.", Methods: []gti.Method{{Name: "InsertAfter", Doc: "InsertAfter inserts a new node in the tree\nafter this node, at the same (sibling) level,\nprompting for the type of node to insert.\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "InsertBefore", Doc: "InsertBefore inserts a new node in the tree\nbefore this node, at the same (sibling) level,\nprompting for the type of node to insert\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "AddChildNode", Doc: "AddChildNode adds a new child node to this one in the tree,\nprompting the user for the type of node to add\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "DeleteNode", Doc: "DeleteNode deletes the tree node or sync node corresponding\nto this view node in the sync tree.\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "Duplicate", Doc: "Duplicate duplicates the sync node corresponding to this view node in\nthe tree, and inserts the duplicate after this node (as a new sibling).\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "EditNode", Doc: "EditNode pulls up a StructViewDialog window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "InspectNode", Doc: "InspectNode pulls up a new Inspector window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "OpenAll", Doc: "OpenAll opens the given node and all of its sub-nodes", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "CloseAll", Doc: "CloseAll closes the given node and all of its sub-nodes.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "Copy", Doc: "Copy copies to goosi.Clipboard, optionally resetting the selection.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}, Args: []string{"reset"}}, {Name: "Cut", Doc: "Cut copies to goosi.Clipboard and deletes selected items.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}, {Name: "Paste", Doc: "Paste pastes clipboard at given node.", Directives: []gti.Directive{{Tool: "gti", Directive: "add"}}}}, Embeds: []gti.Field{{Name: "WidgetBase"}}, Fields: []gti.Field{{Name: "SyncNode", Doc: "If non-nil, the Ki Node that this widget is viewing in the tree (the source)"}, {Name: "Text", Doc: "The text to display for the tree view item label, which automatically\ndefaults to the [tree.NodeBase.Name] of the tree view node. It has no effect\nif [TreeView.SyncNode] is non-nil."}, {Name: "Icon", Doc: "optional icon, displayed to the the left of the text label"}, {Name: "IconOpen", Doc: "icon to use for an open (expanded) branch; defaults to [icons.KeyboardArrowDown]"}, {Name: "IconClosed", Doc: "icon to use for a closed (collapsed) branch; defaults to [icons.KeyboardArrowRight]"}, {Name: "IconLeaf", Doc: "icon to use for a terminal node branch that has no children; defaults to [icons.Blank]"}, {Name: "Indent", Doc: "amount to indent children relative to this node"}, {Name: "OpenDepth", Doc: "depth for nodes be initialized as open (default 4).\nNodes beyond this depth will be initialized as closed."}, {Name: "ViewIndex", Doc: "linear index of this node within the entire tree.\nupdated on full rebuilds and may sometimes be off,\nbut close enough for expected uses"}, {Name: "WidgetSize", Doc: "size of just this node widget.\nour alloc includes all of our children, but we only draw us."}, {Name: "RootView", Doc: "The cached root of the view. It is automatically set and does not need to be\nset by the end user."}, {Name: "SelectedNodes", Doc: "SelectedNodes holds the currently-selected nodes, on the\nRootView node only."}, {Name: "actStateLayer", Doc: "actStateLayer is the actual state layer of the tree view, which\nshould be used when rendering it and its parts (but not its children).\nthe reason that it exists is so that the children of the tree view\n(other tree views) do not inherit its stateful background color, as\nthat does not look good."}}, Instance: &TreeView{}})

// NewTreeView adds a new [TreeView] with the given name to the given parent:
// TreeView provides a graphical representation of a tree structure,
// providing full navigation and manipulation abilities.
//
// It does not handle layout by itself, so if you want it to scroll
// separately from the rest of the surrounding context, use [NewTreeViewFrame].
//
// If the SyncNode field is non-nil, typically via
// SyncRootNode method, then the TreeView mirrors another
// Ki tree structure, and tree editing functions apply to
// the source tree first, and then to the TreeView by sync.
//
// Otherwise, data can be directly encoded in a TreeView
// derived type, to represent any kind of tree structure
// and associated data.
//
// Standard events.Event are sent to any listeners, including
// Select, Change, and DoubleClick.  The selected nodes
// are in the root SelectedNodes list.
func NewTreeView(parent tree.Node, name ...string) *TreeView {
	return parent.NewChild(TreeViewType, name...).(*TreeView)
}

// NodeType returns the [*gti.Type] of [TreeView]
func (t *TreeView) NodeType() *gti.Type { return TreeViewType }

// New returns a new [*TreeView] value
func (t *TreeView) New() tree.Node { return &TreeView{} }

// SetText sets the [TreeView.Text]:
// The text to display for the tree view item label, which automatically
// defaults to the [tree.Node.Name] of the tree view node. It has no effect
// if [TreeView.SyncNode] is non-nil.
func (t *TreeView) SetText(v string) *TreeView { t.Text = v; return t }

// SetIcon sets the [TreeView.Icon]:
// optional icon, displayed to the the left of the text label
func (t *TreeView) SetIcon(v icons.Icon) *TreeView { t.Icon = v; return t }

// SetIconOpen sets the [TreeView.IconOpen]:
// icon to use for an open (expanded) branch; defaults to [icons.KeyboardArrowDown]
func (t *TreeView) SetIconOpen(v icons.Icon) *TreeView { t.IconOpen = v; return t }

// SetIconClosed sets the [TreeView.IconClosed]:
// icon to use for a closed (collapsed) branch; defaults to [icons.KeyboardArrowRight]
func (t *TreeView) SetIconClosed(v icons.Icon) *TreeView { t.IconClosed = v; return t }

// SetIconLeaf sets the [TreeView.IconLeaf]:
// icon to use for a terminal node branch that has no children; defaults to [icons.Blank]
func (t *TreeView) SetIconLeaf(v icons.Icon) *TreeView { t.IconLeaf = v; return t }

// SetIndent sets the [TreeView.Indent]:
// amount to indent children relative to this node
func (t *TreeView) SetIndent(v units.Value) *TreeView { t.Indent = v; return t }

// SetOpenDepth sets the [TreeView.OpenDepth]:
// depth for nodes be initialized as open (default 4).
// Nodes beyond this depth will be initialized as closed.
func (t *TreeView) SetOpenDepth(v int) *TreeView { t.OpenDepth = v; return t }

// SetViewIndex sets the [TreeView.ViewIndex]:
// linear index of this node within the entire tree.
// updated on full rebuilds and may sometimes be off,
// but close enough for expected uses
func (t *TreeView) SetViewIndex(v int) *TreeView { t.ViewIndex = v; return t }

// SetWidgetSize sets the [TreeView.WidgetSize]:
// size of just this node widget.
// our alloc includes all of our children, but we only draw us.
func (t *TreeView) SetWidgetSize(v mat32.Vec2) *TreeView { t.WidgetSize = v; return t }

// SetRootView sets the [TreeView.RootView]:
// The cached root of the view. It is automatically set and does not need to be
// set by the end user.
func (t *TreeView) SetRootView(v *TreeView) *TreeView { t.RootView = v; return t }

// SetSelectedNodes sets the [TreeView.SelectedNodes]:
// SelectedNodes holds the currently-selected nodes, on the
// RootView node only.
func (t *TreeView) SetSelectedNodes(v ...TreeViewer) *TreeView { t.SelectedNodes = v; return t }

// SetTooltip sets the [TreeView.Tooltip]
func (t *TreeView) SetTooltip(v string) *TreeView { t.Tooltip = v; return t }
