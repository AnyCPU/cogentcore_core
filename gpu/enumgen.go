// Code generated by "core generate"; DO NOT EDIT.

package gpu

import (
	"cogentcore.org/core/enums"
)

var _BufferTypesValues = []BufferTypes{0, 1, 2, 3, 4}

// BufferTypesN is the highest valid value for type BufferTypes, plus one.
const BufferTypesN BufferTypes = 5

var _BufferTypesValueMap = map[string]BufferTypes{`VertexBuffer`: 0, `IndexBuffer`: 1, `UniformBuffer`: 2, `StorageBuffer`: 3, `TextureBuff`: 4}

var _BufferTypesDescMap = map[BufferTypes]string{0: `VertexBuffer is a buffer holding Vertex values.`, 1: `IndexBuffer is a buffer holding Index values`, 2: `UniformBuffer holds Uniform objects: read-only, small footprint.`, 3: `StorageBuffer holds Storage data: read-write, larger, mostly for compute shaders.`, 4: `TextureBuff holds StorageTextures (todo: not supported yet?).`}

var _BufferTypesMap = map[BufferTypes]string{0: `VertexBuffer`, 1: `IndexBuffer`, 2: `UniformBuffer`, 3: `StorageBuffer`, 4: `TextureBuff`}

// String returns the string representation of this BufferTypes value.
func (i BufferTypes) String() string { return enums.String(i, _BufferTypesMap) }

// SetString sets the BufferTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *BufferTypes) SetString(s string) error {
	return enums.SetString(i, s, _BufferTypesValueMap, "BufferTypes")
}

// Int64 returns the BufferTypes value as an int64.
func (i BufferTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the BufferTypes value from an int64.
func (i *BufferTypes) SetInt64(in int64) { *i = BufferTypes(in) }

// Desc returns the description of the BufferTypes value.
func (i BufferTypes) Desc() string { return enums.Desc(i, _BufferTypesDescMap) }

// BufferTypesValues returns all possible values for the type BufferTypes.
func BufferTypesValues() []BufferTypes { return _BufferTypesValues }

// Values returns all possible values for the type BufferTypes.
func (i BufferTypes) Values() []enums.Enum { return enums.Values(_BufferTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BufferTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BufferTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BufferTypes")
}

var _ImageFlagsValues = []ImageFlags{0, 1, 2, 3, 4, 5, 6, 7}

// ImageFlagsN is the highest valid value for type ImageFlags, plus one.
const ImageFlagsN ImageFlags = 8

var _ImageFlagsValueMap = map[string]ImageFlags{`Active`: 0, `HostActive`: 1, `OwnsImage`: 2, `OwnsHost`: 3, `IsValue`: 4, `DepthImage`: 5, `FramebufferImage`: 6, `OnHostOnly`: 7}

var _ImageFlagsDescMap = map[ImageFlags]string{0: `ImageActive: the Image and ImageView are configured and ready to use`, 1: `ImageHostActive: the Host representation of the image is present and ready to be accessed`, 2: `ImageOwnsImage: we own the Vk.Image`, 3: `ImageOwnsHost: we own the Host buffer (and it is initialized)`, 4: `ImageIsValue: we are a Value image and our Host buffer is shared, with offset. this is incompatible with ImageOwnsHost`, 5: `DepthImage indicates that this is a Depth buffer image`, 6: `FramebufferImage indicates that this is a Framebuffer image`, 7: `ImageOnHostOnly causes the image to be created only on host visible memory, not on device memory -- no additional host buffer should be created. this is for an ImageGrab image. layout is LINEAR`}

var _ImageFlagsMap = map[ImageFlags]string{0: `Active`, 1: `HostActive`, 2: `OwnsImage`, 3: `OwnsHost`, 4: `IsValue`, 5: `DepthImage`, 6: `FramebufferImage`, 7: `OnHostOnly`}

// String returns the string representation of this ImageFlags value.
func (i ImageFlags) String() string { return enums.BitFlagString(i, _ImageFlagsValues) }

// BitIndexString returns the string representation of this ImageFlags value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i ImageFlags) BitIndexString() string { return enums.String(i, _ImageFlagsMap) }

// SetString sets the ImageFlags value from its string representation,
// and returns an error if the string is invalid.
func (i *ImageFlags) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the ImageFlags value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *ImageFlags) SetStringOr(s string) error {
	return enums.SetStringOr(i, s, _ImageFlagsValueMap, "ImageFlags")
}

// Int64 returns the ImageFlags value as an int64.
func (i ImageFlags) Int64() int64 { return int64(i) }

// SetInt64 sets the ImageFlags value from an int64.
func (i *ImageFlags) SetInt64(in int64) { *i = ImageFlags(in) }

// Desc returns the description of the ImageFlags value.
func (i ImageFlags) Desc() string { return enums.Desc(i, _ImageFlagsDescMap) }

// ImageFlagsValues returns all possible values for the type ImageFlags.
func ImageFlagsValues() []ImageFlags { return _ImageFlagsValues }

// Values returns all possible values for the type ImageFlags.
func (i ImageFlags) Values() []enums.Enum { return enums.Values(_ImageFlagsValues) }

// HasFlag returns whether these bit flags have the given bit flag set.
func (i ImageFlags) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(&i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *ImageFlags) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ImageFlags) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ImageFlags) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ImageFlags")
}

var _OptionStatesValues = []OptionStates{0, 1, 2, 3}

// OptionStatesN is the highest valid value for type OptionStates, plus one.
const OptionStatesN OptionStates = 4

var _OptionStatesValueMap = map[string]OptionStates{`Disabled`: 0, `Optional`: 1, `Required`: 2, `Enabled`: 3}

var _OptionStatesDescMap = map[OptionStates]string{0: `Disabled -- option is not enabled`, 1: `Optional -- option is enabled if possible and code checks for actual state providing workaround if not supported`, 2: `Required -- option is required and GPU.Config fails if not supported by the hardware`, 3: `Enabled is the state of all options specified during Config, and supported bythe hardware`}

var _OptionStatesMap = map[OptionStates]string{0: `Disabled`, 1: `Optional`, 2: `Required`, 3: `Enabled`}

// String returns the string representation of this OptionStates value.
func (i OptionStates) String() string { return enums.String(i, _OptionStatesMap) }

// SetString sets the OptionStates value from its string representation,
// and returns an error if the string is invalid.
func (i *OptionStates) SetString(s string) error {
	return enums.SetString(i, s, _OptionStatesValueMap, "OptionStates")
}

// Int64 returns the OptionStates value as an int64.
func (i OptionStates) Int64() int64 { return int64(i) }

// SetInt64 sets the OptionStates value from an int64.
func (i *OptionStates) SetInt64(in int64) { *i = OptionStates(in) }

// Desc returns the description of the OptionStates value.
func (i OptionStates) Desc() string { return enums.Desc(i, _OptionStatesDescMap) }

// OptionStatesValues returns all possible values for the type OptionStates.
func OptionStatesValues() []OptionStates { return _OptionStatesValues }

// Values returns all possible values for the type OptionStates.
func (i OptionStates) Values() []enums.Enum { return enums.Values(_OptionStatesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i OptionStates) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *OptionStates) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "OptionStates")
}

var _VarRolesValues = []VarRoles{0, 1, 2, 3, 4, 5, 6, 7}

// VarRolesN is the highest valid value for type VarRoles, plus one.
const VarRolesN VarRoles = 8

var _VarRolesValueMap = map[string]VarRoles{`UndefVarRole`: 0, `Vertex`: 1, `Index`: 2, `Push`: 3, `Uniform`: 4, `Storage`: 5, `StorageTexture`: 6, `SampledTexture`: 7}

var _VarRolesDescMap = map[VarRoles]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``}

var _VarRolesMap = map[VarRoles]string{0: `UndefVarRole`, 1: `Vertex`, 2: `Index`, 3: `Push`, 4: `Uniform`, 5: `Storage`, 6: `StorageTexture`, 7: `SampledTexture`}

// String returns the string representation of this VarRoles value.
func (i VarRoles) String() string { return enums.String(i, _VarRolesMap) }

// SetString sets the VarRoles value from its string representation,
// and returns an error if the string is invalid.
func (i *VarRoles) SetString(s string) error {
	return enums.SetString(i, s, _VarRolesValueMap, "VarRoles")
}

// Int64 returns the VarRoles value as an int64.
func (i VarRoles) Int64() int64 { return int64(i) }

// SetInt64 sets the VarRoles value from an int64.
func (i *VarRoles) SetInt64(in int64) { *i = VarRoles(in) }

// Desc returns the description of the VarRoles value.
func (i VarRoles) Desc() string { return enums.Desc(i, _VarRolesDescMap) }

// VarRolesValues returns all possible values for the type VarRoles.
func VarRolesValues() []VarRoles { return _VarRolesValues }

// Values returns all possible values for the type VarRoles.
func (i VarRoles) Values() []enums.Enum { return enums.Values(_VarRolesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VarRoles) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VarRoles) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "VarRoles") }

var _SamplerModesValues = []SamplerModes{0, 1, 2, 3, 4}

// SamplerModesN is the highest valid value for type SamplerModes, plus one.
const SamplerModesN SamplerModes = 5

var _SamplerModesValueMap = map[string]SamplerModes{`Repeat`: 0, `MirroredRepeat`: 1, `ClampToEdge`: 2, `ClampToBorder`: 3, `MirrorClampToEdge`: 4}

var _SamplerModesDescMap = map[SamplerModes]string{0: `Repeat the texture when going beyond the image dimensions.`, 1: `Like repeat, but inverts the coordinates to mirror the image when going beyond the dimensions.`, 2: `Take the color of the edge closest to the coordinate beyond the image dimensions.`, 3: `Return a solid color when sampling beyond the dimensions of the image.`, 4: `Like clamp to edge, but instead uses the edge opposite to the closest edge.`}

var _SamplerModesMap = map[SamplerModes]string{0: `Repeat`, 1: `MirroredRepeat`, 2: `ClampToEdge`, 3: `ClampToBorder`, 4: `MirrorClampToEdge`}

// String returns the string representation of this SamplerModes value.
func (i SamplerModes) String() string { return enums.String(i, _SamplerModesMap) }

// SetString sets the SamplerModes value from its string representation,
// and returns an error if the string is invalid.
func (i *SamplerModes) SetString(s string) error {
	return enums.SetString(i, s, _SamplerModesValueMap, "SamplerModes")
}

// Int64 returns the SamplerModes value as an int64.
func (i SamplerModes) Int64() int64 { return int64(i) }

// SetInt64 sets the SamplerModes value from an int64.
func (i *SamplerModes) SetInt64(in int64) { *i = SamplerModes(in) }

// Desc returns the description of the SamplerModes value.
func (i SamplerModes) Desc() string { return enums.Desc(i, _SamplerModesDescMap) }

// SamplerModesValues returns all possible values for the type SamplerModes.
func SamplerModesValues() []SamplerModes { return _SamplerModesValues }

// Values returns all possible values for the type SamplerModes.
func (i SamplerModes) Values() []enums.Enum { return enums.Values(_SamplerModesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SamplerModes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SamplerModes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "SamplerModes")
}

var _BorderColorsValues = []BorderColors{0, 1, 2}

// BorderColorsN is the highest valid value for type BorderColors, plus one.
const BorderColorsN BorderColors = 3

var _BorderColorsValueMap = map[string]BorderColors{`Trans`: 0, `Black`: 1, `White`: 2}

var _BorderColorsDescMap = map[BorderColors]string{0: `Repeat the texture when going beyond the image dimensions.`, 1: ``, 2: ``}

var _BorderColorsMap = map[BorderColors]string{0: `Trans`, 1: `Black`, 2: `White`}

// String returns the string representation of this BorderColors value.
func (i BorderColors) String() string { return enums.String(i, _BorderColorsMap) }

// SetString sets the BorderColors value from its string representation,
// and returns an error if the string is invalid.
func (i *BorderColors) SetString(s string) error {
	return enums.SetString(i, s, _BorderColorsValueMap, "BorderColors")
}

// Int64 returns the BorderColors value as an int64.
func (i BorderColors) Int64() int64 { return int64(i) }

// SetInt64 sets the BorderColors value from an int64.
func (i *BorderColors) SetInt64(in int64) { *i = BorderColors(in) }

// Desc returns the description of the BorderColors value.
func (i BorderColors) Desc() string { return enums.Desc(i, _BorderColorsDescMap) }

// BorderColorsValues returns all possible values for the type BorderColors.
func BorderColorsValues() []BorderColors { return _BorderColorsValues }

// Values returns all possible values for the type BorderColors.
func (i BorderColors) Values() []enums.Enum { return enums.Values(_BorderColorsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BorderColors) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BorderColors) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BorderColors")
}

var _TypesValues = []Types{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}

// TypesN is the highest valid value for type Types, plus one.
const TypesN Types = 24

var _TypesValueMap = map[string]Types{`UndefType`: 0, `Bool32`: 1, `Int16`: 2, `Uint16`: 3, `Int32`: 4, `Int32Vector2`: 5, `Int32Vector4`: 6, `Uint32`: 7, `Uint32Vector2`: 8, `Uint32Vector4`: 9, `Float32`: 10, `Float32Vector2`: 11, `Float32Vector3`: 12, `Float32Vector4`: 13, `Float64`: 14, `Float64Vector2`: 15, `Float64Vector3`: 16, `Float64Vector4`: 17, `Float32Matrix4`: 18, `Float32Matrix3`: 19, `ImageRGBA32`: 20, `Depth32`: 21, `Depth24Sten8`: 22, `Struct`: 23}

var _TypesDescMap = map[Types]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``, 12: ``, 13: ``, 14: ``, 15: ``, 16: ``, 17: ``, 18: ``, 19: ``, 20: ``, 21: ``, 22: ``, 23: ``}

var _TypesMap = map[Types]string{0: `UndefType`, 1: `Bool32`, 2: `Int16`, 3: `Uint16`, 4: `Int32`, 5: `Int32Vector2`, 6: `Int32Vector4`, 7: `Uint32`, 8: `Uint32Vector2`, 9: `Uint32Vector4`, 10: `Float32`, 11: `Float32Vector2`, 12: `Float32Vector3`, 13: `Float32Vector4`, 14: `Float64`, 15: `Float64Vector2`, 16: `Float64Vector3`, 17: `Float64Vector4`, 18: `Float32Matrix4`, 19: `Float32Matrix3`, 20: `ImageRGBA32`, 21: `Depth32`, 22: `Depth24Sten8`, 23: `Struct`}

// String returns the string representation of this Types value.
func (i Types) String() string { return enums.String(i, _TypesMap) }

// SetString sets the Types value from its string representation,
// and returns an error if the string is invalid.
func (i *Types) SetString(s string) error { return enums.SetString(i, s, _TypesValueMap, "Types") }

// Int64 returns the Types value as an int64.
func (i Types) Int64() int64 { return int64(i) }

// SetInt64 sets the Types value from an int64.
func (i *Types) SetInt64(in int64) { *i = Types(in) }

// Desc returns the description of the Types value.
func (i Types) Desc() string { return enums.Desc(i, _TypesDescMap) }

// TypesValues returns all possible values for the type Types.
func TypesValues() []Types { return _TypesValues }

// Values returns all possible values for the type Types.
func (i Types) Values() []enums.Enum { return enums.Values(_TypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Types) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Types) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Types") }

var _ValueFlagsValues = []ValueFlags{0, 1}

// ValueFlagsN is the highest valid value for type ValueFlags, plus one.
const ValueFlagsN ValueFlags = 2

var _ValueFlagsValueMap = map[string]ValueFlags{`PaddedArray`: 0, `TextureOwns`: 1}

var _ValueFlagsDescMap = map[ValueFlags]string{0: `ValuePaddedArray array had to be padded -- cannot access elements continuously`, 1: `ValueTextureOwns val owns and manages the host staging memory for texture. based on Var TextureOwns -- for dynamically changing images.`}

var _ValueFlagsMap = map[ValueFlags]string{0: `PaddedArray`, 1: `TextureOwns`}

// String returns the string representation of this ValueFlags value.
func (i ValueFlags) String() string { return enums.BitFlagString(i, _ValueFlagsValues) }

// BitIndexString returns the string representation of this ValueFlags value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i ValueFlags) BitIndexString() string { return enums.String(i, _ValueFlagsMap) }

// SetString sets the ValueFlags value from its string representation,
// and returns an error if the string is invalid.
func (i *ValueFlags) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the ValueFlags value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *ValueFlags) SetStringOr(s string) error {
	return enums.SetStringOr(i, s, _ValueFlagsValueMap, "ValueFlags")
}

// Int64 returns the ValueFlags value as an int64.
func (i ValueFlags) Int64() int64 { return int64(i) }

// SetInt64 sets the ValueFlags value from an int64.
func (i *ValueFlags) SetInt64(in int64) { *i = ValueFlags(in) }

// Desc returns the description of the ValueFlags value.
func (i ValueFlags) Desc() string { return enums.Desc(i, _ValueFlagsDescMap) }

// ValueFlagsValues returns all possible values for the type ValueFlags.
func ValueFlagsValues() []ValueFlags { return _ValueFlagsValues }

// Values returns all possible values for the type ValueFlags.
func (i ValueFlags) Values() []enums.Enum { return enums.Values(_ValueFlagsValues) }

// HasFlag returns whether these bit flags have the given bit flag set.
func (i ValueFlags) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(&i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *ValueFlags) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ValueFlags) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ValueFlags) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ValueFlags")
}
