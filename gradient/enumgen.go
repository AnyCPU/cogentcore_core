// Code generated by "goki generate ./..."; DO NOT EDIT.

package gradient

import (
	"errors"
	"log"
	"strconv"
	"strings"

	"goki.dev/enums"
)

var _SpreadsValues = []Spreads{0, 1, 2}

// SpreadsN is the highest valid value
// for type Spreads, plus one.
const SpreadsN Spreads = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SpreadsNoOp() {
	var x [1]struct{}
	_ = x[Pad-(0)]
	_ = x[Reflect-(1)]
	_ = x[Repeat-(2)]
}

var _SpreadsNameToValueMap = map[string]Spreads{
	`pad`:     0,
	`reflect`: 1,
	`repeat`:  2,
}

var _SpreadsDescMap = map[Spreads]string{
	0: `Pad indicates to have the final color of the gradient fill the object beyond the end of the gradient.`,
	1: `Reflect indicates to have a gradient repeat in reverse order (offset 1 to 0) to fully fill an object beyond the end of the gradient.`,
	2: `Repeat indicates to have a gradient continue in its original order (offset 0 to 1) by jumping back to the start to fully fill an object beyond the end of the gradient.`,
}

var _SpreadsMap = map[Spreads]string{
	0: `pad`,
	1: `reflect`,
	2: `repeat`,
}

// String returns the string representation
// of this Spreads value.
func (i Spreads) String() string {
	if str, ok := _SpreadsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Spreads value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Spreads) SetString(s string) error {
	if val, ok := _SpreadsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SpreadsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Spreads")
}

// Int64 returns the Spreads value as an int64.
func (i Spreads) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Spreads value from an int64.
func (i *Spreads) SetInt64(in int64) {
	*i = Spreads(in)
}

// Desc returns the description of the Spreads value.
func (i Spreads) Desc() string {
	if str, ok := _SpreadsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SpreadsValues returns all possible values
// for the type Spreads.
func SpreadsValues() []Spreads {
	return _SpreadsValues
}

// Values returns all possible values
// for the type Spreads.
func (i Spreads) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SpreadsValues))
	for i, d := range _SpreadsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Spreads.
func (i Spreads) IsValid() bool {
	_, ok := _SpreadsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Spreads) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Spreads) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _UnitsValues = []Units{0, 1}

// UnitsN is the highest valid value
// for type Units, plus one.
const UnitsN Units = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _UnitsNoOp() {
	var x [1]struct{}
	_ = x[ObjectBoundingBox-(0)]
	_ = x[UserSpaceOnUse-(1)]
}

var _UnitsNameToValueMap = map[string]Units{
	`ObjectBoundingBox`: 0,
	`objectboundingbox`: 0,
	`UserSpaceOnUse`:    1,
	`userspaceonuse`:    1,
}

var _UnitsDescMap = map[Units]string{
	0: `ObjectBoundingBox indicates that coordinate values are scaled relative to the size of the object and are specified in the normalized range of 0 to 1.`,
	1: `UserSpaceOnUse indicates that coordinate values are specified in the current user coordinate system when the gradient is used (ie: actual SVG/gi coordinates).`,
}

var _UnitsMap = map[Units]string{
	0: `ObjectBoundingBox`,
	1: `UserSpaceOnUse`,
}

// String returns the string representation
// of this Units value.
func (i Units) String() string {
	if str, ok := _UnitsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Units value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Units) SetString(s string) error {
	if val, ok := _UnitsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _UnitsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Units")
}

// Int64 returns the Units value as an int64.
func (i Units) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Units value from an int64.
func (i *Units) SetInt64(in int64) {
	*i = Units(in)
}

// Desc returns the description of the Units value.
func (i Units) Desc() string {
	if str, ok := _UnitsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// UnitsValues returns all possible values
// for the type Units.
func UnitsValues() []Units {
	return _UnitsValues
}

// Values returns all possible values
// for the type Units.
func (i Units) Values() []enums.Enum {
	res := make([]enums.Enum, len(_UnitsValues))
	for i, d := range _UnitsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Units.
func (i Units) IsValid() bool {
	_, ok := _UnitsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Units) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Units) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}
