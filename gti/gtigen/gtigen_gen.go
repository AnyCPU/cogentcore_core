// Code generated by "gtigen -output gtigen_gen.go"; DO NOT EDIT.

package gtigen

import (
	"goki.dev/goki/gti"
	"goki.dev/goki/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/goki/gti/gtigen.Config",
	ShortName: "gtigen.Config",
	IDName:    "config",
	Doc:       "Config contains the configuration information\nused by gtigen",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Dir", &gti.Field{Name: "Dir", Type: "string", LocalType: "string", Doc: "the source directory to run gtigen on (can be set to multiple through paths like ./...)", Directives: gti.Directives{}, Tag: "def:\".\" posarg:\"0\" required:\"-\""}},
		{"Output", &gti.Field{Name: "Output", Type: "string", LocalType: "string", Doc: "the output file location relative to the package on which gtigen is being called", Directives: gti.Directives{}, Tag: "def:\"gtigen.go\""}},
		{"AddTypes", &gti.Field{Name: "AddTypes", Type: "bool", LocalType: "bool", Doc: "whether to add types to gtigen by default", Directives: gti.Directives{}, Tag: ""}},
		{"AddMethods", &gti.Field{Name: "AddMethods", Type: "bool", LocalType: "bool", Doc: "whether to add methods to gtigen by default", Directives: gti.Directives{}, Tag: ""}},
		{"AddFuncs", &gti.Field{Name: "AddFuncs", Type: "bool", LocalType: "bool", Doc: "whether to add functions to gtigen by default", Directives: gti.Directives{}, Tag: ""}},
		{"InterfaceConfigs", &gti.Field{Name: "InterfaceConfigs", Type: "map[string]*goki.dev/goki/gti/gtigen.Config", LocalType: "map[string]*Config", Doc: "A map of configs keyed by fully-qualified interface type names; if a type implements the interface, the config will be applied to it.\nNote: the package gtigen is run on must explicitly reference this interface at some point for this to work; adding a simple\n`var _ MyInterface = (*MyType)(nil)` statement to check for interface implementation is an easy way to accomplish that.\nNote: gtigen will still succeed if it can not find one of the interfaces specified here in order to allow it to work generically across multiple directories; you can use the -v flag to get log warnings about this if you suspect that it is not finding interfaces when it should.", Directives: gti.Directives{}, Tag: ""}},
		{"Instance", &gti.Field{Name: "Instance", Type: "bool", LocalType: "bool", Doc: "whether to generate an instance of the type(s)", Directives: gti.Directives{}, Tag: ""}},
		{"TypeVar", &gti.Field{Name: "TypeVar", Type: "bool", LocalType: "bool", Doc: "whether to generate a global type variable of the form 'TypeNameType'", Directives: gti.Directives{}, Tag: ""}},
		{"Setters", &gti.Field{Name: "Setters", Type: "bool", LocalType: "bool", Doc: "Whether to generate chaining `Set*` methods for each field of each type (eg: \"SetText\" for field \"Text\").\nIf this is set to true, then you can add `set:\"-\"` struct tags to individual fields\nto prevent Set methods being generated for them.", Directives: gti.Directives{}, Tag: ""}},
		{"Templates", &gti.Field{Name: "Templates", Type: "[]*text/template.Template", LocalType: "[]*template.Template", Doc: "a slice of templates to execute on each type being added; the template data is of the type gtigen.Type", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddFunc(&gti.Func{
	Name: "goki.dev/goki/gti/gtigen.Generate",
	Doc:  "Generate generates gti type info, using the\nconfiguration information, loading the packages from the\nconfiguration source directory, and writing the result\nto the configuration output file.\n\nIt is a simple entry point to gtigen that does all\nof the steps; for more specific functionality, create\na new [Generator] with [NewGenerator] and call methods on it.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		&gti.Directive{Tool: "grease", Directive: "cmd", Args: []string{"-root"}},
	},
	Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"cfg", &gti.Field{Name: "cfg", Type: "*goki.dev/goki/gti/gtigen.Config", LocalType: "*Config", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
})
