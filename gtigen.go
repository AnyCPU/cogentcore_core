// Code generated by "goki generate"; DO NOT EDIT.

package svg

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
)

// CircleType is the [gti.Type] for [Circle]
var CircleType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Circle",
	Doc:        "Circle is a SVG circle",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec2", Doc: "position of the center of the circle", Directives: gti.Directives{}}},
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", Doc: "radius of the circle", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Circle{},
})

// NewCircle adds a new [Circle] with
// the given name to the given parent.
func NewCircle(par ki.Ki, name string) *Circle {
	return par.NewChild(CircleType, name).(*Circle)
}

// KiType returns the [*gti.Type] of [Circle]
func (t *Circle) KiType() *gti.Type {
	return CircleType
}

// New returns a new [*Circle] value
func (t *Circle) New() ki.Ki {
	return &Circle{}
}

// ClipPathType is the [gti.Type] for [ClipPath]
var ClipPathType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.ClipPath",
	Doc:        "ClipPath is used for holding a path that renders as a clip path",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ClipPath{},
})

// NewClipPath adds a new [ClipPath] with
// the given name to the given parent.
func NewClipPath(par ki.Ki, name string) *ClipPath {
	return par.NewChild(ClipPathType, name).(*ClipPath)
}

// KiType returns the [*gti.Type] of [ClipPath]
func (t *ClipPath) KiType() *gti.Type {
	return ClipPathType
}

// New returns a new [*ClipPath] value
func (t *ClipPath) New() ki.Ki {
	return &ClipPath{}
}

// StyleSheetType is the [gti.Type] for [StyleSheet]
var StyleSheetType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.StyleSheet",
	Doc:        "StyleSheet is a Node2D node that contains a stylesheet -- property values\ncontained in this sheet can be transformed into ki.Props and set in CSS\nfield of appropriate node",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Sheet", &gti.Field{Name: "Sheet", Type: "*css.Stylesheet", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &StyleSheet{},
})

// NewStyleSheet adds a new [StyleSheet] with
// the given name to the given parent.
func NewStyleSheet(par ki.Ki, name string) *StyleSheet {
	return par.NewChild(StyleSheetType, name).(*StyleSheet)
}

// KiType returns the [*gti.Type] of [StyleSheet]
func (t *StyleSheet) KiType() *gti.Type {
	return StyleSheetType
}

// New returns a new [*StyleSheet] value
func (t *StyleSheet) New() ki.Ki {
	return &StyleSheet{}
}

// MetaDataType is the [gti.Type] for [MetaData]
var MetaDataType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.MetaData",
	Doc:        "MetaData is used for holding meta data info",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MetaData", &gti.Field{Name: "MetaData", Type: "string", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &MetaData{},
})

// NewMetaData adds a new [MetaData] with
// the given name to the given parent.
func NewMetaData(par ki.Ki, name string) *MetaData {
	return par.NewChild(MetaDataType, name).(*MetaData)
}

// KiType returns the [*gti.Type] of [MetaData]
func (t *MetaData) KiType() *gti.Type {
	return MetaDataType
}

// New returns a new [*MetaData] value
func (t *MetaData) New() ki.Ki {
	return &MetaData{}
}

// EllipseType is the [gti.Type] for [Ellipse]
var EllipseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Ellipse",
	Doc:        "Ellipse is a SVG ellipse",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec2", Doc: "position of the center of the ellipse", Directives: gti.Directives{}}},
		{"Radii", &gti.Field{Name: "Radii", Type: "mat32.Vec2", Doc: "radii of the ellipse in the horizontal, vertical axes", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Ellipse{},
})

// NewEllipse adds a new [Ellipse] with
// the given name to the given parent.
func NewEllipse(par ki.Ki, name string) *Ellipse {
	return par.NewChild(EllipseType, name).(*Ellipse)
}

// KiType returns the [*gti.Type] of [Ellipse]
func (t *Ellipse) KiType() *gti.Type {
	return EllipseType
}

// New returns a new [*Ellipse] value
func (t *Ellipse) New() ki.Ki {
	return &Ellipse{}
}

// FilterType is the [gti.Type] for [Filter]
var FilterType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Filter",
	Doc:        "Filter represents SVG filter* elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FilterType", &gti.Field{Name: "FilterType", Type: "string", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Filter{},
})

// NewFilter adds a new [Filter] with
// the given name to the given parent.
func NewFilter(par ki.Ki, name string) *Filter {
	return par.NewChild(FilterType, name).(*Filter)
}

// KiType returns the [*gti.Type] of [Filter]
func (t *Filter) KiType() *gti.Type {
	return FilterType
}

// New returns a new [*Filter] value
func (t *Filter) New() ki.Ki {
	return &Filter{}
}

// FlowType is the [gti.Type] for [Flow]
var FlowType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Flow",
	Doc:        "Flow represents SVG flow* elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"FlowType", &gti.Field{Name: "FlowType", Type: "string", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Flow{},
})

// NewFlow adds a new [Flow] with
// the given name to the given parent.
func NewFlow(par ki.Ki, name string) *Flow {
	return par.NewChild(FlowType, name).(*Flow)
}

// KiType returns the [*gti.Type] of [Flow]
func (t *Flow) KiType() *gti.Type {
	return FlowType
}

// New returns a new [*Flow] value
func (t *Flow) New() ki.Ki {
	return &Flow{}
}

// GradientType is the [gti.Type] for [Gradient]
var GradientType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Gradient",
	Doc:        "Gradient is used for holding a specified color gradient (ColorSpec)\nname is id for lookup in url",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Grad", &gti.Field{Name: "Grad", Type: "colors.Full", Doc: "the color gradient", Directives: gti.Directives{}}},
		{"StopsName", &gti.Field{Name: "StopsName", Type: "string", Doc: "name of another gradient to get stops from", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Gradient{},
})

// NewGradient adds a new [Gradient] with
// the given name to the given parent.
func NewGradient(par ki.Ki, name string) *Gradient {
	return par.NewChild(GradientType, name).(*Gradient)
}

// KiType returns the [*gti.Type] of [Gradient]
func (t *Gradient) KiType() *gti.Type {
	return GradientType
}

// New returns a new [*Gradient] value
func (t *Gradient) New() ki.Ki {
	return &Gradient{}
}

// GroupType is the [gti.Type] for [Group]
var GroupType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Group",
	Doc:        "Group groups together SVG elements.\nProvides a common transform for all group elements\nand shared style properties.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Group{},
})

// NewGroup adds a new [Group] with
// the given name to the given parent.
func NewGroup(par ki.Ki, name string) *Group {
	return par.NewChild(GroupType, name).(*Group)
}

// KiType returns the [*gti.Type] of [Group]
func (t *Group) KiType() *gti.Type {
	return GroupType
}

// New returns a new [*Group] value
func (t *Group) New() ki.Ki {
	return &Group{}
}

// ImageType is the [gti.Type] for [Image]
var ImageType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Image",
	Doc:        "Image is an SVG image (bitmap)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec2", Doc: "position of the top-left of the image", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "mat32.Vec2", Doc: "rendered size of the image (imposes a scaling on image when it is rendered)", Directives: gti.Directives{}}},
		{"PreserveAspectRatio", &gti.Field{Name: "PreserveAspectRatio", Type: "bool", Doc: "directs resize operations to preserve aspect ratio", Directives: gti.Directives{}}},
		{"Filename", &gti.Field{Name: "Filename", Type: "string", Doc: "file name of image loaded -- set by OpenImage", Directives: gti.Directives{}}},
		{"Pixels", &gti.Field{Name: "Pixels", Type: "*image.RGBA", Doc: "[view: -] the image pixels", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Image{},
})

// NewImage adds a new [Image] with
// the given name to the given parent.
func NewImage(par ki.Ki, name string) *Image {
	return par.NewChild(ImageType, name).(*Image)
}

// KiType returns the [*gti.Type] of [Image]
func (t *Image) KiType() *gti.Type {
	return ImageType
}

// New returns a new [*Image] value
func (t *Image) New() ki.Ki {
	return &Image{}
}

// LineType is the [gti.Type] for [Line]
var LineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Line",
	Doc:        "Line is a SVG line",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Start", &gti.Field{Name: "Start", Type: "mat32.Vec2", Doc: "position of the start of the line", Directives: gti.Directives{}}},
		{"End", &gti.Field{Name: "End", Type: "mat32.Vec2", Doc: "position of the end of the line", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Line{},
})

// NewLine adds a new [Line] with
// the given name to the given parent.
func NewLine(par ki.Ki, name string) *Line {
	return par.NewChild(LineType, name).(*Line)
}

// KiType returns the [*gti.Type] of [Line]
func (t *Line) KiType() *gti.Type {
	return LineType
}

// New returns a new [*Line] value
func (t *Line) New() ki.Ki {
	return &Line{}
}

// MarkerType is the [gti.Type] for [Marker]
var MarkerType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Marker",
	Doc:        "Marker represents marker elements that can be drawn along paths (arrow heads, etc)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"RefPos", &gti.Field{Name: "RefPos", Type: "mat32.Vec2", Doc: "reference position to align the vertex position with, specified in ViewBox coordinates", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "mat32.Vec2", Doc: "size of marker to render, in Units units", Directives: gti.Directives{}}},
		{"Units", &gti.Field{Name: "Units", Type: "MarkerUnits", Doc: "units to use", Directives: gti.Directives{}}},
		{"ViewBox", &gti.Field{Name: "ViewBox", Type: "ViewBox", Doc: "viewbox defines the internal coordinate system for the drawing elements within the marker", Directives: gti.Directives{}}},
		{"Orient", &gti.Field{Name: "Orient", Type: "string", Doc: "orientation of the marker -- either 'auto' or an angle", Directives: gti.Directives{}}},
		{"VertexPos", &gti.Field{Name: "VertexPos", Type: "mat32.Vec2", Doc: "current vertex position", Directives: gti.Directives{}}},
		{"VertexAngle", &gti.Field{Name: "VertexAngle", Type: "float32", Doc: "current vertex angle in radians", Directives: gti.Directives{}}},
		{"StrokeWidth", &gti.Field{Name: "StrokeWidth", Type: "float32", Doc: "current stroke width", Directives: gti.Directives{}}},
		{"XForm", &gti.Field{Name: "XForm", Type: "mat32.Mat2", Doc: "net transform computed from settings and current values -- applied prior to rendering", Directives: gti.Directives{}}},
		{"EffSize", &gti.Field{Name: "EffSize", Type: "mat32.Vec2", Doc: "effective size for actual rendering", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Marker{},
})

// NewMarker adds a new [Marker] with
// the given name to the given parent.
func NewMarker(par ki.Ki, name string) *Marker {
	return par.NewChild(MarkerType, name).(*Marker)
}

// KiType returns the [*gti.Type] of [Marker]
func (t *Marker) KiType() *gti.Type {
	return MarkerType
}

// New returns a new [*Marker] value
func (t *Marker) New() ki.Ki {
	return &Marker{}
}

// NodeBaseType is the [gti.Type] for [NodeBase]
var NodeBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.NodeBase",
	Doc:        "svg.NodeBase is the base type for elements within the SVG scenegraph",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Class", &gti.Field{Name: "Class", Type: "string", Doc: "user-defined class name(s) used primarily for attaching CSS styles to different display elements -- multiple class names can be used to combine properties: use spaces to separate per css standard", Directives: gti.Directives{}}},
		{"CSS", &gti.Field{Name: "CSS", Type: "ki.Props", Doc: "cascading style sheet at this level -- these styles apply here and to everything below, until superceded -- use .class and #name Props elements to apply entire styles to given elements, and type for element type", Directives: gti.Directives{}}},
		{"CSSAgg", &gti.Field{Name: "CSSAgg", Type: "ki.Props", Doc: "[view: no-inline] aggregated css properties from all higher nodes down to me", Directives: gti.Directives{}}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", Doc: "bounding box for the node within the SVG Pixels image -- this one can be outside the visible range of the SVG image -- VpBBox is intersected and only shows visible portion.", Directives: gti.Directives{}}},
		{"VisBBox", &gti.Field{Name: "VisBBox", Type: "image.Rectangle", Doc: "visible bounding box for the node intersected with the SVG image geometry", Directives: gti.Directives{}}},
		{"Paint", &gti.Field{Name: "Paint", Type: "paint.Paint", Doc: "paint style information for this node", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &NodeBase{},
})

// NewNodeBase adds a new [NodeBase] with
// the given name to the given parent.
func NewNodeBase(par ki.Ki, name string) *NodeBase {
	return par.NewChild(NodeBaseType, name).(*NodeBase)
}

// KiType returns the [*gti.Type] of [NodeBase]
func (t *NodeBase) KiType() *gti.Type {
	return NodeBaseType
}

// New returns a new [*NodeBase] value
func (t *NodeBase) New() ki.Ki {
	return &NodeBase{}
}

// PathType is the [gti.Type] for [Path]
var PathType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Path",
	Doc:        "Path renders SVG data sequences that can render just about anything",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Data", &gti.Field{Name: "Data", Type: "[]PathData", Doc: "the path data to render -- path commands and numbers are serialized, with each command specifying the number of floating-point coord data points that follow", Directives: gti.Directives{}}},
		{"DataStr", &gti.Field{Name: "DataStr", Type: "string", Doc: "string version of the path data", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Path{},
})

// NewPath adds a new [Path] with
// the given name to the given parent.
func NewPath(par ki.Ki, name string) *Path {
	return par.NewChild(PathType, name).(*Path)
}

// KiType returns the [*gti.Type] of [Path]
func (t *Path) KiType() *gti.Type {
	return PathType
}

// New returns a new [*Path] value
func (t *Path) New() ki.Ki {
	return &Path{}
}

// PolygonType is the [gti.Type] for [Polygon]
var PolygonType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Polygon",
	Doc:        "Polygon is a SVG polygon",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Polyline", &gti.Field{Name: "Polyline", Type: "Polyline", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Polygon{},
})

// NewPolygon adds a new [Polygon] with
// the given name to the given parent.
func NewPolygon(par ki.Ki, name string) *Polygon {
	return par.NewChild(PolygonType, name).(*Polygon)
}

// KiType returns the [*gti.Type] of [Polygon]
func (t *Polygon) KiType() *gti.Type {
	return PolygonType
}

// New returns a new [*Polygon] value
func (t *Polygon) New() ki.Ki {
	return &Polygon{}
}

// PolylineType is the [gti.Type] for [Polyline]
var PolylineType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Polyline",
	Doc:        "Polyline is a SVG multi-line shape",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Points", &gti.Field{Name: "Points", Type: "[]mat32.Vec2", Doc: "the coordinates to draw -- does a moveto on the first, then lineto for all the rest", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Polyline{},
})

// NewPolyline adds a new [Polyline] with
// the given name to the given parent.
func NewPolyline(par ki.Ki, name string) *Polyline {
	return par.NewChild(PolylineType, name).(*Polyline)
}

// KiType returns the [*gti.Type] of [Polyline]
func (t *Polyline) KiType() *gti.Type {
	return PolylineType
}

// New returns a new [*Polyline] value
func (t *Polyline) New() ki.Ki {
	return &Polyline{}
}

// RectType is the [gti.Type] for [Rect]
var RectType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Rect",
	Doc:        "Rect is a SVG rectangle, optionally with rounded corners",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec2", Doc: "position of the top-left of the rectangle", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "mat32.Vec2", Doc: "size of the rectangle", Directives: gti.Directives{}}},
		{"Radius", &gti.Field{Name: "Radius", Type: "mat32.Vec2", Doc: "radii for curved corners, as a proportion of width, height", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Rect{},
})

// NewRect adds a new [Rect] with
// the given name to the given parent.
func NewRect(par ki.Ki, name string) *Rect {
	return par.NewChild(RectType, name).(*Rect)
}

// KiType returns the [*gti.Type] of [Rect]
func (t *Rect) KiType() *gti.Type {
	return RectType
}

// New returns a new [*Rect] value
func (t *Rect) New() ki.Ki {
	return &Rect{}
}

// SVGNodeType is the [gti.Type] for [SVGNode]
var SVGNodeType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.SVGNode",
	Doc:        "SVGNode represents the root of an SVG tree",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ViewBox", &gti.Field{Name: "ViewBox", Type: "ViewBox", Doc: "viewbox defines the coordinate system for the drawing -- these units are mapped into the screen space allocated for the SVG during rendering", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Group", &gti.Field{Name: "Group", Type: "Group", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SVGNode{},
})

// NewSVGNode adds a new [SVGNode] with
// the given name to the given parent.
func NewSVGNode(par ki.Ki, name string) *SVGNode {
	return par.NewChild(SVGNodeType, name).(*SVGNode)
}

// KiType returns the [*gti.Type] of [SVGNode]
func (t *SVGNode) KiType() *gti.Type {
	return SVGNodeType
}

// New returns a new [*SVGNode] value
func (t *SVGNode) New() ki.Ki {
	return &SVGNode{}
}

// TextType is the [gti.Type] for [Text]
var TextType = gti.AddType(&gti.Type{
	Name:       "goki.dev/svg.Text",
	Doc:        "Text renders SVG text, handling both text and tspan elements.\ntspan is nested under a parent text -- text has empty Text string.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec2", Doc: "position of the left, baseline of the text", Directives: gti.Directives{}}},
		{"Width", &gti.Field{Name: "Width", Type: "float32", Doc: "width of text to render if using word-wrapping", Directives: gti.Directives{}}},
		{"Text", &gti.Field{Name: "Text", Type: "string", Doc: "text string to render", Directives: gti.Directives{}}},
		{"TextRender", &gti.Field{Name: "TextRender", Type: "paint.Text", Doc: "render version of text", Directives: gti.Directives{}}},
		{"CharPosX", &gti.Field{Name: "CharPosX", Type: "[]float32", Doc: "character positions along X axis, if specified", Directives: gti.Directives{}}},
		{"CharPosY", &gti.Field{Name: "CharPosY", Type: "[]float32", Doc: "character positions along Y axis, if specified", Directives: gti.Directives{}}},
		{"CharPosDX", &gti.Field{Name: "CharPosDX", Type: "[]float32", Doc: "character delta-positions along X axis, if specified", Directives: gti.Directives{}}},
		{"CharPosDY", &gti.Field{Name: "CharPosDY", Type: "[]float32", Doc: "character delta-positions along Y axis, if specified", Directives: gti.Directives{}}},
		{"CharRots", &gti.Field{Name: "CharRots", Type: "[]float32", Doc: "character rotations, if specified", Directives: gti.Directives{}}},
		{"TextLength", &gti.Field{Name: "TextLength", Type: "float32", Doc: "author's computed text length, if specified -- we attempt to match", Directives: gti.Directives{}}},
		{"AdjustGlyphs", &gti.Field{Name: "AdjustGlyphs", Type: "bool", Doc: "in attempting to match TextLength, should we adjust glyphs in addition to spacing?", Directives: gti.Directives{}}},
		{"LastPos", &gti.Field{Name: "LastPos", Type: "mat32.Vec2", Doc: "last text render position -- lower-left baseline of start", Directives: gti.Directives{}}},
		{"LastBBox", &gti.Field{Name: "LastBBox", Type: "mat32.Box2", Doc: "last actual bounding box in display units (dots)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "NodeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Text{},
})

// NewText adds a new [Text] with
// the given name to the given parent.
func NewText(par ki.Ki, name string) *Text {
	return par.NewChild(TextType, name).(*Text)
}

// KiType returns the [*gti.Type] of [Text]
func (t *Text) KiType() *gti.Type {
	return TextType
}

// New returns a new [*Text] value
func (t *Text) New() ki.Ki {
	return &Text{}
}
