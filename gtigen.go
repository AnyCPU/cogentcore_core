// Code generated by "goki generate"; DO NOT EDIT.

package gi3d

import (
	"image/color"

	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
)

// GroupType is the [gti.Type] for [Group]
var GroupType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.Group",
	ShortName:  "gi3d.Group",
	IDName:     "group",
	Doc:        "Group collects individual elements in a scene but does not have a Mesh or Material of\nits own.  It does have a transform that applies to all nodes under it.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "goki.dev/gi3d.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Group{},
})

// NewGroup adds a new [Group] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewGroup(par ki.Ki, name ...string) *Group {
	return par.NewChild(GroupType, name...).(*Group)
}

// KiType returns the [*gti.Type] of [Group]
func (t *Group) KiType() *gti.Type {
	return GroupType
}

// New returns a new [*Group] value
func (t *Group) New() ki.Ki {
	return &Group{}
}

// ManipPtType is the [gti.Type] for [ManipPt]
var ManipPtType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.ManipPt",
	ShortName:  "gi3d.ManipPt",
	IDName:     "manip-pt",
	Doc:        "ManipPt is a manipulation control point",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/gi3d.Solid", LocalType: "Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ManipPt{},
})

// NewManipPt adds a new [ManipPt] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewManipPt(par ki.Ki, name ...string) *ManipPt {
	return par.NewChild(ManipPtType, name...).(*ManipPt)
}

// KiType returns the [*gti.Type] of [ManipPt]
func (t *ManipPt) KiType() *gti.Type {
	return ManipPtType
}

// New returns a new [*ManipPt] value
func (t *ManipPt) New() ki.Ki {
	return &ManipPt{}
}

// SetMat sets the [ManipPt.Mat]
func (t *ManipPt) SetMat(v Material) *ManipPt {
	t.Mat = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Material",
	ShortName: "gi3d.Material",
	IDName:    "material",
	Doc:       "Material describes the material properties of a surface (colors, shininess, texture)\ni.e., phong lighting parameters.\nMain color is used for both ambient and diffuse color, and alpha component\nis used for opacity.  The Emissive color is only for glowing objects.\nThe Specular color is always white (multiplied by light color).\nTextures are stored on the Scene and accessed by name",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "prop: color = main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering", Directives: gti.Directives{}, Tag: ""}},
		{"Emissive", &gti.Field{Name: "Emissive", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "prop: emissive = color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object", Directives: gti.Directives{}, Tag: ""}},
		{"Shiny", &gti.Field{Name: "Shiny", Type: "float32", LocalType: "float32", Doc: "prop: shiny = specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect.", Directives: gti.Directives{}, Tag: ""}},
		{"Reflective", &gti.Field{Name: "Reflective", Type: "float32", LocalType: "float32", Doc: "prop: reflective = specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light.", Directives: gti.Directives{}, Tag: ""}},
		{"Bright", &gti.Field{Name: "Bright", Type: "float32", LocalType: "float32", Doc: "prop: bright = overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters", Directives: gti.Directives{}, Tag: ""}},
		{"Texture", &gti.Field{Name: "Texture", Type: "goki.dev/gi3d.TexName", LocalType: "TexName", Doc: "prop: texture = texture to provide color for the surface", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Tiling", &gti.Field{Name: "Tiling", Type: "goki.dev/gi3d.Tiling", LocalType: "Tiling", Doc: "texture tiling parameters -- repeat and offset", Directives: gti.Directives{}, Tag: "view:\"inline\" viewif:\"Texture!=''\""}},
		{"CullBack", &gti.Field{Name: "CullBack", Type: "bool", LocalType: "bool", Doc: "prop: cull-back = cull the back-facing surfaces", Directives: gti.Directives{}, Tag: ""}},
		{"CullFront", &gti.Field{Name: "CullFront", Type: "bool", LocalType: "bool", Doc: "prop: cull-front = cull the front-facing surfaces", Directives: gti.Directives{}, Tag: ""}},
		{"TexPtr", &gti.Field{Name: "TexPtr", Type: "goki.dev/gi3d.Texture", LocalType: "Texture", Doc: "pointer to texture", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetColor sets the [Material.Color]:
// prop: color = main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering
func (t *Material) SetColor(v color.RGBA) *Material {
	t.Color = v
	return t
}

// SetEmissive sets the [Material.Emissive]:
// prop: emissive = color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object
func (t *Material) SetEmissive(v color.RGBA) *Material {
	t.Emissive = v
	return t
}

// SetShiny sets the [Material.Shiny]:
// prop: shiny = specular shininess factor -- how focally vs. broad the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128 or so but can go higher) having a smaller more focal specular reflection.  Also set Reflective factor to change overall shininess effect.
func (t *Material) SetShiny(v float32) *Material {
	t.Shiny = v
	return t
}

// SetReflective sets the [Material.Reflective]:
// prop: reflective = specular reflectiveness factor -- how much it shines back directional light.  The specular reflection color is always white * the incoming light.
func (t *Material) SetReflective(v float32) *Material {
	t.Reflective = v
	return t
}

// SetBright sets the [Material.Bright]:
// prop: bright = overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters
func (t *Material) SetBright(v float32) *Material {
	t.Bright = v
	return t
}

// SetTiling sets the [Material.Tiling]:
// texture tiling parameters -- repeat and offset
func (t *Material) SetTiling(v Tiling) *Material {
	t.Tiling = v
	return t
}

// SetCullBack sets the [Material.CullBack]:
// prop: cull-back = cull the back-facing surfaces
func (t *Material) SetCullBack(v bool) *Material {
	t.CullBack = v
	return t
}

// SetCullFront sets the [Material.CullFront]:
// prop: cull-front = cull the front-facing surfaces
func (t *Material) SetCullFront(v bool) *Material {
	t.CullFront = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.MeshBase",
	ShortName: "gi3d.MeshBase",
	IDName:    "mesh-base",
	Doc:       "MeshBase provides the core implementation of Mesh interface",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Nm", &gti.Field{Name: "Nm", Type: "string", LocalType: "string", Doc: "name of mesh -- meshes are linked to Solids by name so this matters", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"NVtx", &gti.Field{Name: "NVtx", Type: "int", LocalType: "int", Doc: "number of vertex points, as mat32.Vec3 -- always includes mat32.Vec3 normals and mat32.Vec2 texture coordinates -- only valid after Sizes() has been called", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"NIdx", &gti.Field{Name: "NIdx", Type: "int", LocalType: "int", Doc: "number of indexes, as mat32.ArrayU32 -- only valid after Sizes() has been called", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Color", &gti.Field{Name: "Color", Type: "bool", LocalType: "bool", Doc: "has per-vertex colors, as mat32.Vec4 per vertex", Directives: gti.Directives{}, Tag: ""}},
		{"Dynamic", &gti.Field{Name: "Dynamic", Type: "bool", LocalType: "bool", Doc: "if true, this mesh changes frequently -- otherwise considered to be static", Directives: gti.Directives{}, Tag: ""}},
		{"Trans", &gti.Field{Name: "Trans", Type: "bool", LocalType: "bool", Doc: "set to true if color has transparency -- not worth checking manually", Directives: gti.Directives{}, Tag: ""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "computed bounding-box and other gross solid properties", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex on bbox access", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetColor sets the [MeshBase.Color]:
// has per-vertex colors, as mat32.Vec4 per vertex
func (t *MeshBase) SetColor(v bool) *MeshBase {
	t.Color = v
	return t
}

// SetDynamic sets the [MeshBase.Dynamic]:
// if true, this mesh changes frequently -- otherwise considered to be static
func (t *MeshBase) SetDynamic(v bool) *MeshBase {
	t.Dynamic = v
	return t
}

// SetTrans sets the [MeshBase.Trans]:
// set to true if color has transparency -- not worth checking manually
func (t *MeshBase) SetTrans(v bool) *MeshBase {
	t.Trans = v
	return t
}

// NodeBaseType is the [gti.Type] for [NodeBase]
var NodeBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.NodeBase",
	ShortName:  "gi3d.NodeBase",
	IDName:     "node-base",
	Doc:        "NodeBase is the basic 3D scenegraph node, which has the full transform information\nrelative to parent, and computed bounding boxes, etc.\nThere are only two different kinds of Nodes: Group and Solid",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pose", &gti.Field{Name: "Pose", Type: "goki.dev/gi3d.Pose", LocalType: "Pose", Doc: "complete specification of position and orientation", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Sc", &gti.Field{Name: "Sc", Type: "*goki.dev/gi3d.Scene", LocalType: "*Scene", Doc: "Sc is the cached Scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"PoseMu", &gti.Field{Name: "PoseMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex on pose access -- needed for parallel updating", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\"  set:\"-\""}},
		{"MeshBBox", &gti.Field{Name: "MeshBBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "mesh-based local bounding box (aggregated for groups)", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"WorldBBox", &gti.Field{Name: "WorldBBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "world coordinates bounding box", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"NDCBBox", &gti.Field{Name: "NDCBBox", Type: "goki.dev/mat32/v2.Box3", LocalType: "mat32.Box3", Doc: "normalized display coordinates bounding box, used for frustrum clipping", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "raw original bounding box for the widget within its parent Scene.\nThis is prior to intersecting with Frame bounds.", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ScBBox", &gti.Field{Name: "ScBBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "2D bounding box for region occupied within Scene Frame that we render onto.\nThis is BBox intersected with Frame bounds.", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &NodeBase{},
})

// NewNodeBase adds a new [NodeBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNodeBase(par ki.Ki, name ...string) *NodeBase {
	return par.NewChild(NodeBaseType, name...).(*NodeBase)
}

// KiType returns the [*gti.Type] of [NodeBase]
func (t *NodeBase) KiType() *gti.Type {
	return NodeBaseType
}

// New returns a new [*NodeBase] value
func (t *NodeBase) New() ki.Ki {
	return &NodeBase{}
}

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Scene",
	ShortName: "gi3d.Scene",
	IDName:    "scene",
	Doc:       "Scene is the overall scenegraph containing nodes as children.\nIt renders to its own vgpu.RenderFrame.\nThe Image of this Frame is usable directly or, via gi3v.Scene3D,\nwhere it is copied into an overall gi.Scene image.\n\nThere is default navigation event processing (disabled by setting NoNav)\nwhere mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)\nand arrow keys do Orbit, Pan, PanTarget with same key modifiers.\nSpacebar restores original \"default\" camera, and numbers save (1st time)\nor restore (subsequently) camera views (Control = always save)\n\nA Group at the top-level named \"TrackCamera\" will automatically track\nthe camera (i.e., its Pose is copied) -- Solids in that group can\nset their relative Pos etc to display relative to the camera, to achieve\n\"first person\" effects.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Geom", &gti.Field{Name: "Geom", Type: "goki.dev/mat32/v2.Geom2DInt", LocalType: "mat32.Geom2DInt", Doc: "Viewport-level viewbox within any parent Viewport2D", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"MultiSample", &gti.Field{Name: "MultiSample", Type: "int", LocalType: "int", Doc: "number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame", Directives: gti.Directives{}, Tag: "def:\"4\""}},
		{"Wireframe", &gti.Field{Name: "Wireframe", Type: "bool", LocalType: "bool", Doc: "render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)", Directives: gti.Directives{}, Tag: "def:\"false\""}},
		{"Camera", &gti.Field{Name: "Camera", Type: "goki.dev/gi3d.Camera", LocalType: "Camera", Doc: "camera determines view onto scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"BackgroundColor", &gti.Field{Name: "BackgroundColor", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "background color", Directives: gti.Directives{}, Tag: ""}},
		{"Lights", &gti.Field{Name: "Lights", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Light]", LocalType: "ordmap.Map[string, Light]", Doc: "all lights used in the scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Meshes", &gti.Field{Name: "Meshes", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Mesh]", LocalType: "ordmap.Map[string, Mesh]", Doc: "meshes -- holds all the mesh data -- must be configured prior to rendering", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Textures", &gti.Field{Name: "Textures", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Texture]", LocalType: "ordmap.Map[string, Texture]", Doc: "textures -- must be configured prior to rendering -- a maximum of 16 textures is supported for full cross-platform portability", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Library", &gti.Field{Name: "Library", Type: "map[string]*goki.dev/gi3d.Group", LocalType: "map[string]*Group", Doc: "library of objects that can be used in the scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"NoNav", &gti.Field{Name: "NoNav", Type: "bool", LocalType: "bool", Doc: "don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene", Directives: gti.Directives{}, Tag: ""}},
		{"SavedCams", &gti.Field{Name: "SavedCams", Type: "map[string]goki.dev/gi3d.Camera", LocalType: "map[string]Camera", Doc: "saved cameras -- can Save and Set these to view the scene from different angles", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SetDragCursor", &gti.Field{Name: "SetDragCursor", Type: "bool", LocalType: "bool", Doc: "has dragging cursor been set yet?", Directives: gti.Directives{}, Tag: "view:\"-\" set:\"-\""}},
		{"SelMode", &gti.Field{Name: "SelMode", Type: "goki.dev/gi3d.SelModes", LocalType: "SelModes", Doc: "how to deal with selection / manipulation events", Directives: gti.Directives{}, Tag: ""}},
		{"CurSel", &gti.Field{Name: "CurSel", Type: "goki.dev/gi3d.Node", LocalType: "Node", Doc: "currently selected node", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"CurManipPt", &gti.Field{Name: "CurManipPt", Type: "*goki.dev/gi3d.ManipPt", LocalType: "*ManipPt", Doc: "currently selected manipulation control point", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\" set:\"-\""}},
		{"SelParams", &gti.Field{Name: "SelParams", Type: "goki.dev/gi3d.SelParams", LocalType: "SelParams", Doc: "parameters for selection / manipulation box", Directives: gti.Directives{}, Tag: "view:\"inline\""}},
		{"Phong", &gti.Field{Name: "Phong", Type: "goki.dev/vgpu/v2/vphong.Phong", LocalType: "vphong.Phong", Doc: "the vphong rendering system", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Frame", &gti.Field{Name: "Frame", Type: "*goki.dev/vgpu/v2/vgpu.RenderFrame", LocalType: "*vgpu.RenderFrame", Doc: "the vgpu render frame holding the rendered scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"ImgCopy", &gti.Field{Name: "ImgCopy", Type: "image.RGBA", LocalType: "image.RGBA", Doc: "image used to hold a copy of the Frame image, for ImageCopy() call.\nThis is re-used across calls to avoid large memory allocations,\nso it will automatically update after every ImageCopy call.\nIf a persistent image is required, call [glop/images.CloneAsRGBA].", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"DirUpIdx", &gti.Field{Name: "DirUpIdx", Type: "int", LocalType: "int", Doc: "index in list of window direct uploading images", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"RenderMu", &gti.Field{Name: "RenderMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex on rendering", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Scene{},
})

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type {
	return SceneType
}

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki {
	return &Scene{}
}

// SetMultiSample sets the [Scene.MultiSample]:
// number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame
func (t *Scene) SetMultiSample(v int) *Scene {
	t.MultiSample = v
	return t
}

// SetWireframe sets the [Scene.Wireframe]:
// render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)
func (t *Scene) SetWireframe(v bool) *Scene {
	t.Wireframe = v
	return t
}

// SetBackgroundColor sets the [Scene.BackgroundColor]:
// background color
func (t *Scene) SetBackgroundColor(v color.RGBA) *Scene {
	t.BackgroundColor = v
	return t
}

// SetNoNav sets the [Scene.NoNav]:
// don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene
func (t *Scene) SetNoNav(v bool) *Scene {
	t.NoNav = v
	return t
}

// SetSelMode sets the [Scene.SelMode]:
// how to deal with selection / manipulation events
func (t *Scene) SetSelMode(v SelModes) *Scene {
	t.SelMode = v
	return t
}

// SetSelParams sets the [Scene.SelParams]:
// parameters for selection / manipulation box
func (t *Scene) SetSelParams(v SelParams) *Scene {
	t.SelParams = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Plane",
	ShortName: "gi3d.Plane",
	IDName:    "plane",
	Doc:       "Plane is a flat 2D plane, which can be oriented along any\naxis facing either positive or negative",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NormAxis", &gti.Field{Name: "NormAxis", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.", Directives: gti.Directives{}, Tag: ""}},
		{"NormNeg", &gti.Field{Name: "NormNeg", Type: "bool", LocalType: "bool", Doc: "if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true", Directives: gti.Directives{}, Tag: ""}},
		{"Size", &gti.Field{Name: "Size", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "2D size of plane", Directives: gti.Directives{}, Tag: ""}},
		{"Segs", &gti.Field{Name: "Segs", Type: "goki.dev/mat32/v2.Vec2i", LocalType: "mat32.Vec2i", Doc: "number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}, Tag: ""}},
		{"Offset", &gti.Field{Name: "Offset", Type: "float32", LocalType: "float32", Doc: "offset from origin along direction of normal to the plane", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetNormAxis sets the [Plane.NormAxis]:
// axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.
func (t *Plane) SetNormAxis(v mat32.Dims) *Plane {
	t.NormAxis = v
	return t
}

// SetNormNeg sets the [Plane.NormNeg]:
// if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true
func (t *Plane) SetNormNeg(v bool) *Plane {
	t.NormNeg = v
	return t
}

// SetSize sets the [Plane.Size]:
// 2D size of plane
func (t *Plane) SetSize(v mat32.Vec2) *Plane {
	t.Size = v
	return t
}

// SetSegs sets the [Plane.Segs]:
// number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Plane) SetSegs(v mat32.Vec2i) *Plane {
	t.Segs = v
	return t
}

// SetOffset sets the [Plane.Offset]:
// offset from origin along direction of normal to the plane
func (t *Plane) SetOffset(v float32) *Plane {
	t.Offset = v
	return t
}

// SetColor sets the [Plane.Color]
func (t *Plane) SetColor(v bool) *Plane {
	t.Color = v
	return t
}

// SetDynamic sets the [Plane.Dynamic]
func (t *Plane) SetDynamic(v bool) *Plane {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Plane.Trans]
func (t *Plane) SetTrans(v bool) *Plane {
	t.Trans = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Box",
	ShortName: "gi3d.Box",
	IDName:    "box",
	Doc:       "Box is a rectangular-shaped solid (cuboid)",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "goki.dev/mat32/v2.Vec3", LocalType: "mat32.Vec3", Doc: "size along each dimension", Directives: gti.Directives{}, Tag: ""}},
		{"Segs", &gti.Field{Name: "Segs", Type: "goki.dev/mat32/v2.Vec3i", LocalType: "mat32.Vec3i", Doc: "number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetSize sets the [Box.Size]:
// size along each dimension
func (t *Box) SetSize(v mat32.Vec3) *Box {
	t.Size = v
	return t
}

// SetSegs sets the [Box.Segs]:
// number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Box) SetSegs(v mat32.Vec3i) *Box {
	t.Segs = v
	return t
}

// SetColor sets the [Box.Color]
func (t *Box) SetColor(v bool) *Box {
	t.Color = v
	return t
}

// SetDynamic sets the [Box.Dynamic]
func (t *Box) SetDynamic(v bool) *Box {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Box.Trans]
func (t *Box) SetTrans(v bool) *Box {
	t.Trans = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Sphere",
	ShortName: "gi3d.Sphere",
	IDName:    "sphere",
	Doc:       "Sphere is a sphere mesh",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", LocalType: "float32", Doc: "radius of the sphere", Directives: gti.Directives{}, Tag: ""}},
		{"WidthSegs", &gti.Field{Name: "WidthSegs", Type: "int", LocalType: "int", Doc: "number of segments around the width of the sphere (32 is reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"3\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments (32 is reasonable default for full height)", Directives: gti.Directives{}, Tag: "min:\"3\""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting radial angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"ElevStart", &gti.Field{Name: "ElevStart", Type: "float32", LocalType: "float32", Doc: "starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"180\" step:\"5\""}},
		{"ElevLen", &gti.Field{Name: "ElevLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max = 180)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"180\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetRadius sets the [Sphere.Radius]:
// radius of the sphere
func (t *Sphere) SetRadius(v float32) *Sphere {
	t.Radius = v
	return t
}

// SetWidthSegs sets the [Sphere.WidthSegs]:
// number of segments around the width of the sphere (32 is reasonable default for full circle)
func (t *Sphere) SetWidthSegs(v int) *Sphere {
	t.WidthSegs = v
	return t
}

// SetHeightSegs sets the [Sphere.HeightSegs]:
// number of height segments (32 is reasonable default for full height)
func (t *Sphere) SetHeightSegs(v int) *Sphere {
	t.HeightSegs = v
	return t
}

// SetAngStart sets the [Sphere.AngStart]:
// starting radial angle in degrees, relative to -1,0,0 left side starting point
func (t *Sphere) SetAngStart(v float32) *Sphere {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Sphere.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Sphere) SetAngLen(v float32) *Sphere {
	t.AngLen = v
	return t
}

// SetElevStart sets the [Sphere.ElevStart]:
// starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom
func (t *Sphere) SetElevStart(v float32) *Sphere {
	t.ElevStart = v
	return t
}

// SetElevLen sets the [Sphere.ElevLen]:
// total angle to generate in degrees (max = 180)
func (t *Sphere) SetElevLen(v float32) *Sphere {
	t.ElevLen = v
	return t
}

// SetColor sets the [Sphere.Color]
func (t *Sphere) SetColor(v bool) *Sphere {
	t.Color = v
	return t
}

// SetDynamic sets the [Sphere.Dynamic]
func (t *Sphere) SetDynamic(v bool) *Sphere {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Sphere.Trans]
func (t *Sphere) SetTrans(v bool) *Sphere {
	t.Trans = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Cylinder",
	ShortName: "gi3d.Cylinder",
	IDName:    "cylinder",
	Doc:       "Cylinder is a generalized cylinder shape, including a cone\nor truncated cone by having different size circles at either end.\nHeight is up along the Y axis.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder", Directives: gti.Directives{}, Tag: ""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}, Tag: ""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments", Directives: gti.Directives{}, Tag: ""}},
		{"Top", &gti.Field{Name: "Top", Type: "bool", LocalType: "bool", Doc: "render the top disc", Directives: gti.Directives{}, Tag: ""}},
		{"Bottom", &gti.Field{Name: "Bottom", Type: "bool", LocalType: "bool", Doc: "render the bottom disc", Directives: gti.Directives{}, Tag: ""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetHeight sets the [Cylinder.Height]:
// height of the cylinder
func (t *Cylinder) SetHeight(v float32) *Cylinder {
	t.Height = v
	return t
}

// SetTopRad sets the [Cylinder.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Cylinder) SetTopRad(v float32) *Cylinder {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Cylinder.BotRad]:
// radius of the bottom
func (t *Cylinder) SetBotRad(v float32) *Cylinder {
	t.BotRad = v
	return t
}

// SetRadialSegs sets the [Cylinder.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Cylinder) SetRadialSegs(v int) *Cylinder {
	t.RadialSegs = v
	return t
}

// SetHeightSegs sets the [Cylinder.HeightSegs]:
// number of height segments
func (t *Cylinder) SetHeightSegs(v int) *Cylinder {
	t.HeightSegs = v
	return t
}

// SetTop sets the [Cylinder.Top]:
// render the top disc
func (t *Cylinder) SetTop(v bool) *Cylinder {
	t.Top = v
	return t
}

// SetBottom sets the [Cylinder.Bottom]:
// render the bottom disc
func (t *Cylinder) SetBottom(v bool) *Cylinder {
	t.Bottom = v
	return t
}

// SetAngStart sets the [Cylinder.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Cylinder) SetAngStart(v float32) *Cylinder {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Cylinder.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Cylinder) SetAngLen(v float32) *Cylinder {
	t.AngLen = v
	return t
}

// SetColor sets the [Cylinder.Color]
func (t *Cylinder) SetColor(v bool) *Cylinder {
	t.Color = v
	return t
}

// SetDynamic sets the [Cylinder.Dynamic]
func (t *Cylinder) SetDynamic(v bool) *Cylinder {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Cylinder.Trans]
func (t *Cylinder) SetTrans(v bool) *Cylinder {
	t.Trans = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Capsule",
	ShortName: "gi3d.Capsule",
	IDName:    "capsule",
	Doc:       "Capsule is a generalized capsule shape: a cylinder with hemisphere end caps.\nSupports different radii on each end.\nHeight is along the Y axis -- total height is Height + TopRad + BotRad.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder portion", Directives: gti.Directives{}, Tag: ""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}, Tag: ""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments", Directives: gti.Directives{}, Tag: ""}},
		{"CapSegs", &gti.Field{Name: "CapSegs", Type: "int", LocalType: "int", Doc: "number of segments in the hemisphere cap ends (16 is a reasonable default)", Directives: gti.Directives{}, Tag: ""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetHeight sets the [Capsule.Height]:
// height of the cylinder portion
func (t *Capsule) SetHeight(v float32) *Capsule {
	t.Height = v
	return t
}

// SetTopRad sets the [Capsule.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Capsule) SetTopRad(v float32) *Capsule {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Capsule.BotRad]:
// radius of the bottom
func (t *Capsule) SetBotRad(v float32) *Capsule {
	t.BotRad = v
	return t
}

// SetRadialSegs sets the [Capsule.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Capsule) SetRadialSegs(v int) *Capsule {
	t.RadialSegs = v
	return t
}

// SetHeightSegs sets the [Capsule.HeightSegs]:
// number of height segments
func (t *Capsule) SetHeightSegs(v int) *Capsule {
	t.HeightSegs = v
	return t
}

// SetCapSegs sets the [Capsule.CapSegs]:
// number of segments in the hemisphere cap ends (16 is a reasonable default)
func (t *Capsule) SetCapSegs(v int) *Capsule {
	t.CapSegs = v
	return t
}

// SetAngStart sets the [Capsule.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Capsule) SetAngStart(v float32) *Capsule {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Capsule.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Capsule) SetAngLen(v float32) *Capsule {
	t.AngLen = v
	return t
}

// SetColor sets the [Capsule.Color]
func (t *Capsule) SetColor(v bool) *Capsule {
	t.Color = v
	return t
}

// SetDynamic sets the [Capsule.Dynamic]
func (t *Capsule) SetDynamic(v bool) *Capsule {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Capsule.Trans]
func (t *Capsule) SetTrans(v bool) *Capsule {
	t.Trans = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Torus",
	ShortName: "gi3d.Torus",
	IDName:    "torus",
	Doc:       "Torus is a torus mesh, defined by the radius of the solid tube and the\nlarger radius of the ring.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", LocalType: "float32", Doc: "larger radius of the torus ring", Directives: gti.Directives{}, Tag: ""}},
		{"TubeRadius", &gti.Field{Name: "TubeRadius", Type: "float32", LocalType: "float32", Doc: "radius of the solid tube", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of segments around the radius of the torus (32 is reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"TubeSegs", &gti.Field{Name: "TubeSegs", Type: "int", LocalType: "int", Doc: "number of segments for the tube itself (32 is reasonable default for full height)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting radial angle in degrees relative to 1,0,0 starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetRadius sets the [Torus.Radius]:
// larger radius of the torus ring
func (t *Torus) SetRadius(v float32) *Torus {
	t.Radius = v
	return t
}

// SetTubeRadius sets the [Torus.TubeRadius]:
// radius of the solid tube
func (t *Torus) SetTubeRadius(v float32) *Torus {
	t.TubeRadius = v
	return t
}

// SetRadialSegs sets the [Torus.RadialSegs]:
// number of segments around the radius of the torus (32 is reasonable default for full circle)
func (t *Torus) SetRadialSegs(v int) *Torus {
	t.RadialSegs = v
	return t
}

// SetTubeSegs sets the [Torus.TubeSegs]:
// number of segments for the tube itself (32 is reasonable default for full height)
func (t *Torus) SetTubeSegs(v int) *Torus {
	t.TubeSegs = v
	return t
}

// SetAngStart sets the [Torus.AngStart]:
// starting radial angle in degrees relative to 1,0,0 starting point
func (t *Torus) SetAngStart(v float32) *Torus {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Torus.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Torus) SetAngLen(v float32) *Torus {
	t.AngLen = v
	return t
}

// SetColor sets the [Torus.Color]
func (t *Torus) SetColor(v bool) *Torus {
	t.Color = v
	return t
}

// SetDynamic sets the [Torus.Dynamic]
func (t *Torus) SetDynamic(v bool) *Torus {
	t.Dynamic = v
	return t
}

// SetTrans sets the [Torus.Trans]
func (t *Torus) SetTrans(v bool) *Torus {
	t.Trans = v
	return t
}

// SolidType is the [gti.Type] for [Solid]
var SolidType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Solid",
	ShortName: "gi3d.Solid",
	IDName:    "solid",
	Doc:       "Solid represents an individual 3D solid element.\nIt has its own unique spatial transforms and material properties,\nand points to a mesh structure defining the shape of the solid.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Mesh", &gti.Field{Name: "Mesh", Type: "goki.dev/gi3d.MeshName", LocalType: "MeshName", Doc: "name of the mesh shape information used for rendering this solid -- all meshes are collected on the Scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Mat", &gti.Field{Name: "Mat", Type: "goki.dev/gi3d.Material", LocalType: "Material", Doc: "material properties of the surface (color, shininess, texture, etc)", Directives: gti.Directives{}, Tag: "view:\"add-fields\""}},
		{"MeshPtr", &gti.Field{Name: "MeshPtr", Type: "goki.dev/gi3d.Mesh", LocalType: "Mesh", Doc: "cached pointer to mesh", Directives: gti.Directives{}, Tag: "view:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "goki.dev/gi3d.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Solid{},
})

// KiType returns the [*gti.Type] of [Solid]
func (t *Solid) KiType() *gti.Type {
	return SolidType
}

// New returns a new [*Solid] value
func (t *Solid) New() ki.Ki {
	return &Solid{}
}

// SetMat sets the [Solid.Mat]:
// material properties of the surface (color, shininess, texture, etc)
func (t *Solid) SetMat(v Material) *Solid {
	t.Mat = v
	return t
}

// Text2DType is the [gti.Type] for [Text2D]
var Text2DType = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Text2D",
	ShortName: "gi3d.Text2D",
	IDName:    "text-2-d",
	Doc:       "Text2D presents 2D rendered text on a vertically-oriented plane, using a texture.\nCall SetText() which calls RenderText to update fortext changes (re-renders texture).\nThe native scale is such that a unit height value is the height of the default font\nset by the font-size property, and the X axis is scaled proportionally based on the\nrendered text size to maintain the aspect ratio.  Further scaling can be applied on\ntop of that by setting the Pose.Scale values as usual.\nStandard styling properties can be set on the node to set font size, family,\nand text alignment relative to the Pose.Pos position (e.g., Left, Top puts the\nupper-left corner of text at Pos).\nNote that higher quality is achieved by using a larger font size (36 default).\nThe margin property creates blank margin of the background color around the text\n(2 px default) and the background-color defaults to transparent\nbut can be set to any color.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", LocalType: "string", Doc: "the text string to display", Directives: gti.Directives{}, Tag: ""}},
		{"Styles", &gti.Field{Name: "Styles", Type: "goki.dev/girl/styles.Style", LocalType: "styles.Style", Doc: "styling settings for the text", Directives: gti.Directives{}, Tag: "set:\"-\" json:\"-\" xml:\"-\""}},
		{"TxtPos", &gti.Field{Name: "TxtPos", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "position offset of start of text rendering relative to upper-left corner", Directives: gti.Directives{}, Tag: "set:\"-\" xml:\"-\" json:\"-\""}},
		{"TxtRender", &gti.Field{Name: "TxtRender", Type: "goki.dev/girl/paint.Text", LocalType: "paint.Text", Doc: "render data for text label", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\" xml:\"-\" json:\"-\""}},
		{"RenderState", &gti.Field{Name: "RenderState", Type: "goki.dev/girl/paint.State", LocalType: "paint.State", Doc: "render state for rendering text", Directives: gti.Directives{}, Tag: "set:\"-\" copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/gi3d.Solid", LocalType: "Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Text2D{},
})

// KiType returns the [*gti.Type] of [Text2D]
func (t *Text2D) KiType() *gti.Type {
	return Text2DType
}

// New returns a new [*Text2D] value
func (t *Text2D) New() ki.Ki {
	return &Text2D{}
}

// SetText sets the [Text2D.Text]:
// the text string to display
func (t *Text2D) SetText(v string) *Text2D {
	t.Text = v
	return t
}

// SetMat sets the [Text2D.Mat]
func (t *Text2D) SetMat(v Material) *Text2D {
	t.Mat = v
	return t
}
