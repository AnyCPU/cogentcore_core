// Code generated by "goki generate"; DO NOT EDIT.

package gi3d

import (
	"image/color"
	"sync"

	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
	"goki.dev/vgpu/v2/vgpu"
	"goki.dev/vgpu/v2/vphong"
)

// GroupType is the [gti.Type] for [Group]
var GroupType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.Group",
	ShortName:  "gi3d.Group",
	IDName:     "group",
	Doc:        "Group collects individual elements in a scene but does not have a Mesh or Material of\nits own.  It does have a transform that applies to all nodes under it.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "goki.dev/gi3d.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Group{},
})

// NewGroup adds a new [Group] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewGroup(par ki.Ki, name ...string) *Group {
	return par.NewChild(GroupType, name...).(*Group)
}

// KiType returns the [*gti.Type] of [Group]
func (t *Group) KiType() *gti.Type {
	return GroupType
}

// New returns a new [*Group] value
func (t *Group) New() ki.Ki {
	return &Group{}
}

// ManipPtType is the [gti.Type] for [ManipPt]
var ManipPtType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.ManipPt",
	ShortName:  "gi3d.ManipPt",
	IDName:     "manip-pt",
	Doc:        "ManipPt is a manipulation control point",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/gi3d.Solid", LocalType: "Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ManipPt{},
})

// NewManipPt adds a new [ManipPt] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewManipPt(par ki.Ki, name ...string) *ManipPt {
	return par.NewChild(ManipPtType, name...).(*ManipPt)
}

// KiType returns the [*gti.Type] of [ManipPt]
func (t *ManipPt) KiType() *gti.Type {
	return ManipPtType
}

// New returns a new [*ManipPt] value
func (t *ManipPt) New() ki.Ki {
	return &ManipPt{}
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.MeshBase",
	ShortName: "gi3d.MeshBase",
	IDName:    "mesh-base",
	Doc:       "MeshBase provides the core implementation of Mesh interface",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Nm", &gti.Field{Name: "Nm", Type: "string", LocalType: "string", Doc: "name of mesh -- meshes are linked to Solids by name so this matters", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"NVtx", &gti.Field{Name: "NVtx", Type: "int", LocalType: "int", Doc: "number of vertex points, as mat32.Vec3 -- always includes mat32.Vec3 normals and mat32.Vec2 texture coordinates -- only valid after Sizes() has been called", Directives: gti.Directives{}, Tag: ""}},
		{"NIdx", &gti.Field{Name: "NIdx", Type: "int", LocalType: "int", Doc: "number of indexes, as mat32.ArrayU32 -- only valid after Sizes() has been called", Directives: gti.Directives{}, Tag: ""}},
		{"Color", &gti.Field{Name: "Color", Type: "bool", LocalType: "bool", Doc: "has per-vertex colors, as mat32.Vec4 per vertex", Directives: gti.Directives{}, Tag: ""}},
		{"Dynamic", &gti.Field{Name: "Dynamic", Type: "bool", LocalType: "bool", Doc: "if true, this mesh changes frequently -- otherwise considered to be static", Directives: gti.Directives{}, Tag: ""}},
		{"Trans", &gti.Field{Name: "Trans", Type: "bool", LocalType: "bool", Doc: "set to true if color has transparency -- not worth checking manually", Directives: gti.Directives{}, Tag: ""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "computed bounding-box and other gross solid properties", Directives: gti.Directives{}, Tag: ""}},
		{"BBoxMu", &gti.Field{Name: "BBoxMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex on bbox access", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetNVtx sets the [MeshBase.NVtx]:
// number of vertex points, as mat32.Vec3 -- always includes mat32.Vec3 normals and mat32.Vec2 texture coordinates -- only valid after Sizes() has been called
func (t *MeshBase) SetNVtx(v int) *MeshBase {
	t.NVtx = v
	return t
}

// SetNIdx sets the [MeshBase.NIdx]:
// number of indexes, as mat32.ArrayU32 -- only valid after Sizes() has been called
func (t *MeshBase) SetNIdx(v int) *MeshBase {
	t.NIdx = v
	return t
}

// SetColor sets the [MeshBase.Color]:
// has per-vertex colors, as mat32.Vec4 per vertex
func (t *MeshBase) SetColor(v bool) *MeshBase {
	t.Color = v
	return t
}

// SetDynamic sets the [MeshBase.Dynamic]:
// if true, this mesh changes frequently -- otherwise considered to be static
func (t *MeshBase) SetDynamic(v bool) *MeshBase {
	t.Dynamic = v
	return t
}

// SetTrans sets the [MeshBase.Trans]:
// set to true if color has transparency -- not worth checking manually
func (t *MeshBase) SetTrans(v bool) *MeshBase {
	t.Trans = v
	return t
}

// SetBBox sets the [MeshBase.BBox]:
// computed bounding-box and other gross solid properties
func (t *MeshBase) SetBBox(v BBox) *MeshBase {
	t.BBox = v
	return t
}

// SetBBoxMu sets the [MeshBase.BBoxMu]:
// mutex on bbox access
func (t *MeshBase) SetBBoxMu(v sync.RWMutex) *MeshBase {
	t.BBoxMu = v
	return t
}

// NodeBaseType is the [gti.Type] for [NodeBase]
var NodeBaseType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.NodeBase",
	ShortName:  "gi3d.NodeBase",
	IDName:     "node-base",
	Doc:        "NodeBase is the basic 3D scenegraph node, which has the full transform information\nrelative to parent, and computed bounding boxes, etc.\nThere are only two different kinds of Nodes: Group and Solid",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Pose", &gti.Field{Name: "Pose", Type: "goki.dev/gi3d.Pose", LocalType: "Pose", Doc: "complete specification of position and orientation", Directives: gti.Directives{}, Tag: ""}},
		{"PoseMu", &gti.Field{Name: "PoseMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex on pose access -- needed for parallel updating", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
		{"MeshBBox", &gti.Field{Name: "MeshBBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "mesh-based local bounding box (aggregated for groups)", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"WorldBBox", &gti.Field{Name: "WorldBBox", Type: "goki.dev/gi3d.BBox", LocalType: "BBox", Doc: "world coordinates bounding box", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"NDCBBox", &gti.Field{Name: "NDCBBox", Type: "goki.dev/mat32/v2.Box3", LocalType: "mat32.Box3", Doc: "normalized display coordinates bounding box, used for frustrum clipping", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "raw original bounding box for the widget within its parent Scene -- used for computing ScBBox.  This is not updated by LayoutScroll, whereas ScBBox is", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ObjBBox", &gti.Field{Name: "ObjBBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "full object bbox -- this is BBox + LayoutScroll delta, but NOT intersected with parent's parBBox -- used for computing color gradients or other object-specific geometry computations", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
		{"ScBBox", &gti.Field{Name: "ScBBox", Type: "image.Rectangle", LocalType: "image.Rectangle", Doc: "2D bounding box for region occupied within immediate parent Scene object that we render onto. These are the pixels we draw into, filtered through parent bounding boxes. Used for render Bounds clipping", Directives: gti.Directives{}, Tag: "readonly:\"-\" copy:\"-\" json:\"-\" xml:\"-\" set:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &NodeBase{},
})

// NewNodeBase adds a new [NodeBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNodeBase(par ki.Ki, name ...string) *NodeBase {
	return par.NewChild(NodeBaseType, name...).(*NodeBase)
}

// KiType returns the [*gti.Type] of [NodeBase]
func (t *NodeBase) KiType() *gti.Type {
	return NodeBaseType
}

// New returns a new [*NodeBase] value
func (t *NodeBase) New() ki.Ki {
	return &NodeBase{}
}

// SetPose sets the [NodeBase.Pose]:
// complete specification of position and orientation
func (t *NodeBase) SetPose(v Pose) *NodeBase {
	t.Pose = v
	return t
}

// SetPoseMu sets the [NodeBase.PoseMu]:
// mutex on pose access -- needed for parallel updating
func (t *NodeBase) SetPoseMu(v sync.RWMutex) *NodeBase {
	t.PoseMu = v
	return t
}

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.Scene",
	ShortName:  "gi3d.Scene",
	IDName:     "scene",
	Doc:        "Scene is the overall scenegraph containing nodes as children.\nIt renders to its own vgpu.RenderFrame, the Image of which is then copied\ninto the window vgpu.Drawer images for subsequent compositing into the\nwindow directly, as a DurectWinUpload element.\n\nThere is default navigation event processing (disabled by setting NoNav)\nwhere mouse drag events Orbit the camera (Shift = Pan, Alt = PanTarget)\nand arrow keys do Orbit, Pan, PanTarget with same key modifiers.\nSpacebar restores original \"default\" camera, and numbers save (1st time)\nor restore (subsequently) camera views (Control = always save)\n\nA Group at the top-level named \"TrackCamera\" will automatically track\nthe camera (i.e., its Pose is copied) -- Solids in that group can\nset their relative Pos etc to display relative to the camera, to achieve\n\"first person\" effects.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Geom", &gti.Field{Name: "Geom", Type: "goki.dev/mat32/v2.Geom2DInt", LocalType: "mat32.Geom2DInt", Doc: "Viewport-level viewbox within any parent Viewport2D", Directives: gti.Directives{}, Tag: ""}},
		{"MultiSample", &gti.Field{Name: "MultiSample", Type: "int", LocalType: "int", Doc: "number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame", Directives: gti.Directives{}, Tag: "def:\"4\""}},
		{"Wireframe", &gti.Field{Name: "Wireframe", Type: "bool", LocalType: "bool", Doc: "render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)", Directives: gti.Directives{}, Tag: "def:\"false\""}},
		{"Camera", &gti.Field{Name: "Camera", Type: "goki.dev/gi3d.Camera", LocalType: "Camera", Doc: "camera determines view onto scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"BackgroundColor", &gti.Field{Name: "BackgroundColor", Type: "image/color.RGBA", LocalType: "color.RGBA", Doc: "background color", Directives: gti.Directives{}, Tag: ""}},
		{"Lights", &gti.Field{Name: "Lights", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Light]", LocalType: "ordmap.Map[string, Light]", Doc: "all lights used in the scene", Directives: gti.Directives{}, Tag: ""}},
		{"Meshes", &gti.Field{Name: "Meshes", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Mesh]", LocalType: "ordmap.Map[string, Mesh]", Doc: "meshes -- holds all the mesh data -- must be configured prior to rendering", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Textures", &gti.Field{Name: "Textures", Type: "goki.dev/ordmap.Map[string, goki.dev/gi3d.Texture]", LocalType: "ordmap.Map[string, Texture]", Doc: "textures -- must be configured prior to rendering -- a maximum of 16 textures is supported for full cross-platform portability", Directives: gti.Directives{}, Tag: ""}},
		{"Library", &gti.Field{Name: "Library", Type: "map[string]*goki.dev/gi3d.Group", LocalType: "map[string]*Group", Doc: "library of objects that can be used in the scene", Directives: gti.Directives{}, Tag: ""}},
		{"NoNav", &gti.Field{Name: "NoNav", Type: "bool", LocalType: "bool", Doc: "don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene", Directives: gti.Directives{}, Tag: ""}},
		{"SavedCams", &gti.Field{Name: "SavedCams", Type: "map[string]goki.dev/gi3d.Camera", LocalType: "map[string]Camera", Doc: "saved cameras -- can Save and Set these to view the scene from different angles", Directives: gti.Directives{}, Tag: ""}},
		{"SetDragCursor", &gti.Field{Name: "SetDragCursor", Type: "bool", LocalType: "bool", Doc: "has dragging cursor been set yet?", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"SelMode", &gti.Field{Name: "SelMode", Type: "goki.dev/gi3d.SelModes", LocalType: "SelModes", Doc: "how to deal with selection / manipulation events", Directives: gti.Directives{}, Tag: ""}},
		{"CurSel", &gti.Field{Name: "CurSel", Type: "goki.dev/gi3d.Node", LocalType: "Node", Doc: "currently selected node", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
		{"CurManipPt", &gti.Field{Name: "CurManipPt", Type: "*goki.dev/gi3d.ManipPt", LocalType: "*ManipPt", Doc: "currently selected manipulation control point", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
		{"SelParams", &gti.Field{Name: "SelParams", Type: "goki.dev/gi3d.SelParams", LocalType: "SelParams", Doc: "parameters for selection / manipulation box", Directives: gti.Directives{}, Tag: "view:\"inline\""}},
		{"Phong", &gti.Field{Name: "Phong", Type: "goki.dev/vgpu/v2/vphong.Phong", LocalType: "vphong.Phong", Doc: "the vphong rendering system", Directives: gti.Directives{}, Tag: ""}},
		{"Frame", &gti.Field{Name: "Frame", Type: "*goki.dev/vgpu/v2/vgpu.RenderFrame", LocalType: "*vgpu.RenderFrame", Doc: "the vgpu render frame holding the rendered scene", Directives: gti.Directives{}, Tag: ""}},
		{"DirUpIdx", &gti.Field{Name: "DirUpIdx", Type: "int", LocalType: "int", Doc: "index in list of window direct uploading images", Directives: gti.Directives{}, Tag: ""}},
		{"RenderMu", &gti.Field{Name: "RenderMu", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex on rendering", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/gi/v2/gi.WidgetBase", LocalType: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Scene{},
})

// NewScene adds a new [Scene] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewScene(par ki.Ki, name ...string) *Scene {
	return par.NewChild(SceneType, name...).(*Scene)
}

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type {
	return SceneType
}

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki {
	return &Scene{}
}

// SetGeom sets the [Scene.Geom]:
// Viewport-level viewbox within any parent Viewport2D
func (t *Scene) SetGeom(v mat32.Geom2DInt) *Scene {
	t.Geom = v
	return t
}

// SetMultiSample sets the [Scene.MultiSample]:
// number of samples in multisampling -- must be a power of 2, and must be 1 if grabbing the Depth buffer back from the RenderFrame
func (t *Scene) SetMultiSample(v int) *Scene {
	t.MultiSample = v
	return t
}

// SetWireframe sets the [Scene.Wireframe]:
// render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system (i.e., just after Scene is made)
func (t *Scene) SetWireframe(v bool) *Scene {
	t.Wireframe = v
	return t
}

// SetBackgroundColor sets the [Scene.BackgroundColor]:
// background color
func (t *Scene) SetBackgroundColor(v color.RGBA) *Scene {
	t.BackgroundColor = v
	return t
}

// SetLights sets the [Scene.Lights]:
// all lights used in the scene
func (t *Scene) SetLights(v ordmap.Map[string, Light]) *Scene {
	t.Lights = v
	return t
}

// SetTextures sets the [Scene.Textures]:
// textures -- must be configured prior to rendering -- a maximum of 16 textures is supported for full cross-platform portability
func (t *Scene) SetTextures(v ordmap.Map[string, Texture]) *Scene {
	t.Textures = v
	return t
}

// SetLibrary sets the [Scene.Library]:
// library of objects that can be used in the scene
func (t *Scene) SetLibrary(v map[string]*Group) *Scene {
	t.Library = v
	return t
}

// SetNoNav sets the [Scene.NoNav]:
// don't activate the standard navigation keyboard and mouse event processing to move around the camera in the scene
func (t *Scene) SetNoNav(v bool) *Scene {
	t.NoNav = v
	return t
}

// SetSavedCams sets the [Scene.SavedCams]:
// saved cameras -- can Save and Set these to view the scene from different angles
func (t *Scene) SetSavedCams(v map[string]Camera) *Scene {
	t.SavedCams = v
	return t
}

// SetSetDragCursor sets the [Scene.SetDragCursor]:
// has dragging cursor been set yet?
func (t *Scene) SetSetDragCursor(v bool) *Scene {
	t.SetDragCursor = v
	return t
}

// SetSelMode sets the [Scene.SelMode]:
// how to deal with selection / manipulation events
func (t *Scene) SetSelMode(v SelModes) *Scene {
	t.SelMode = v
	return t
}

// SetCurSel sets the [Scene.CurSel]:
// currently selected node
func (t *Scene) SetCurSel(v Node) *Scene {
	t.CurSel = v
	return t
}

// SetCurManipPt sets the [Scene.CurManipPt]:
// currently selected manipulation control point
func (t *Scene) SetCurManipPt(v *ManipPt) *Scene {
	t.CurManipPt = v
	return t
}

// SetSelParams sets the [Scene.SelParams]:
// parameters for selection / manipulation box
func (t *Scene) SetSelParams(v SelParams) *Scene {
	t.SelParams = v
	return t
}

// SetPhong sets the [Scene.Phong]:
// the vphong rendering system
func (t *Scene) SetPhong(v vphong.Phong) *Scene {
	t.Phong = v
	return t
}

// SetFrame sets the [Scene.Frame]:
// the vgpu render frame holding the rendered scene
func (t *Scene) SetFrame(v *vgpu.RenderFrame) *Scene {
	t.Frame = v
	return t
}

// SetDirUpIdx sets the [Scene.DirUpIdx]:
// index in list of window direct uploading images
func (t *Scene) SetDirUpIdx(v int) *Scene {
	t.DirUpIdx = v
	return t
}

// SetRenderMu sets the [Scene.RenderMu]:
// mutex on rendering
func (t *Scene) SetRenderMu(v sync.Mutex) *Scene {
	t.RenderMu = v
	return t
}

// SceneViewType is the [gti.Type] for [SceneView]
var SceneViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.SceneView",
	ShortName:  "gi3d.SceneView",
	IDName:     "scene-view",
	Doc:        "SceneView provides a toolbar controller for a gi3d.Scene",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SceneView{},
})

// NewSceneView adds a new [SceneView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSceneView(par ki.Ki, name ...string) *SceneView {
	return par.NewChild(SceneViewType, name...).(*SceneView)
}

// KiType returns the [*gti.Type] of [SceneView]
func (t *SceneView) KiType() *gti.Type {
	return SceneViewType
}

// New returns a new [*SceneView] value
func (t *SceneView) New() ki.Ki {
	return &SceneView{}
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Plane",
	ShortName: "gi3d.Plane",
	IDName:    "plane",
	Doc:       "Plane is a flat 2D plane, which can be oriented along any\naxis facing either positive or negative",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NormAxis", &gti.Field{Name: "NormAxis", Type: "goki.dev/mat32/v2.Dims", LocalType: "mat32.Dims", Doc: "axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.", Directives: gti.Directives{}, Tag: ""}},
		{"NormNeg", &gti.Field{Name: "NormNeg", Type: "bool", LocalType: "bool", Doc: "if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true", Directives: gti.Directives{}, Tag: ""}},
		{"Size", &gti.Field{Name: "Size", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "2D size of plane", Directives: gti.Directives{}, Tag: ""}},
		{"Segs", &gti.Field{Name: "Segs", Type: "goki.dev/mat32/v2.Vec2i", LocalType: "mat32.Vec2i", Doc: "number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}, Tag: ""}},
		{"Offset", &gti.Field{Name: "Offset", Type: "float32", LocalType: "float32", Doc: "offset from origin along direction of normal to the plane", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetNormAxis sets the [Plane.NormAxis]:
// axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.
func (t *Plane) SetNormAxis(v mat32.Dims) *Plane {
	t.NormAxis = v
	return t
}

// SetNormNeg sets the [Plane.NormNeg]:
// if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true
func (t *Plane) SetNormNeg(v bool) *Plane {
	t.NormNeg = v
	return t
}

// SetSize sets the [Plane.Size]:
// 2D size of plane
func (t *Plane) SetSize(v mat32.Vec2) *Plane {
	t.Size = v
	return t
}

// SetSegs sets the [Plane.Segs]:
// number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Plane) SetSegs(v mat32.Vec2i) *Plane {
	t.Segs = v
	return t
}

// SetOffset sets the [Plane.Offset]:
// offset from origin along direction of normal to the plane
func (t *Plane) SetOffset(v float32) *Plane {
	t.Offset = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Box",
	ShortName: "gi3d.Box",
	IDName:    "box",
	Doc:       "Box is a rectangular-shaped solid (cuboid)",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "goki.dev/mat32/v2.Vec3", LocalType: "mat32.Vec3", Doc: "size along each dimension", Directives: gti.Directives{}, Tag: ""}},
		{"Segs", &gti.Field{Name: "Segs", Type: "goki.dev/mat32/v2.Vec3i", LocalType: "mat32.Vec3i", Doc: "number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetSize sets the [Box.Size]:
// size along each dimension
func (t *Box) SetSize(v mat32.Vec3) *Box {
	t.Size = v
	return t
}

// SetSegs sets the [Box.Segs]:
// number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1
func (t *Box) SetSegs(v mat32.Vec3i) *Box {
	t.Segs = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Sphere",
	ShortName: "gi3d.Sphere",
	IDName:    "sphere",
	Doc:       "Sphere is a sphere mesh",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", LocalType: "float32", Doc: "radius of the sphere", Directives: gti.Directives{}, Tag: ""}},
		{"WidthSegs", &gti.Field{Name: "WidthSegs", Type: "int", LocalType: "int", Doc: "number of segments around the width of the sphere (32 is reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"3\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments (32 is reasonable default for full height)", Directives: gti.Directives{}, Tag: "min:\"3\""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting radial angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"ElevStart", &gti.Field{Name: "ElevStart", Type: "float32", LocalType: "float32", Doc: "starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"180\" step:\"5\""}},
		{"ElevLen", &gti.Field{Name: "ElevLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max = 180)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"180\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetRadius sets the [Sphere.Radius]:
// radius of the sphere
func (t *Sphere) SetRadius(v float32) *Sphere {
	t.Radius = v
	return t
}

// SetWidthSegs sets the [Sphere.WidthSegs]:
// number of segments around the width of the sphere (32 is reasonable default for full circle)
func (t *Sphere) SetWidthSegs(v int) *Sphere {
	t.WidthSegs = v
	return t
}

// SetHeightSegs sets the [Sphere.HeightSegs]:
// number of height segments (32 is reasonable default for full height)
func (t *Sphere) SetHeightSegs(v int) *Sphere {
	t.HeightSegs = v
	return t
}

// SetAngStart sets the [Sphere.AngStart]:
// starting radial angle in degrees, relative to -1,0,0 left side starting point
func (t *Sphere) SetAngStart(v float32) *Sphere {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Sphere.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Sphere) SetAngLen(v float32) *Sphere {
	t.AngLen = v
	return t
}

// SetElevStart sets the [Sphere.ElevStart]:
// starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom
func (t *Sphere) SetElevStart(v float32) *Sphere {
	t.ElevStart = v
	return t
}

// SetElevLen sets the [Sphere.ElevLen]:
// total angle to generate in degrees (max = 180)
func (t *Sphere) SetElevLen(v float32) *Sphere {
	t.ElevLen = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Cylinder",
	ShortName: "gi3d.Cylinder",
	IDName:    "cylinder",
	Doc:       "Cylinder is a generalized cylinder shape, including a cone\nor truncated cone by having different size circles at either end.\nHeight is up along the Y axis.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder", Directives: gti.Directives{}, Tag: ""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}, Tag: ""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments", Directives: gti.Directives{}, Tag: ""}},
		{"Top", &gti.Field{Name: "Top", Type: "bool", LocalType: "bool", Doc: "render the top disc", Directives: gti.Directives{}, Tag: ""}},
		{"Bottom", &gti.Field{Name: "Bottom", Type: "bool", LocalType: "bool", Doc: "render the bottom disc", Directives: gti.Directives{}, Tag: ""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetHeight sets the [Cylinder.Height]:
// height of the cylinder
func (t *Cylinder) SetHeight(v float32) *Cylinder {
	t.Height = v
	return t
}

// SetTopRad sets the [Cylinder.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Cylinder) SetTopRad(v float32) *Cylinder {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Cylinder.BotRad]:
// radius of the bottom
func (t *Cylinder) SetBotRad(v float32) *Cylinder {
	t.BotRad = v
	return t
}

// SetRadialSegs sets the [Cylinder.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Cylinder) SetRadialSegs(v int) *Cylinder {
	t.RadialSegs = v
	return t
}

// SetHeightSegs sets the [Cylinder.HeightSegs]:
// number of height segments
func (t *Cylinder) SetHeightSegs(v int) *Cylinder {
	t.HeightSegs = v
	return t
}

// SetTop sets the [Cylinder.Top]:
// render the top disc
func (t *Cylinder) SetTop(v bool) *Cylinder {
	t.Top = v
	return t
}

// SetBottom sets the [Cylinder.Bottom]:
// render the bottom disc
func (t *Cylinder) SetBottom(v bool) *Cylinder {
	t.Bottom = v
	return t
}

// SetAngStart sets the [Cylinder.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Cylinder) SetAngStart(v float32) *Cylinder {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Cylinder.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Cylinder) SetAngLen(v float32) *Cylinder {
	t.AngLen = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Capsule",
	ShortName: "gi3d.Capsule",
	IDName:    "capsule",
	Doc:       "Capsule is a generalized capsule shape: a cylinder with hemisphere end caps.\nSupports different radii on each end.\nHeight is along the Y axis -- total height is Height + TopRad + BotRad.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder portion", Directives: gti.Directives{}, Tag: ""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}, Tag: ""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", LocalType: "int", Doc: "number of height segments", Directives: gti.Directives{}, Tag: ""}},
		{"CapSegs", &gti.Field{Name: "CapSegs", Type: "int", LocalType: "int", Doc: "number of segments in the hemisphere cap ends (16 is a reasonable default)", Directives: gti.Directives{}, Tag: ""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total angle to generate in degrees (max 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetHeight sets the [Capsule.Height]:
// height of the cylinder portion
func (t *Capsule) SetHeight(v float32) *Capsule {
	t.Height = v
	return t
}

// SetTopRad sets the [Capsule.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Capsule) SetTopRad(v float32) *Capsule {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Capsule.BotRad]:
// radius of the bottom
func (t *Capsule) SetBotRad(v float32) *Capsule {
	t.BotRad = v
	return t
}

// SetRadialSegs sets the [Capsule.RadialSegs]:
// number of radial segments (32 is a reasonable default for full circle)
func (t *Capsule) SetRadialSegs(v int) *Capsule {
	t.RadialSegs = v
	return t
}

// SetHeightSegs sets the [Capsule.HeightSegs]:
// number of height segments
func (t *Capsule) SetHeightSegs(v int) *Capsule {
	t.HeightSegs = v
	return t
}

// SetCapSegs sets the [Capsule.CapSegs]:
// number of segments in the hemisphere cap ends (16 is a reasonable default)
func (t *Capsule) SetCapSegs(v int) *Capsule {
	t.CapSegs = v
	return t
}

// SetAngStart sets the [Capsule.AngStart]:
// starting angle in degrees, relative to -1,0,0 left side starting point
func (t *Capsule) SetAngStart(v float32) *Capsule {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Capsule.AngLen]:
// total angle to generate in degrees (max 360)
func (t *Capsule) SetAngLen(v float32) *Capsule {
	t.AngLen = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "goki.dev/gi3d.Torus",
	ShortName: "gi3d.Torus",
	IDName:    "torus",
	Doc:       "Torus is a torus mesh, defined by the radius of the solid tube and the\nlarger radius of the ring.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{"-setters"}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", LocalType: "float32", Doc: "larger radius of the torus ring", Directives: gti.Directives{}, Tag: ""}},
		{"TubeRadius", &gti.Field{Name: "TubeRadius", Type: "float32", LocalType: "float32", Doc: "radius of the solid tube", Directives: gti.Directives{}, Tag: ""}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", LocalType: "int", Doc: "number of segments around the radius of the torus (32 is reasonable default for full circle)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"TubeSegs", &gti.Field{Name: "TubeSegs", Type: "int", LocalType: "int", Doc: "number of segments for the tube itself (32 is reasonable default for full height)", Directives: gti.Directives{}, Tag: "min:\"1\""}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", LocalType: "float32", Doc: "starting radial angle in degrees relative to 1,0,0 starting point", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", LocalType: "float32", Doc: "total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"360\" step:\"5\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"MeshBase", &gti.Field{Name: "MeshBase", Type: "goki.dev/gi3d.MeshBase", LocalType: "MeshBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// SetRadius sets the [Torus.Radius]:
// larger radius of the torus ring
func (t *Torus) SetRadius(v float32) *Torus {
	t.Radius = v
	return t
}

// SetTubeRadius sets the [Torus.TubeRadius]:
// radius of the solid tube
func (t *Torus) SetTubeRadius(v float32) *Torus {
	t.TubeRadius = v
	return t
}

// SetRadialSegs sets the [Torus.RadialSegs]:
// number of segments around the radius of the torus (32 is reasonable default for full circle)
func (t *Torus) SetRadialSegs(v int) *Torus {
	t.RadialSegs = v
	return t
}

// SetTubeSegs sets the [Torus.TubeSegs]:
// number of segments for the tube itself (32 is reasonable default for full height)
func (t *Torus) SetTubeSegs(v int) *Torus {
	t.TubeSegs = v
	return t
}

// SetAngStart sets the [Torus.AngStart]:
// starting radial angle in degrees relative to 1,0,0 starting point
func (t *Torus) SetAngStart(v float32) *Torus {
	t.AngStart = v
	return t
}

// SetAngLen sets the [Torus.AngLen]:
// total radial angle to generate in degrees (max = 360)
func (t *Torus) SetAngLen(v float32) *Torus {
	t.AngLen = v
	return t
}

// SolidType is the [gti.Type] for [Solid]
var SolidType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.Solid",
	ShortName:  "gi3d.Solid",
	IDName:     "solid",
	Doc:        "Solid represents an individual 3D solid element.\nIt has its own unique spatial transforms and material properties,\nand points to a mesh structure defining the shape of the solid.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Mesh", &gti.Field{Name: "Mesh", Type: "goki.dev/gi3d.MeshName", LocalType: "MeshName", Doc: "name of the mesh shape information used for rendering this solid -- all meshes are collected on the Scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Mat", &gti.Field{Name: "Mat", Type: "goki.dev/gi3d.Material", LocalType: "Material", Doc: "material properties of the surface (color, shininess, texture, etc)", Directives: gti.Directives{}, Tag: "view:\"add-fields\""}},
		{"MeshPtr", &gti.Field{Name: "MeshPtr", Type: "goki.dev/gi3d.Mesh", LocalType: "Mesh", Doc: "cached pointer to mesh", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "goki.dev/gi3d.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Solid{},
})

// NewSolid adds a new [Solid] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSolid(par ki.Ki, name ...string) *Solid {
	return par.NewChild(SolidType, name...).(*Solid)
}

// KiType returns the [*gti.Type] of [Solid]
func (t *Solid) KiType() *gti.Type {
	return SolidType
}

// New returns a new [*Solid] value
func (t *Solid) New() ki.Ki {
	return &Solid{}
}

// SetMat sets the [Solid.Mat]:
// material properties of the surface (color, shininess, texture, etc)
func (t *Solid) SetMat(v Material) *Solid {
	t.Mat = v
	return t
}

// SetMeshPtr sets the [Solid.MeshPtr]:
// cached pointer to mesh
func (t *Solid) SetMeshPtr(v Mesh) *Solid {
	t.MeshPtr = v
	return t
}

// Text2DType is the [gti.Type] for [Text2D]
var Text2DType = gti.AddType(&gti.Type{
	Name:       "goki.dev/gi3d.Text2D",
	ShortName:  "gi3d.Text2D",
	IDName:     "text-2-d",
	Doc:        "Text2D presents 2D rendered text on a vertically-oriented plane, using a texture.\nCall SetText() which calls RenderText to update fortext changes (re-renders texture).\nThe native scale is such that a unit height value is the height of the default font\nset by the font-size property, and the X axis is scaled proportionally based on the\nrendered text size to maintain the aspect ratio.  Further scaling can be applied on\ntop of that by setting the Pose.Scale values as usual.\nStandard styling properties can be set on the node to set font size, family,\nand text alignment relative to the Pose.Pos position (e.g., Left, Top puts the\nupper-left corner of text at Pos).\nNote that higher quality is achieved by using a larger font size (36 default).\nThe margin property creates blank margin of the background color around the text\n(2 px default) and the background-color defaults to transparent\nbut can be set to any color.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text", &gti.Field{Name: "Text", Type: "string", LocalType: "string", Doc: "the text string to display", Directives: gti.Directives{}, Tag: ""}},
		{"Sty", &gti.Field{Name: "Sty", Type: "goki.dev/girl/styles.Style", LocalType: "styles.Style", Doc: "styling settings for the text", Directives: gti.Directives{}, Tag: "set:\"-\" json:\"-\" xml:\"-\""}},
		{"TxtPos", &gti.Field{Name: "TxtPos", Type: "goki.dev/mat32/v2.Vec2", LocalType: "mat32.Vec2", Doc: "position offset of start of text rendering relative to upper-left corner", Directives: gti.Directives{}, Tag: "set:\"-\" xml:\"-\" json:\"-\""}},
		{"TxtRender", &gti.Field{Name: "TxtRender", Type: "goki.dev/girl/paint.Text", LocalType: "paint.Text", Doc: "render data for text label", Directives: gti.Directives{}, Tag: "set:\"-\" view:\"-\" xml:\"-\" json:\"-\""}},
		{"RenderState", &gti.Field{Name: "RenderState", Type: "goki.dev/girl/paint.State", LocalType: "paint.State", Doc: "render state for rendering text", Directives: gti.Directives{}, Tag: "set:\"-\" copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/gi3d.Solid", LocalType: "Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Text2D{},
})

// NewText2D adds a new [Text2D] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewText2D(par ki.Ki, name ...string) *Text2D {
	return par.NewChild(Text2DType, name...).(*Text2D)
}

// KiType returns the [*gti.Type] of [Text2D]
func (t *Text2D) KiType() *gti.Type {
	return Text2DType
}

// New returns a new [*Text2D] value
func (t *Text2D) New() ki.Ki {
	return &Text2D{}
}

// SetText sets the [Text2D.Text]:
// the text string to display
func (t *Text2D) SetText(v string) *Text2D {
	t.Text = v
	return t
}
