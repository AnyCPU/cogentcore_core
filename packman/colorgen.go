// Copyright (c) 2023, The GoKi Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package packman

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"goki.dev/goki/config"
)

// ColorSchemeData contains the data of a color scheme
// Material Theme Builder Android Views XML file.
type ColorSchemeData struct {
	XMLName xml.Name           `xml:"resources"`
	Colors  []ColorSchemeColor `xml:",any"`
}

// ColorSchemeColor contains the data for one color
// in a [ColorSchemeData] object.
type ColorSchemeColor struct {
	XMLName xml.Name `xml:"color"`
	Name    string   `xml:"name,attr"`
	Color   string   `xml:",chardata"`
}

// IsDark returns whether the color scheme color
// is a color for dark mode. It also removes
// the Light/Dark prefix from the color's name.
// It panics if it the color is for neither light nor dark mode.
func (c *ColorSchemeColor) IsDark() bool {
	if strings.HasPrefix(c.Name, "Light") {
		c.Name = strings.TrimPrefix(c.Name, "Light")
		return false
	}
	if strings.HasPrefix(c.Name, "Dark") {
		c.Name = strings.TrimPrefix(c.Name, "Dark")
		return true
	}
	panic("(ColorSchemeColor).IsDark: color is for neither light nor dark mode")
}

// IsValid returns whether the color is a valid color
// that can be used in a color scheme.
func (c *ColorSchemeColor) IsValid() bool {
	return c.Name != "seed"
}

// Camel fixes the name of the color to
// be correctly formatted camel case
// with any prefixes removed
func (c *ColorSchemeColor) FixName() {
	c.Name = strings.TrimPrefix(c.Name, "md_theme_")
	c.Name = strcase.ToCamel(c.Name)
}

// colorSchemesPreambleData contains
// the data used for the colorSchemesPreamble template.
type colorSchemesPreambleData struct {
	Package string
	Comment string
}

// colorSchemesPreamble is the template for the information
// located at the top of the colorschemes.go file
var colorSchemesPreamble = template.Must(template.New("colorSchemesPreamble").Parse(`// Code generated by "goki colorgen"; DO NOT EDIT

package {{.Package}}

import (
	"github.com/goki/gi/gist"
)

{{.Comment}}
var ColorSchemes = gist.ColorSchemes{
	Light: gist.ColorScheme{`))

// colorSchemeDarkPreamble is the string
// located at the top of the dark color scheme
// declaration.
const colorSchemeDarkPreamble = `
	},
	Dark: gist.ColorScheme{`

// colorSchemesEnd is the string located
// at the end of the colorschemes.go file
const colorSchemesEnd = `
	},
}
`

// colorDataTmpl is the template for
// the information for one color scheme color
var colorDataTmpl = template.Must(template.New("colorData").Parse(
	`
		{{.Name}}: gist.MustColorFromHex("{{.Color}}"),`,
))

// tempCustomColors is a TEMPORARY slice of color scheme colors
// to be added into the resulting colorschemes.go file. It contains
// some of the colors that have not been added to the material theme
// builder yet. TODO: remove this once the rest of the colors are
// added to the material theme builder
// (see https://github.com/material-foundation/material-theme-builder/issues/187).
var tempCustomColors = []ColorSchemeColor{
	{Name: "LightSurfaceDim", Color: "#DED8E1"},
	{Name: "LightSurfaceBright", Color: "#FEF7FF"},
	{Name: "LightSurfaceContainerLowest", Color: "#FFFFFF"},
	{Name: "LightSurfaceContainerLow", Color: "#F7F2FA"},
	{Name: "LightSurfaceContainer", Color: "#F3EDF7"},
	{Name: "LightSurfaceContainerHigh", Color: "#ECE6F0"},
	{Name: "LightSurfaceContainerHighest", Color: "#E6E0E9"},

	{Name: "DarkSurfaceDim", Color: "#141218"},
	{Name: "DarkSurfaceBright", Color: "#3B383E"},
	{Name: "DarkSurfaceContainerLowest", Color: "#0F0D13"},
	{Name: "DarkSurfaceContainerLow", Color: "#1D1B20"},
	{Name: "DarkSurfaceContainer", Color: "#211F26"},
	{Name: "DarkSurfaceContainerHigh", Color: "#2B2930"},
	{Name: "DarkSurfaceContainerHighest", Color: "#36343B"},
}

// addTempCustomColors is a TEMPORARY function that returns
// the combination of [tempCustomColors] and the given colors
// in the correct order. See the documentation of [tempCustomColors]
// for more information. TODO: remove this once the rest of the
// colors are added to the material theme builder
func addTempCustomColors(colors []ColorSchemeColor) []ColorSchemeColor {
	// whether we have switched over to dark colors yet
	onDark := false
	res := []ColorSchemeColor{}
	for _, color := range colors {
		if !color.IsValid() {
			continue
		}
		color.FixName()
		if strings.HasPrefix(color.Name, "Dark") && !onDark {
			onDark = true
			for _, tcolor := range tempCustomColors {
				if strings.HasPrefix(tcolor.Name, "Dark") {
					break
				}
				res = append(res, tcolor)
			}
		}
		res = append(res, color)
	}
	for _, tcolor := range tempCustomColors {
		if strings.HasPrefix(tcolor.Name, "Light") {
			continue
		}
		res = append(res, tcolor)
	}
	return res
}

// GenerateColorScheme generates a Go color scheme
// declaration file from a Material Theme Builder
// Android Views XML file located at the config source
// file path. It stores the resulting Go file
// at the config destination file path. The generated
// file is part of the config package and puts the
// config comment as the comment for the ColorSchemes variable.
func GenerateColorScheme(c *config.Config) error {
	d, err := GetColorSchemeData(c.Colorgen.Source)
	if err != nil {
		return fmt.Errorf("GenerateColorScheme: error getting color scheme data: %w", err)
	}

	buf := &bytes.Buffer{}
	err = colorSchemesPreamble.Execute(buf, colorSchemesPreambleData{c.Colorgen.Package, c.Colorgen.Comment})
	if err != nil {
		return fmt.Errorf("GenerateColorScheme: error executing preamble template: %w", err)
	}
	// whether we have switched over to dark colors yet
	onDark := false
	d.Colors = addTempCustomColors(d.Colors)
	for _, c := range d.Colors {
		if !c.IsValid() {
			continue
		}
		c.FixName()
		if c.IsDark() && !onDark {
			buf.WriteString(colorSchemeDarkPreamble)
			onDark = true
		}
		err := colorDataTmpl.Execute(buf, c)
		if err != nil {
			return fmt.Errorf("GenerateColorScheme: error executing color data template: %w", err)
		}
	}
	buf.WriteString(colorSchemesEnd)
	err = os.WriteFile(c.Colorgen.Output, buf.Bytes(), 0666)
	if err != nil {
		return fmt.Errorf("GenerateColorSchemes: error writing result to file: %w", err)
	}
	return nil
}

// GetColorSchemeData gets the [ColorSchemeData] from
// the XML file located at the given filepath.
func GetColorSchemeData(fpath string) (ColorSchemeData, error) {
	b, err := os.ReadFile(fpath)
	if err != nil {
		return ColorSchemeData{}, fmt.Errorf("GetColorSchemeData: error loading file %s: %w", fpath, err)
	}
	v := ColorSchemeData{}
	err = xml.Unmarshal(b, &v)
	if err != nil {
		return ColorSchemeData{}, fmt.Errorf("GetColorSchemeData: error unmarshalling file data: %w", err)
	}
	return v, nil
}
