// Code generated by "goki generate"; DO NOT EDIT.

package parse

import (
	"goki.dev/gti"
	"goki.dev/ki"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Actions",
	Doc:        "Actions are parsing actions to perform",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Act",
	Doc:        "Act is one action to perform, operating on the Ast output",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"RunIdx", &gti.Field{Name: "RunIdx", Type: "int", Doc: "at what point during sequence of sub-rules / tokens should this action be run?  -1 = at end, 0 = before first rule, 1 = before second rule, etc -- must be at point when relevant Ast nodes have been added, but for scope setting, must be early enough so that scope is present", Directives: gti.Directives{}}},
		{"Act", &gti.Field{Name: "Act", Type: "Actions", Doc: "what action to perform", Directives: gti.Directives{}}},
		{"Path", &gti.Field{Name: "Path", Type: "string", Doc: "Ast path, relative to current node: empty = current node; [idx] specifies a child node by index, and a name specifies it by name -- include name/name for sub-nodes etc -- multiple path options can be specified by | or & and will be tried in order until one succeeds (for |) or all that succeed will be used for &. ... means use all nodes with given name (only for change token) -- for PushStack, this is what to push on the stack", Directives: gti.Directives{}}},
		{"Tok", &gti.Field{Name: "Tok", Type: "token.Tokens", Doc: "for ChgToken, the new token type to assign to token at given path", Directives: gti.Directives{}}},
		{"FmTok", &gti.Field{Name: "FmTok", Type: "token.Tokens", Doc: "for ChgToken, only change if token is this to start with (only if != None))", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Acts",
	Doc:        "Acts are multiple actions",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.AstActs",
	Doc:        "AstActs are actions to perform on the Ast nodes",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

// AstType is the [gti.Type] for [Ast]
var AstType = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Ast",
	Doc:        "Ast is a node in the abstract syntax tree generated by the parsing step\nthe name of the node (from ki.Node) is the type of the element\n(e.g., expr, stmt, etc)\nThese nodes are generated by the parse.Rule's by matching tokens",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"TokReg", &gti.Field{Name: "TokReg", Type: "lex.Reg", Doc: "region in source lexical tokens corresponding to this Ast node -- Ch = index in lex lines", Directives: gti.Directives{}}},
		{"SrcReg", &gti.Field{Name: "SrcReg", Type: "lex.Reg", Doc: "region in source file corresponding to this Ast node", Directives: gti.Directives{}}},
		{"Src", &gti.Field{Name: "Src", Type: "string", Doc: "source code corresponding to this Ast node", Directives: gti.Directives{}}},
		{"Syms", &gti.Field{Name: "Syms", Type: "syms.SymStack", Doc: "stack of symbols created for this node", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Ast{},
})

// NewAst adds a new [Ast] with
// the given name to the given parent.
func NewAst(par ki.Ki, name string) *Ast {
	return par.NewChild(AstType, name).(*Ast)
}

// KiType returns the [*gti.Type] of [Ast]
func (t *Ast) KiType() *gti.Type {
	return AstType
}

// New returns a new [*Ast] value
func (t *Ast) New() ki.Ki {
	return &Ast{}
}

// RuleType is the [gti.Type] for [Rule]
var RuleType = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Rule",
	Doc:        "The first step is matching which searches in order for matches within the\nchildren of parent nodes, and for explicit rule nodes, it looks first\nthrough all the explicit tokens in the rule.  If there are no explicit tokens\nthen matching defers to ONLY the first node listed by default -- you can\nadd a @ prefix to indicate a rule that is also essential to match.\n\nAfter a rule matches, it then proceeds through the rules narrowing the scope\nand calling the sub-nodes..",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Off", &gti.Field{Name: "Off", Type: "bool", Doc: "disable this rule -- useful for testing and exploration", Directives: gti.Directives{}}},
		{"Desc", &gti.Field{Name: "Desc", Type: "string", Doc: "description / comments about this rule", Directives: gti.Directives{}}},
		{"Rule", &gti.Field{Name: "Rule", Type: "string", Doc: "the rule as a space-separated list of rule names and token(s) -- use single quotes around 'tokens' (using token.Tokens names or symbols). For keywords use 'key:keyword'.  All tokens are matched at the same nesting depth as the start of the scope of this rule, unless they have a +D relative depth value differential before the token.  Use @ prefix for a sub-rule to require that rule to match -- by default explicit tokens are used if available, and then only the first sub-rule failing that.  Use ! by itself to define start of an exclusionary rule -- doesn't match when those rule elements DO match.  Use : prefix for a special group node that matches a single token at start of scope, and then defers to the child rules to perform full match -- this is used for FirstTokMap when there are multiple versions of a given keyword rule.  Use - prefix for tokens anchored by the end (next token) instead of the previous one -- typically just for token prior to 'EOS' but also a block of tokens that need to go backward in the middle of a sequence to avoid ambiguity can be marked with -", Directives: gti.Directives{}}},
		{"StackMatch", &gti.Field{Name: "StackMatch", Type: "string", Doc: "if present, this rule only fires if stack has this on it", Directives: gti.Directives{}}},
		{"Ast", &gti.Field{Name: "Ast", Type: "AstActs", Doc: "what action should be take for this node when it matches", Directives: gti.Directives{}}},
		{"Acts", &gti.Field{Name: "Acts", Type: "Acts", Doc: "actions to perform based on parsed Ast tree data, when this rule is done executing", Directives: gti.Directives{}}},
		{"OptTokMap", &gti.Field{Name: "OptTokMap", Type: "bool", Doc: "for group-level rules having lots of children and lots of recursiveness, and also of high-frequency, when we first encounter such a rule, make a map of all the tokens in the entire scope, and use that for a first-pass rejection on matching tokens", Directives: gti.Directives{}}},
		{"FirstTokMap", &gti.Field{Name: "FirstTokMap", Type: "bool", Doc: "for group-level rules with a number of rules that match based on first tokens / keywords, build map to directly go to that rule -- must also organize all of these rules sequentially from the start -- if no match, goes directly to first non-lookup case", Directives: gti.Directives{}}},
		{"Rules", &gti.Field{Name: "Rules", Type: "RuleList", Doc: "rule elements compiled from Rule string", Directives: gti.Directives{}}},
		{"Order", &gti.Field{Name: "Order", Type: "[]int", Doc: "strategic matching order for matching the rules", Directives: gti.Directives{}}},
		{"FiTokMap", &gti.Field{Name: "FiTokMap", Type: "map[string]*Rule", Doc: "map from first tokens / keywords to rules for FirstTokMap case", Directives: gti.Directives{}}},
		{"FiTokElseIdx", &gti.Field{Name: "FiTokElseIdx", Type: "int", Doc: "for FirstTokMap, the start of the else cases not covered by the map", Directives: gti.Directives{}}},
		{"ExclKeyIdx", &gti.Field{Name: "ExclKeyIdx", Type: "int", Doc: "exclusionary key index -- this is the token in Rules that we need to exclude matches for using ExclFwd and ExclRev rules", Directives: gti.Directives{}}},
		{"ExclFwd", &gti.Field{Name: "ExclFwd", Type: "RuleList", Doc: "exclusionary forward-search rule elements compiled from Rule string", Directives: gti.Directives{}}},
		{"ExclRev", &gti.Field{Name: "ExclRev", Type: "RuleList", Doc: "exclusionary reverse-search rule elements compiled from Rule string", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ki.Node", &gti.Field{Name: "ki.Node", Type: "ki.Node", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Rule{},
})

// NewRule adds a new [Rule] with
// the given name to the given parent.
func NewRule(par ki.Ki, name string) *Rule {
	return par.NewChild(RuleType, name).(*Rule)
}

// KiType returns the [*gti.Type] of [Rule]
func (t *Rule) KiType() *gti.Type {
	return RuleType
}

// New returns a new [*Rule] value
func (t *Rule) New() ki.Ki {
	return &Rule{}
}

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.RuleFlags",
	Doc:        "RuleFlags define bitflags for rule options compiled from rule syntax",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Parser",
	Doc:        "Parser is the interface type for parsers -- likely not necessary except is essential\nfor defining the BaseIface for gui in making new nodes",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.RuleEl",
	Doc:        "RuleEl is an element of a parsing rule -- either a pointer to another rule or a token",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Rule", &gti.Field{Name: "Rule", Type: "*Rule", Doc: "sub-rule for this position -- nil if token", Directives: gti.Directives{}}},
		{"Tok", &gti.Field{Name: "Tok", Type: "token.KeyToken", Doc: "token, None if rule", Directives: gti.Directives{}}},
		{"StInc", &gti.Field{Name: "StInc", Type: "int", Doc: "start increment for matching -- this is the number of non-optional, non-match items between (start | last match) and this item -- increments start region for matching", Directives: gti.Directives{}}},
		{"Match", &gti.Field{Name: "Match", Type: "bool", Doc: "if true, this rule must match for rule to fire -- by default only tokens and, failing that, the first sub-rule is used for matching -- use @ to require a match", Directives: gti.Directives{}}},
		{"Opt", &gti.Field{Name: "Opt", Type: "bool", Doc: "this rule is optional -- will absorb tokens if they exist -- indicated with ? prefix", Directives: gti.Directives{}}},
		{"FmNext", &gti.Field{Name: "FmNext", Type: "bool", Doc: "match this rule working backward from the next token -- triggered by - (minus) prefix and optimizes cases where there can be a lot of tokens going forward but few going from end -- must be anchored by a terminal EOS or other FmNext elements and is ignored if at the very end", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.RuleList",
	Doc:        "RuleList is a list (slice) of rule elements",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Matches",
	Doc:        "Matches encodes the regions of each match, Err for no match",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.State",
	Doc:        "parse.State is the state maintained for parsing",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Src", &gti.Field{Name: "Src", Type: "*lex.File", Doc: "[view: no-inline] source and lexed version of source we're parsing", Directives: gti.Directives{}}},
		{"Trace", &gti.Field{Name: "Trace", Type: "TraceOpts", Doc: "tracing for this parser", Directives: gti.Directives{}}},
		{"Ast", &gti.Field{Name: "Ast", Type: "*Ast", Doc: "root of the Ast abstract syntax tree we're updating", Directives: gti.Directives{}}},
		{"Syms", &gti.Field{Name: "Syms", Type: "syms.SymMap", Doc: "symbol map that everything gets added to from current file of parsing -- typically best for subsequent management to just have a single outer-most scoping symbol here (e.g., in Go it is the package), and then everything is a child under that", Directives: gti.Directives{}}},
		{"Scopes", &gti.Field{Name: "Scopes", Type: "syms.SymStack", Doc: "stack of scope(s) added to FileSyms e.g., package, library, module-level elements of which this file is a part -- these are reset at the start and must be added by parsing actions within the file itself", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "lex.Pos", Doc: "the current lex token position", Directives: gti.Directives{}}},
		{"Errs", &gti.Field{Name: "Errs", Type: "lex.ErrorList", Doc: "[view: no-inline] any error messages accumulated during parsing specifically", Directives: gti.Directives{}}},
		{"Matches", &gti.Field{Name: "Matches", Type: "[][]MatchStack", Doc: "[view: no-inline] rules that matched and ran at each point, in 1-to-1 correspondence with the Src.Lex tokens for the lines and char pos dims", Directives: gti.Directives{}}},
		{"NonMatches", &gti.Field{Name: "NonMatches", Type: "ScopeRuleSet", Doc: "[view: no-inline] rules that did NOT match -- represented as a map by scope of a RuleSet", Directives: gti.Directives{}}},
		{"Stack", &gti.Field{Name: "Stack", Type: "lex.Stack", Doc: "[view: no-inline] stack for context-sensitive rules", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.MatchState",
	Doc:        "MatchState holds state info for rules that matched, recorded at starting position of match",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Rule", &gti.Field{Name: "Rule", Type: "*Rule", Doc: "rule that either matched or ran here", Directives: gti.Directives{}}},
		{"Scope", &gti.Field{Name: "Scope", Type: "lex.Reg", Doc: "scope for match", Directives: gti.Directives{}}},
		{"Regs", &gti.Field{Name: "Regs", Type: "Matches", Doc: "regions of match for each sub-region", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.MatchStack",
	Doc:        "MatchStack is the stack of rules that matched or ran for each token point",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.ScopeRule",
	Doc:        "ScopeRule is a scope and a rule, for storing matches / nonmatch",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Scope", &gti.Field{Name: "Scope", Type: "lex.Reg", Doc: "", Directives: gti.Directives{}}},
		{"Rule", &gti.Field{Name: "Rule", Type: "*Rule", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.ScopeRuleSet",
	Doc:        "ScopeRuleSet is a map by scope of RuleSets, for non-matching rules",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.TraceOpts",
	Doc:        "TraceOpts provides options for debugging / monitoring the rule matching and execution process",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"On", &gti.Field{Name: "On", Type: "bool", Doc: "perform tracing", Directives: gti.Directives{}}},
		{"Rules", &gti.Field{Name: "Rules", Type: "string", Doc: "trace specific named rules here (space separated) -- if blank, then all rules are traced", Directives: gti.Directives{}}},
		{"Match", &gti.Field{Name: "Match", Type: "bool", Doc: "trace full rule matches -- when a rule fully matches", Directives: gti.Directives{}}},
		{"SubMatch", &gti.Field{Name: "SubMatch", Type: "bool", Doc: "trace sub-rule matches -- when the parts of each rule match", Directives: gti.Directives{}}},
		{"NoMatch", &gti.Field{Name: "NoMatch", Type: "bool", Doc: "trace sub-rule non-matches -- why a rule doesn't match -- which terminates the matching process at first non-match (can be a lot of info)", Directives: gti.Directives{}}},
		{"Run", &gti.Field{Name: "Run", Type: "bool", Doc: "trace progress running through each of the sub-rules when a rule has matched and is 'running'", Directives: gti.Directives{}}},
		{"RunAct", &gti.Field{Name: "RunAct", Type: "bool", Doc: "trace actions performed by running rules", Directives: gti.Directives{}}},
		{"ScopeSrc", &gti.Field{Name: "ScopeSrc", Type: "bool", Doc: "if true, shows the full scope source for every trace statement", Directives: gti.Directives{}}},
		{"FullStackOut", &gti.Field{Name: "FullStackOut", Type: "bool", Doc: "for the ParseOut display, whether to display the full stack of rules at each position, or just the deepest one", Directives: gti.Directives{}}},
		{"RulesList", &gti.Field{Name: "RulesList", Type: "[]string", Doc: "[view: -] list of rules", Directives: gti.Directives{}}},
		{"OutWrite", &gti.Field{Name: "OutWrite", Type: "*os.File", Doc: "[view: -] trace output is written here, connected via os.Pipe to OutRead", Directives: gti.Directives{}}},
		{"OutRead", &gti.Field{Name: "OutRead", Type: "*os.File", Doc: "[view: -] trace output is read here -- can connect this to a TextBuf via giv.OutBuf to monitor tracing output", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/pi/parse.Steps",
	Doc:        "Steps are the different steps of the parsing processing",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
