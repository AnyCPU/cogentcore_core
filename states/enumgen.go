// Code generated by "enumgen"; DO NOT EDIT.

package states

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _StatesValues = []States{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}

// StatesN is the highest valid value
// for type States, plus one.
const StatesN States = 15

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _StatesNoOp() {
	var x [1]struct{}
	_ = x[Disabled-(0)]
	_ = x[ReadOnly-(1)]
	_ = x[Selected-(2)]
	_ = x[Active-(3)]
	_ = x[Focused-(4)]
	_ = x[FocusedWithin-(5)]
	_ = x[Checked-(6)]
	_ = x[Hovered-(7)]
	_ = x[LongHovered-(8)]
	_ = x[Invalid-(9)]
	_ = x[Required-(10)]
	_ = x[Blank-(11)]
	_ = x[Link-(12)]
	_ = x[Visited-(13)]
	_ = x[AnyLink-(14)]
}

var _StatesNameToValueMap = map[string]States{
	`Disabled`:      0,
	`disabled`:      0,
	`ReadOnly`:      1,
	`readonly`:      1,
	`Selected`:      2,
	`selected`:      2,
	`Active`:        3,
	`active`:        3,
	`Focused`:       4,
	`focused`:       4,
	`FocusedWithin`: 5,
	`focusedwithin`: 5,
	`Checked`:       6,
	`checked`:       6,
	`Hovered`:       7,
	`hovered`:       7,
	`LongHovered`:   8,
	`longhovered`:   8,
	`Invalid`:       9,
	`invalid`:       9,
	`Required`:      10,
	`required`:      10,
	`Blank`:         11,
	`blank`:         11,
	`Link`:          12,
	`link`:          12,
	`Visited`:       13,
	`visited`:       13,
	`AnyLink`:       14,
	`anylink`:       14,
}

var _StatesDescMap = map[States]string{
	0:  `Disabled elements cannot be interacted with or selected, but do display`,
	1:  `ReadOnly elements elements cannot be changed`,
	2:  `Selected elements have been marked for clipboard or other such actions`,
	3:  `Active elements are currently being interacted with, including a button being pressed, an element being dragged or scrolled`,
	4:  `Focused elements receive keyboard input`,
	5:  `FocusedWithin elements have a Focused element within them, including self`,
	6:  `Checked is for check boxes or radio buttons or other similar state`,
	7:  `Hovered indicates that a mouse pointer has entered the space over an element, but it is not Active`,
	8:  `LongHovered indicates a Hover that persists without significant movement for a minimum period of time (e.g., 500 msec), which typically triggers a tooltip popup`,
	9:  `Invalid indicates that the element has invalid input and needs to be corrected by the user`,
	10: `Required indicates that the element must be set by the user`,
	11: `Blank indicates that the element has yet to be set by user`,
	12: `Link indicates a URL link that has not been visited yet`,
	13: `Visited indicates a URL link that has been visited`,
	14: `AnyLink is either Link or Visited`,
}

var _StatesMap = map[States]string{
	0:  `Disabled`,
	1:  `ReadOnly`,
	2:  `Selected`,
	3:  `Active`,
	4:  `Focused`,
	5:  `FocusedWithin`,
	6:  `Checked`,
	7:  `Hovered`,
	8:  `LongHovered`,
	9:  `Invalid`,
	10: `Required`,
	11: `Blank`,
	12: `Link`,
	13: `Visited`,
	14: `AnyLink`,
}

// String returns the string representation
// of this States value.
func (i States) String() string {
	str := ""
	for _, ie := range _StatesValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this States value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i States) BitIndexString() string {
	if str, ok := _StatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the States value from its
// string representation, and returns an
// error if the string is invalid.
func (i *States) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the States value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *States) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _StatesNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _StatesNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type States")
		}
	}
	return nil
}

// Int64 returns the States value as an int64.
func (i States) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the States value from an int64.
func (i *States) SetInt64(in int64) {
	*i = States(in)
}

// Desc returns the description of the States value.
func (i States) Desc() string {
	if str, ok := _StatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// StatesValues returns all possible values
// for the type States.
func StatesValues() []States {
	return _StatesValues
}

// Values returns all possible values
// for the type States.
func (i States) Values() []enums.Enum {
	res := make([]enums.Enum, len(_StatesValues))
	for i, d := range _StatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type States.
func (i States) IsValid() bool {
	_, ok := _StatesMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i States) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *States) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i States) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *States) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
