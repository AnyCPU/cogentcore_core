// Code generated by "goki generate ./..."; DO NOT EDIT.

package states

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _StatesValues = []States{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21}

// StatesN is the highest valid value
// for type States, plus one.
const StatesN States = 22

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _StatesNoOp() {
	var x [1]struct{}
	_ = x[Invisible-(0)]
	_ = x[Disabled-(1)]
	_ = x[ReadOnly-(2)]
	_ = x[Selected-(3)]
	_ = x[Active-(4)]
	_ = x[Dragging-(5)]
	_ = x[Sliding-(6)]
	_ = x[Scrolling-(7)]
	_ = x[Focused-(8)]
	_ = x[FocusedWithin-(9)]
	_ = x[Checked-(10)]
	_ = x[Hovered-(11)]
	_ = x[LongHovered-(12)]
	_ = x[LongPressed-(13)]
	_ = x[DragHovered-(14)]
	_ = x[DropOK-(15)]
	_ = x[Invalid-(16)]
	_ = x[Required-(17)]
	_ = x[Blank-(18)]
	_ = x[Link-(19)]
	_ = x[Visited-(20)]
	_ = x[AnyLink-(21)]
}

var _StatesNameToValueMap = map[string]States{
	`Invisible`:     0,
	`invisible`:     0,
	`Disabled`:      1,
	`disabled`:      1,
	`ReadOnly`:      2,
	`readonly`:      2,
	`Selected`:      3,
	`selected`:      3,
	`Active`:        4,
	`active`:        4,
	`Dragging`:      5,
	`dragging`:      5,
	`Sliding`:       6,
	`sliding`:       6,
	`Scrolling`:     7,
	`scrolling`:     7,
	`Focused`:       8,
	`focused`:       8,
	`FocusedWithin`: 9,
	`focusedwithin`: 9,
	`Checked`:       10,
	`checked`:       10,
	`Hovered`:       11,
	`hovered`:       11,
	`LongHovered`:   12,
	`longhovered`:   12,
	`LongPressed`:   13,
	`longpressed`:   13,
	`DragHovered`:   14,
	`draghovered`:   14,
	`DropOK`:        15,
	`dropok`:        15,
	`Invalid`:       16,
	`invalid`:       16,
	`Required`:      17,
	`required`:      17,
	`Blank`:         18,
	`blank`:         18,
	`Link`:          19,
	`link`:          19,
	`Visited`:       20,
	`visited`:       20,
	`AnyLink`:       21,
	`anylink`:       21,
}

var _StatesDescMap = map[States]string{
	0:  `Invisible elements are not displayed, and thus do not present a target for GUI events. It is identical to css display:none. This can also be set when the item is out of visible display as in scrolling or collapsing elements. Elements can be made visible by toggling this flag and thus in general should be constructed and styled, but a new layout step must generally be taken after visibility status has changed.`,
	1:  `Disabled elements cannot be interacted with or selected, but do display.`,
	2:  `ReadOnly elements cannot be changed, but can be selected. A text input must not be ReadOnly for entering text. A button can be pressed while ReadOnly -- if not ReadOnly then the label on the button can be edited, for example.`,
	3:  `Selected elements have been marked for clipboard or other such actions.`,
	4:  `Active elements are currently being interacted with, usually involving a mouse button being pressed in the element. A text field will be active while being clicked on, and this can also result in a Focused state. If further movement happens, an element can also end up being Dragged or Sliding.`,
	5:  `Dragging means this element is currently being dragged by the mouse (i.e., a MouseDown event followed by MouseMove), as part of a drag-n-drop sequence.`,
	6:  `Sliding means this element is currently being manipulated via mouse to change the slider state, which will continue until the mouse is released, even if it goes off the element. It should also still be Active.`,
	7:  `Scrolling means this element is currently being scrolled.`,
	8:  `Focused elements receive keyboard input.`,
	9:  `FocusedWithin elements have a Focused element within them, including self.`,
	10: `Checked is for check boxes or radio buttons or other similar state.`,
	11: `Hovered indicates that a mouse pointer has entered the space over an element, but it is not Active (nor DragHovered).`,
	12: `LongHovered indicates a Hover event that persists without significant movement for a minimum period of time (e.g., 500 msec), which typically triggers a tooltip popup.`,
	13: `LongPressed indicates a MouseDown event that persists without significant movement for a minimum period of time (e.g., 500 msec), which typically triggers a tooltip and/or context menu popup.`,
	14: `DragHovered indicates that a mouse pointer has entered the space over an element, during a drag-n-drop sequence. This makes it a candidate for a potential drop target. See DropOK for state in relation to that.`,
	15: `DropOK indicates that a DragHovered element is OK to receive a Drop from the current Dragged item, subject also to the Droppable ability.`,
	16: `Invalid indicates that the element has invalid input and needs to be corrected by the user`,
	17: `Required indicates that the element must be set by the user`,
	18: `Blank indicates that the element has yet to be set by user`,
	19: `Link indicates a URL link that has not been visited yet`,
	20: `Visited indicates a URL link that has been visited`,
	21: `AnyLink is either Link or Visited`,
}

var _StatesMap = map[States]string{
	0:  `Invisible`,
	1:  `Disabled`,
	2:  `ReadOnly`,
	3:  `Selected`,
	4:  `Active`,
	5:  `Dragging`,
	6:  `Sliding`,
	7:  `Scrolling`,
	8:  `Focused`,
	9:  `FocusedWithin`,
	10: `Checked`,
	11: `Hovered`,
	12: `LongHovered`,
	13: `LongPressed`,
	14: `DragHovered`,
	15: `DropOK`,
	16: `Invalid`,
	17: `Required`,
	18: `Blank`,
	19: `Link`,
	20: `Visited`,
	21: `AnyLink`,
}

// String returns the string representation
// of this States value.
func (i States) String() string {
	str := ""
	for _, ie := range _StatesValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this States value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i States) BitIndexString() string {
	if str, ok := _StatesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the States value from its
// string representation, and returns an
// error if the string is invalid.
func (i *States) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the States value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *States) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _StatesNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _StatesNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type States")
		}
	}
	return nil
}

// Int64 returns the States value as an int64.
func (i States) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the States value from an int64.
func (i *States) SetInt64(in int64) {
	*i = States(in)
}

// Desc returns the description of the States value.
func (i States) Desc() string {
	if str, ok := _StatesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// StatesValues returns all possible values
// for the type States.
func StatesValues() []States {
	return _StatesValues
}

// Values returns all possible values
// for the type States.
func (i States) Values() []enums.Enum {
	res := make([]enums.Enum, len(_StatesValues))
	for i, d := range _StatesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type States.
func (i States) IsValid() bool {
	_, ok := _StatesMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i States) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *States) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i States) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *States) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
