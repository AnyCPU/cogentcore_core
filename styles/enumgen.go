// Code generated by "goki generate ./..."; DO NOT EDIT.

package gist

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _BorderStylesValues = []BorderStyles{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// BorderStylesN is the highest valid value
// for type BorderStyles, plus one.
const BorderStylesN BorderStyles = 10

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BorderStylesNoOp() {
	var x [1]struct{}
	_ = x[BorderSolid-(0)]
	_ = x[BorderDotted-(1)]
	_ = x[BorderDashed-(2)]
	_ = x[BorderDouble-(3)]
	_ = x[BorderGroove-(4)]
	_ = x[BorderRidge-(5)]
	_ = x[BorderInset-(6)]
	_ = x[BorderOutset-(7)]
	_ = x[BorderNone-(8)]
	_ = x[BorderHidden-(9)]
}

var _BorderStylesNameToValueMap = map[string]BorderStyles{
	`BorderSolid`:  0,
	`bordersolid`:  0,
	`BorderDotted`: 1,
	`borderdotted`: 1,
	`BorderDashed`: 2,
	`borderdashed`: 2,
	`BorderDouble`: 3,
	`borderdouble`: 3,
	`BorderGroove`: 4,
	`bordergroove`: 4,
	`BorderRidge`:  5,
	`borderridge`:  5,
	`BorderInset`:  6,
	`borderinset`:  6,
	`BorderOutset`: 7,
	`borderoutset`: 7,
	`BorderNone`:   8,
	`bordernone`:   8,
	`BorderHidden`: 9,
	`borderhidden`: 9,
}

var _BorderStylesDescMap = map[BorderStyles]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
	8: ``,
	9: ``,
}

var _BorderStylesMap = map[BorderStyles]string{
	0: `BorderSolid`,
	1: `BorderDotted`,
	2: `BorderDashed`,
	3: `BorderDouble`,
	4: `BorderGroove`,
	5: `BorderRidge`,
	6: `BorderInset`,
	7: `BorderOutset`,
	8: `BorderNone`,
	9: `BorderHidden`,
}

// String returns the string representation
// of this BorderStyles value.
func (i BorderStyles) String() string {
	if str, ok := _BorderStylesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BorderStyles value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BorderStyles) SetString(s string) error {
	if val, ok := _BorderStylesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BorderStylesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BorderStyles")
}

// Int64 returns the BorderStyles value as an int64.
func (i BorderStyles) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BorderStyles value from an int64.
func (i *BorderStyles) SetInt64(in int64) {
	*i = BorderStyles(in)
}

// Desc returns the description of the BorderStyles value.
func (i BorderStyles) Desc() string {
	if str, ok := _BorderStylesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BorderStylesValues returns all possible values
// for the type BorderStyles.
func BorderStylesValues() []BorderStyles {
	return _BorderStylesValues
}

// Values returns all possible values
// for the type BorderStyles.
func (i BorderStyles) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BorderStylesValues))
	for i, d := range _BorderStylesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BorderStyles.
func (i BorderStyles) IsValid() bool {
	_, ok := _BorderStylesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BorderStyles) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BorderStyles) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontStylesValues = []FontStyles{0, 1, 2}

// FontStylesN is the highest valid value
// for type FontStyles, plus one.
const FontStylesN FontStyles = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontStylesNoOp() {
	var x [1]struct{}
	_ = x[FontNormal-(0)]
	_ = x[FontItalic-(1)]
	_ = x[FontOblique-(2)]
}

var _FontStylesNameToValueMap = map[string]FontStyles{
	`FontNormal`:  0,
	`fontnormal`:  0,
	`FontItalic`:  1,
	`fontitalic`:  1,
	`FontOblique`: 2,
	`fontoblique`: 2,
}

var _FontStylesDescMap = map[FontStyles]string{
	0: ``,
	1: ``,
	2: ``,
}

var _FontStylesMap = map[FontStyles]string{
	0: `FontNormal`,
	1: `FontItalic`,
	2: `FontOblique`,
}

// String returns the string representation
// of this FontStyles value.
func (i FontStyles) String() string {
	if str, ok := _FontStylesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontStyles value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontStyles) SetString(s string) error {
	if val, ok := _FontStylesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontStylesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontStyles")
}

// Int64 returns the FontStyles value as an int64.
func (i FontStyles) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontStyles value from an int64.
func (i *FontStyles) SetInt64(in int64) {
	*i = FontStyles(in)
}

// Desc returns the description of the FontStyles value.
func (i FontStyles) Desc() string {
	if str, ok := _FontStylesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontStylesValues returns all possible values
// for the type FontStyles.
func FontStylesValues() []FontStyles {
	return _FontStylesValues
}

// Values returns all possible values
// for the type FontStyles.
func (i FontStyles) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontStylesValues))
	for i, d := range _FontStylesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontStyles.
func (i FontStyles) IsValid() bool {
	_, ok := _FontStylesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStyles) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStyles) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontWeightsValues = []FontWeights{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}

// FontWeightsN is the highest valid value
// for type FontWeights, plus one.
const FontWeightsN FontWeights = 20

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontWeightsNoOp() {
	var x [1]struct{}
	_ = x[WeightNormal-(0)]
	_ = x[Weight100-(1)]
	_ = x[WeightThin-(2)]
	_ = x[Weight200-(3)]
	_ = x[WeightExtraLight-(4)]
	_ = x[Weight300-(5)]
	_ = x[WeightLight-(6)]
	_ = x[Weight400-(7)]
	_ = x[Weight500-(8)]
	_ = x[WeightMedium-(9)]
	_ = x[Weight600-(10)]
	_ = x[WeightSemiBold-(11)]
	_ = x[Weight700-(12)]
	_ = x[WeightBold-(13)]
	_ = x[Weight800-(14)]
	_ = x[WeightExtraBold-(15)]
	_ = x[Weight900-(16)]
	_ = x[WeightBlack-(17)]
	_ = x[WeightBolder-(18)]
	_ = x[WeightLighter-(19)]
}

var _FontWeightsNameToValueMap = map[string]FontWeights{
	`WeightNormal`:     0,
	`weightnormal`:     0,
	`Weight100`:        1,
	`weight100`:        1,
	`WeightThin`:       2,
	`weightthin`:       2,
	`Weight200`:        3,
	`weight200`:        3,
	`WeightExtraLight`: 4,
	`weightextralight`: 4,
	`Weight300`:        5,
	`weight300`:        5,
	`WeightLight`:      6,
	`weightlight`:      6,
	`Weight400`:        7,
	`weight400`:        7,
	`Weight500`:        8,
	`weight500`:        8,
	`WeightMedium`:     9,
	`weightmedium`:     9,
	`Weight600`:        10,
	`weight600`:        10,
	`WeightSemiBold`:   11,
	`weightsemibold`:   11,
	`Weight700`:        12,
	`weight700`:        12,
	`WeightBold`:       13,
	`weightbold`:       13,
	`Weight800`:        14,
	`weight800`:        14,
	`WeightExtraBold`:  15,
	`weightextrabold`:  15,
	`Weight900`:        16,
	`weight900`:        16,
	`WeightBlack`:      17,
	`weightblack`:      17,
	`WeightBolder`:     18,
	`weightbolder`:     18,
	`WeightLighter`:    19,
	`weightlighter`:    19,
}

var _FontWeightsDescMap = map[FontWeights]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
}

var _FontWeightsMap = map[FontWeights]string{
	0:  `WeightNormal`,
	1:  `Weight100`,
	2:  `WeightThin`,
	3:  `Weight200`,
	4:  `WeightExtraLight`,
	5:  `Weight300`,
	6:  `WeightLight`,
	7:  `Weight400`,
	8:  `Weight500`,
	9:  `WeightMedium`,
	10: `Weight600`,
	11: `WeightSemiBold`,
	12: `Weight700`,
	13: `WeightBold`,
	14: `Weight800`,
	15: `WeightExtraBold`,
	16: `Weight900`,
	17: `WeightBlack`,
	18: `WeightBolder`,
	19: `WeightLighter`,
}

// String returns the string representation
// of this FontWeights value.
func (i FontWeights) String() string {
	if str, ok := _FontWeightsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontWeights value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontWeights) SetString(s string) error {
	if val, ok := _FontWeightsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontWeightsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontWeights")
}

// Int64 returns the FontWeights value as an int64.
func (i FontWeights) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontWeights value from an int64.
func (i *FontWeights) SetInt64(in int64) {
	*i = FontWeights(in)
}

// Desc returns the description of the FontWeights value.
func (i FontWeights) Desc() string {
	if str, ok := _FontWeightsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontWeightsValues returns all possible values
// for the type FontWeights.
func FontWeightsValues() []FontWeights {
	return _FontWeightsValues
}

// Values returns all possible values
// for the type FontWeights.
func (i FontWeights) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontWeightsValues))
	for i, d := range _FontWeightsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontWeights.
func (i FontWeights) IsValid() bool {
	_, ok := _FontWeightsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontWeights) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontWeights) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontStretchValues = []FontStretch{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

// FontStretchN is the highest valid value
// for type FontStretch, plus one.
const FontStretchN FontStretch = 11

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontStretchNoOp() {
	var x [1]struct{}
	_ = x[FontStrNormal-(0)]
	_ = x[FontStrUltraCondensed-(1)]
	_ = x[FontStrExtraCondensed-(2)]
	_ = x[FontStrSemiCondensed-(3)]
	_ = x[FontStrSemiExpanded-(4)]
	_ = x[FontStrExtraExpanded-(5)]
	_ = x[FontStrUltraExpanded-(6)]
	_ = x[FontStrCondensed-(7)]
	_ = x[FontStrExpanded-(8)]
	_ = x[FontStrNarrower-(9)]
	_ = x[FontStrWider-(10)]
}

var _FontStretchNameToValueMap = map[string]FontStretch{
	`FontStrNormal`:         0,
	`fontstrnormal`:         0,
	`FontStrUltraCondensed`: 1,
	`fontstrultracondensed`: 1,
	`FontStrExtraCondensed`: 2,
	`fontstrextracondensed`: 2,
	`FontStrSemiCondensed`:  3,
	`fontstrsemicondensed`:  3,
	`FontStrSemiExpanded`:   4,
	`fontstrsemiexpanded`:   4,
	`FontStrExtraExpanded`:  5,
	`fontstrextraexpanded`:  5,
	`FontStrUltraExpanded`:  6,
	`fontstrultraexpanded`:  6,
	`FontStrCondensed`:      7,
	`fontstrcondensed`:      7,
	`FontStrExpanded`:       8,
	`fontstrexpanded`:       8,
	`FontStrNarrower`:       9,
	`fontstrnarrower`:       9,
	`FontStrWider`:          10,
	`fontstrwider`:          10,
}

var _FontStretchDescMap = map[FontStretch]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
}

var _FontStretchMap = map[FontStretch]string{
	0:  `FontStrNormal`,
	1:  `FontStrUltraCondensed`,
	2:  `FontStrExtraCondensed`,
	3:  `FontStrSemiCondensed`,
	4:  `FontStrSemiExpanded`,
	5:  `FontStrExtraExpanded`,
	6:  `FontStrUltraExpanded`,
	7:  `FontStrCondensed`,
	8:  `FontStrExpanded`,
	9:  `FontStrNarrower`,
	10: `FontStrWider`,
}

// String returns the string representation
// of this FontStretch value.
func (i FontStretch) String() string {
	if str, ok := _FontStretchMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontStretch value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontStretch) SetString(s string) error {
	if val, ok := _FontStretchNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontStretchNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontStretch")
}

// Int64 returns the FontStretch value as an int64.
func (i FontStretch) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontStretch value from an int64.
func (i *FontStretch) SetInt64(in int64) {
	*i = FontStretch(in)
}

// Desc returns the description of the FontStretch value.
func (i FontStretch) Desc() string {
	if str, ok := _FontStretchDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontStretchValues returns all possible values
// for the type FontStretch.
func FontStretchValues() []FontStretch {
	return _FontStretchValues
}

// Values returns all possible values
// for the type FontStretch.
func (i FontStretch) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontStretchValues))
	for i, d := range _FontStretchValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontStretch.
func (i FontStretch) IsValid() bool {
	_, ok := _FontStretchMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStretch) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStretch) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextDecorationsValues = []TextDecorations{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// TextDecorationsN is the highest valid value
// for type TextDecorations, plus one.
const TextDecorationsN TextDecorations = 10

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextDecorationsNoOp() {
	var x [1]struct{}
	_ = x[DecoNone-(0)]
	_ = x[DecoUnderline-(1)]
	_ = x[DecoOverline-(2)]
	_ = x[DecoLineThrough-(3)]
	_ = x[DecoBlink-(4)]
	_ = x[DecoDottedUnderline-(5)]
	_ = x[DecoParaStart-(6)]
	_ = x[DecoSuper-(7)]
	_ = x[DecoSub-(8)]
	_ = x[DecoBackgroundColor-(9)]
}

var _TextDecorationsNameToValueMap = map[string]TextDecorations{
	`DecoNone`:            0,
	`deconone`:            0,
	`DecoUnderline`:       1,
	`decounderline`:       1,
	`DecoOverline`:        2,
	`decooverline`:        2,
	`DecoLineThrough`:     3,
	`decolinethrough`:     3,
	`DecoBlink`:           4,
	`decoblink`:           4,
	`DecoDottedUnderline`: 5,
	`decodottedunderline`: 5,
	`DecoParaStart`:       6,
	`decoparastart`:       6,
	`DecoSuper`:           7,
	`decosuper`:           7,
	`DecoSub`:             8,
	`decosub`:             8,
	`DecoBackgroundColor`: 9,
	`decobackgroundcolor`: 9,
}

var _TextDecorationsDescMap = map[TextDecorations]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: `Blink is not currently supported (and probably a bad idea generally ;)`,
	5: `DottedUnderline is used for abbr tag -- otherwise not a standard text-decoration option afaik`,
	6: `DecoParaStart at start of a SpanRender indicates that it should be styled as the start of a new paragraph and not just the start of a new line`,
	7: `DecoSuper indicates super-scripted text`,
	8: `DecoSub indicates sub-scripted text`,
	9: `DecoBackgroundColor indicates that a bg color has been set -- for use in optimizing rendering`,
}

var _TextDecorationsMap = map[TextDecorations]string{
	0: `DecoNone`,
	1: `DecoUnderline`,
	2: `DecoOverline`,
	3: `DecoLineThrough`,
	4: `DecoBlink`,
	5: `DecoDottedUnderline`,
	6: `DecoParaStart`,
	7: `DecoSuper`,
	8: `DecoSub`,
	9: `DecoBackgroundColor`,
}

// String returns the string representation
// of this TextDecorations value.
func (i TextDecorations) String() string {
	str := ""
	for _, ie := range _TextDecorationsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TextDecorations value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TextDecorations) BitIndexString() string {
	if str, ok := _TextDecorationsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextDecorations value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextDecorations) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TextDecorations value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TextDecorations) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TextDecorationsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TextDecorationsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type TextDecorations")
		}
	}
	return nil
}

// Int64 returns the TextDecorations value as an int64.
func (i TextDecorations) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextDecorations value from an int64.
func (i *TextDecorations) SetInt64(in int64) {
	*i = TextDecorations(in)
}

// Desc returns the description of the TextDecorations value.
func (i TextDecorations) Desc() string {
	if str, ok := _TextDecorationsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextDecorationsValues returns all possible values
// for the type TextDecorations.
func TextDecorationsValues() []TextDecorations {
	return _TextDecorationsValues
}

// Values returns all possible values
// for the type TextDecorations.
func (i TextDecorations) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextDecorationsValues))
	for i, d := range _TextDecorationsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextDecorations.
func (i TextDecorations) IsValid() bool {
	_, ok := _TextDecorationsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TextDecorations) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TextDecorations) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDecorations) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDecorations) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _BaselineShiftsValues = []BaselineShifts{0, 1, 2}

// BaselineShiftsN is the highest valid value
// for type BaselineShifts, plus one.
const BaselineShiftsN BaselineShifts = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BaselineShiftsNoOp() {
	var x [1]struct{}
	_ = x[ShiftBaseline-(0)]
	_ = x[ShiftSuper-(1)]
	_ = x[ShiftSub-(2)]
}

var _BaselineShiftsNameToValueMap = map[string]BaselineShifts{
	`ShiftBaseline`: 0,
	`shiftbaseline`: 0,
	`ShiftSuper`:    1,
	`shiftsuper`:    1,
	`ShiftSub`:      2,
	`shiftsub`:      2,
}

var _BaselineShiftsDescMap = map[BaselineShifts]string{
	0: ``,
	1: ``,
	2: ``,
}

var _BaselineShiftsMap = map[BaselineShifts]string{
	0: `ShiftBaseline`,
	1: `ShiftSuper`,
	2: `ShiftSub`,
}

// String returns the string representation
// of this BaselineShifts value.
func (i BaselineShifts) String() string {
	if str, ok := _BaselineShiftsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BaselineShifts value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BaselineShifts) SetString(s string) error {
	if val, ok := _BaselineShiftsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BaselineShiftsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BaselineShifts")
}

// Int64 returns the BaselineShifts value as an int64.
func (i BaselineShifts) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BaselineShifts value from an int64.
func (i *BaselineShifts) SetInt64(in int64) {
	*i = BaselineShifts(in)
}

// Desc returns the description of the BaselineShifts value.
func (i BaselineShifts) Desc() string {
	if str, ok := _BaselineShiftsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BaselineShiftsValues returns all possible values
// for the type BaselineShifts.
func BaselineShiftsValues() []BaselineShifts {
	return _BaselineShiftsValues
}

// Values returns all possible values
// for the type BaselineShifts.
func (i BaselineShifts) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BaselineShiftsValues))
	for i, d := range _BaselineShiftsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BaselineShifts.
func (i BaselineShifts) IsValid() bool {
	_, ok := _BaselineShiftsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BaselineShifts) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BaselineShifts) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontVariantsValues = []FontVariants{0, 1}

// FontVariantsN is the highest valid value
// for type FontVariants, plus one.
const FontVariantsN FontVariants = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontVariantsNoOp() {
	var x [1]struct{}
	_ = x[FontVarNormal-(0)]
	_ = x[FontVarSmallCaps-(1)]
}

var _FontVariantsNameToValueMap = map[string]FontVariants{
	`FontVarNormal`:    0,
	`fontvarnormal`:    0,
	`FontVarSmallCaps`: 1,
	`fontvarsmallcaps`: 1,
}

var _FontVariantsDescMap = map[FontVariants]string{
	0: ``,
	1: ``,
}

var _FontVariantsMap = map[FontVariants]string{
	0: `FontVarNormal`,
	1: `FontVarSmallCaps`,
}

// String returns the string representation
// of this FontVariants value.
func (i FontVariants) String() string {
	if str, ok := _FontVariantsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontVariants value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontVariants) SetString(s string) error {
	if val, ok := _FontVariantsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontVariantsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontVariants")
}

// Int64 returns the FontVariants value as an int64.
func (i FontVariants) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontVariants value from an int64.
func (i *FontVariants) SetInt64(in int64) {
	*i = FontVariants(in)
}

// Desc returns the description of the FontVariants value.
func (i FontVariants) Desc() string {
	if str, ok := _FontVariantsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontVariantsValues returns all possible values
// for the type FontVariants.
func FontVariantsValues() []FontVariants {
	return _FontVariantsValues
}

// Values returns all possible values
// for the type FontVariants.
func (i FontVariants) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontVariantsValues))
	for i, d := range _FontVariantsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontVariants.
func (i FontVariants) IsValid() bool {
	_, ok := _FontVariantsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontVariants) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontVariants) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _AlignValues = []Align{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}

// AlignN is the highest valid value
// for type Align, plus one.
const AlignN Align = 15

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _AlignNoOp() {
	var x [1]struct{}
	_ = x[AlignLeft-(0)]
	_ = x[AlignTop-(1)]
	_ = x[AlignCenter-(2)]
	_ = x[AlignMiddle-(3)]
	_ = x[AlignRight-(4)]
	_ = x[AlignBottom-(5)]
	_ = x[AlignBaseline-(6)]
	_ = x[AlignJustify-(7)]
	_ = x[AlignSpaceAround-(8)]
	_ = x[AlignFlexStart-(9)]
	_ = x[AlignFlexEnd-(10)]
	_ = x[AlignTextTop-(11)]
	_ = x[AlignTextBottom-(12)]
	_ = x[AlignSub-(13)]
	_ = x[AlignSuper-(14)]
}

var _AlignNameToValueMap = map[string]Align{
	`AlignLeft`:        0,
	`alignleft`:        0,
	`AlignTop`:         1,
	`aligntop`:         1,
	`AlignCenter`:      2,
	`aligncenter`:      2,
	`AlignMiddle`:      3,
	`alignmiddle`:      3,
	`AlignRight`:       4,
	`alignright`:       4,
	`AlignBottom`:      5,
	`alignbottom`:      5,
	`AlignBaseline`:    6,
	`alignbaseline`:    6,
	`AlignJustify`:     7,
	`alignjustify`:     7,
	`AlignSpaceAround`: 8,
	`alignspacearound`: 8,
	`AlignFlexStart`:   9,
	`alignflexstart`:   9,
	`AlignFlexEnd`:     10,
	`alignflexend`:     10,
	`AlignTextTop`:     11,
	`aligntexttop`:     11,
	`AlignTextBottom`:  12,
	`aligntextbottom`:  12,
	`AlignSub`:         13,
	`alignsub`:         13,
	`AlignSuper`:       14,
	`alignsuper`:       14,
}

var _AlignDescMap = map[Align]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  `middle = vertical version of center`,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  `same as CSS space-between`,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: `align to subscript`,
	14: `align to superscript`,
}

var _AlignMap = map[Align]string{
	0:  `AlignLeft`,
	1:  `AlignTop`,
	2:  `AlignCenter`,
	3:  `AlignMiddle`,
	4:  `AlignRight`,
	5:  `AlignBottom`,
	6:  `AlignBaseline`,
	7:  `AlignJustify`,
	8:  `AlignSpaceAround`,
	9:  `AlignFlexStart`,
	10: `AlignFlexEnd`,
	11: `AlignTextTop`,
	12: `AlignTextBottom`,
	13: `AlignSub`,
	14: `AlignSuper`,
}

// String returns the string representation
// of this Align value.
func (i Align) String() string {
	if str, ok := _AlignMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Align value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Align) SetString(s string) error {
	if val, ok := _AlignNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _AlignNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Align")
}

// Int64 returns the Align value as an int64.
func (i Align) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Align value from an int64.
func (i *Align) SetInt64(in int64) {
	*i = Align(in)
}

// Desc returns the description of the Align value.
func (i Align) Desc() string {
	if str, ok := _AlignDescMap[i]; ok {
		return str
	}
	return i.String()
}

// AlignValues returns all possible values
// for the type Align.
func AlignValues() []Align {
	return _AlignValues
}

// Values returns all possible values
// for the type Align.
func (i Align) Values() []enums.Enum {
	res := make([]enums.Enum, len(_AlignValues))
	for i, d := range _AlignValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Align.
func (i Align) IsValid() bool {
	_, ok := _AlignMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Align) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Align) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _OverflowValues = []Overflow{0, 1, 2, 3}

// OverflowN is the highest valid value
// for type Overflow, plus one.
const OverflowN Overflow = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _OverflowNoOp() {
	var x [1]struct{}
	_ = x[OverflowAuto-(0)]
	_ = x[OverflowScroll-(1)]
	_ = x[OverflowVisible-(2)]
	_ = x[OverflowHidden-(3)]
}

var _OverflowNameToValueMap = map[string]Overflow{
	`OverflowAuto`:    0,
	`overflowauto`:    0,
	`OverflowScroll`:  1,
	`overflowscroll`:  1,
	`OverflowVisible`: 2,
	`overflowvisible`: 2,
	`OverflowHidden`:  3,
	`overflowhidden`:  3,
}

var _OverflowDescMap = map[Overflow]string{
	0: `OverflowAuto automatically determines if scrollbars should be added to show the overflow. Scrollbars are added only if the actual content size is greater than the currently available size. Typically, an outer-most Layout will scale up and add scrollbars to accommodate the Min needs of its child elements, so if you want to have scrollbars show up on inner elements, they need to have a style setting that restricts their Min size, but also allows them to stretch so they use whatever space they are allocated.`,
	1: `OverflowScroll means add scrollbars when necessary, and is essentially identical to Auto. However, only during Viewport PrefSize call, the actual content size is used -- otherwise it behaves just like Auto.`,
	2: `OverflowVisible makes the overflow visible -- this is generally unsafe and not very feasible and will be ignored as long as possible. Currently it falls back on Auto, but could go to Hidden if that works better overall.`,
	3: `OverflowHidden hides the overflow and doesn&#39;t present scrollbars (supported).`,
}

var _OverflowMap = map[Overflow]string{
	0: `OverflowAuto`,
	1: `OverflowScroll`,
	2: `OverflowVisible`,
	3: `OverflowHidden`,
}

// String returns the string representation
// of this Overflow value.
func (i Overflow) String() string {
	if str, ok := _OverflowMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Overflow value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Overflow) SetString(s string) error {
	if val, ok := _OverflowNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _OverflowNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Overflow")
}

// Int64 returns the Overflow value as an int64.
func (i Overflow) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Overflow value from an int64.
func (i *Overflow) SetInt64(in int64) {
	*i = Overflow(in)
}

// Desc returns the description of the Overflow value.
func (i Overflow) Desc() string {
	if str, ok := _OverflowDescMap[i]; ok {
		return str
	}
	return i.String()
}

// OverflowValues returns all possible values
// for the type Overflow.
func OverflowValues() []Overflow {
	return _OverflowValues
}

// Values returns all possible values
// for the type Overflow.
func (i Overflow) Values() []enums.Enum {
	res := make([]enums.Enum, len(_OverflowValues))
	for i, d := range _OverflowValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Overflow.
func (i Overflow) IsValid() bool {
	_, ok := _OverflowMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Overflow) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Overflow) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FillRulesValues = []FillRules{0, 1}

// FillRulesN is the highest valid value
// for type FillRules, plus one.
const FillRulesN FillRules = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FillRulesNoOp() {
	var x [1]struct{}
	_ = x[FillRuleNonZero-(0)]
	_ = x[FillRuleEvenOdd-(1)]
}

var _FillRulesNameToValueMap = map[string]FillRules{
	`FillRuleNonZero`: 0,
	`fillrulenonzero`: 0,
	`FillRuleEvenOdd`: 1,
	`fillruleevenodd`: 1,
}

var _FillRulesDescMap = map[FillRules]string{
	0: ``,
	1: ``,
}

var _FillRulesMap = map[FillRules]string{
	0: `FillRuleNonZero`,
	1: `FillRuleEvenOdd`,
}

// String returns the string representation
// of this FillRules value.
func (i FillRules) String() string {
	if str, ok := _FillRulesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FillRules value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FillRules) SetString(s string) error {
	if val, ok := _FillRulesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FillRulesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FillRules")
}

// Int64 returns the FillRules value as an int64.
func (i FillRules) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FillRules value from an int64.
func (i *FillRules) SetInt64(in int64) {
	*i = FillRules(in)
}

// Desc returns the description of the FillRules value.
func (i FillRules) Desc() string {
	if str, ok := _FillRulesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FillRulesValues returns all possible values
// for the type FillRules.
func FillRulesValues() []FillRules {
	return _FillRulesValues
}

// Values returns all possible values
// for the type FillRules.
func (i FillRules) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FillRulesValues))
	for i, d := range _FillRulesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FillRules.
func (i FillRules) IsValid() bool {
	_, ok := _FillRulesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FillRules) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FillRules) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _VectorEffectsValues = []VectorEffects{0, 1}

// VectorEffectsN is the highest valid value
// for type VectorEffects, plus one.
const VectorEffectsN VectorEffects = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _VectorEffectsNoOp() {
	var x [1]struct{}
	_ = x[VecEffNone-(0)]
	_ = x[VecEffNonScalingStroke-(1)]
}

var _VectorEffectsNameToValueMap = map[string]VectorEffects{
	`VecEffNone`:             0,
	`veceffnone`:             0,
	`VecEffNonScalingStroke`: 1,
	`veceffnonscalingstroke`: 1,
}

var _VectorEffectsDescMap = map[VectorEffects]string{
	0: ``,
	1: `VecEffNonScalingStroke means that the stroke width is not affected by transform properties`,
}

var _VectorEffectsMap = map[VectorEffects]string{
	0: `VecEffNone`,
	1: `VecEffNonScalingStroke`,
}

// String returns the string representation
// of this VectorEffects value.
func (i VectorEffects) String() string {
	if str, ok := _VectorEffectsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the VectorEffects value from its
// string representation, and returns an
// error if the string is invalid.
func (i *VectorEffects) SetString(s string) error {
	if val, ok := _VectorEffectsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _VectorEffectsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type VectorEffects")
}

// Int64 returns the VectorEffects value as an int64.
func (i VectorEffects) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the VectorEffects value from an int64.
func (i *VectorEffects) SetInt64(in int64) {
	*i = VectorEffects(in)
}

// Desc returns the description of the VectorEffects value.
func (i VectorEffects) Desc() string {
	if str, ok := _VectorEffectsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// VectorEffectsValues returns all possible values
// for the type VectorEffects.
func VectorEffectsValues() []VectorEffects {
	return _VectorEffectsValues
}

// Values returns all possible values
// for the type VectorEffects.
func (i VectorEffects) Values() []enums.Enum {
	res := make([]enums.Enum, len(_VectorEffectsValues))
	for i, d := range _VectorEffectsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type VectorEffects.
func (i VectorEffects) IsValid() bool {
	_, ok := _VectorEffectsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VectorEffects) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VectorEffects) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LineCapsValues = []LineCaps{0, 1, 2, 3, 4}

// LineCapsN is the highest valid value
// for type LineCaps, plus one.
const LineCapsN LineCaps = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LineCapsNoOp() {
	var x [1]struct{}
	_ = x[LineCapButt-(0)]
	_ = x[LineCapRound-(1)]
	_ = x[LineCapSquare-(2)]
	_ = x[LineCapCubic-(3)]
	_ = x[LineCapQuadratic-(4)]
}

var _LineCapsNameToValueMap = map[string]LineCaps{
	`LineCapButt`:      0,
	`linecapbutt`:      0,
	`LineCapRound`:     1,
	`linecapround`:     1,
	`LineCapSquare`:    2,
	`linecapsquare`:    2,
	`LineCapCubic`:     3,
	`linecapcubic`:     3,
	`LineCapQuadratic`: 4,
	`linecapquadratic`: 4,
}

var _LineCapsDescMap = map[LineCaps]string{
	0: ``,
	1: ``,
	2: ``,
	3: `rasterx extension`,
	4: `rasterx extension`,
}

var _LineCapsMap = map[LineCaps]string{
	0: `LineCapButt`,
	1: `LineCapRound`,
	2: `LineCapSquare`,
	3: `LineCapCubic`,
	4: `LineCapQuadratic`,
}

// String returns the string representation
// of this LineCaps value.
func (i LineCaps) String() string {
	if str, ok := _LineCapsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the LineCaps value from its
// string representation, and returns an
// error if the string is invalid.
func (i *LineCaps) SetString(s string) error {
	if val, ok := _LineCapsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LineCapsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type LineCaps")
}

// Int64 returns the LineCaps value as an int64.
func (i LineCaps) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the LineCaps value from an int64.
func (i *LineCaps) SetInt64(in int64) {
	*i = LineCaps(in)
}

// Desc returns the description of the LineCaps value.
func (i LineCaps) Desc() string {
	if str, ok := _LineCapsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LineCapsValues returns all possible values
// for the type LineCaps.
func LineCapsValues() []LineCaps {
	return _LineCapsValues
}

// Values returns all possible values
// for the type LineCaps.
func (i LineCaps) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LineCapsValues))
	for i, d := range _LineCapsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type LineCaps.
func (i LineCaps) IsValid() bool {
	_, ok := _LineCapsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineCaps) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineCaps) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LineJoinsValues = []LineJoins{0, 1, 2, 3, 4, 5}

// LineJoinsN is the highest valid value
// for type LineJoins, plus one.
const LineJoinsN LineJoins = 6

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LineJoinsNoOp() {
	var x [1]struct{}
	_ = x[LineJoinMiter-(0)]
	_ = x[LineJoinMiterClip-(1)]
	_ = x[LineJoinRound-(2)]
	_ = x[LineJoinBevel-(3)]
	_ = x[LineJoinArcs-(4)]
	_ = x[LineJoinArcsClip-(5)]
}

var _LineJoinsNameToValueMap = map[string]LineJoins{
	`LineJoinMiter`:     0,
	`linejoinmiter`:     0,
	`LineJoinMiterClip`: 1,
	`linejoinmiterclip`: 1,
	`LineJoinRound`:     2,
	`linejoinround`:     2,
	`LineJoinBevel`:     3,
	`linejoinbevel`:     3,
	`LineJoinArcs`:      4,
	`linejoinarcs`:      4,
	`LineJoinArcsClip`:  5,
	`linejoinarcsclip`:  5,
}

var _LineJoinsDescMap = map[LineJoins]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: `rasterx extension`,
}

var _LineJoinsMap = map[LineJoins]string{
	0: `LineJoinMiter`,
	1: `LineJoinMiterClip`,
	2: `LineJoinRound`,
	3: `LineJoinBevel`,
	4: `LineJoinArcs`,
	5: `LineJoinArcsClip`,
}

// String returns the string representation
// of this LineJoins value.
func (i LineJoins) String() string {
	if str, ok := _LineJoinsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the LineJoins value from its
// string representation, and returns an
// error if the string is invalid.
func (i *LineJoins) SetString(s string) error {
	if val, ok := _LineJoinsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LineJoinsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type LineJoins")
}

// Int64 returns the LineJoins value as an int64.
func (i LineJoins) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the LineJoins value from an int64.
func (i *LineJoins) SetInt64(in int64) {
	*i = LineJoins(in)
}

// Desc returns the description of the LineJoins value.
func (i LineJoins) Desc() string {
	if str, ok := _LineJoinsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LineJoinsValues returns all possible values
// for the type LineJoins.
func LineJoinsValues() []LineJoins {
	return _LineJoinsValues
}

// Values returns all possible values
// for the type LineJoins.
func (i LineJoins) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LineJoinsValues))
	for i, d := range _LineJoinsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type LineJoins.
func (i LineJoins) IsValid() bool {
	_, ok := _LineJoinsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineJoins) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineJoins) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _UnicodeBidiValues = []UnicodeBidi{0, 1, 2}

// UnicodeBidiN is the highest valid value
// for type UnicodeBidi, plus one.
const UnicodeBidiN UnicodeBidi = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _UnicodeBidiNoOp() {
	var x [1]struct{}
	_ = x[BidiNormal-(0)]
	_ = x[BidiEmbed-(1)]
	_ = x[BidiBidiOverride-(2)]
}

var _UnicodeBidiNameToValueMap = map[string]UnicodeBidi{
	`BidiNormal`:       0,
	`bidinormal`:       0,
	`BidiEmbed`:        1,
	`bidiembed`:        1,
	`BidiBidiOverride`: 2,
	`bidibidioverride`: 2,
}

var _UnicodeBidiDescMap = map[UnicodeBidi]string{
	0: ``,
	1: ``,
	2: ``,
}

var _UnicodeBidiMap = map[UnicodeBidi]string{
	0: `BidiNormal`,
	1: `BidiEmbed`,
	2: `BidiBidiOverride`,
}

// String returns the string representation
// of this UnicodeBidi value.
func (i UnicodeBidi) String() string {
	if str, ok := _UnicodeBidiMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the UnicodeBidi value from its
// string representation, and returns an
// error if the string is invalid.
func (i *UnicodeBidi) SetString(s string) error {
	if val, ok := _UnicodeBidiNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _UnicodeBidiNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type UnicodeBidi")
}

// Int64 returns the UnicodeBidi value as an int64.
func (i UnicodeBidi) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the UnicodeBidi value from an int64.
func (i *UnicodeBidi) SetInt64(in int64) {
	*i = UnicodeBidi(in)
}

// Desc returns the description of the UnicodeBidi value.
func (i UnicodeBidi) Desc() string {
	if str, ok := _UnicodeBidiDescMap[i]; ok {
		return str
	}
	return i.String()
}

// UnicodeBidiValues returns all possible values
// for the type UnicodeBidi.
func UnicodeBidiValues() []UnicodeBidi {
	return _UnicodeBidiValues
}

// Values returns all possible values
// for the type UnicodeBidi.
func (i UnicodeBidi) Values() []enums.Enum {
	res := make([]enums.Enum, len(_UnicodeBidiValues))
	for i, d := range _UnicodeBidiValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type UnicodeBidi.
func (i UnicodeBidi) IsValid() bool {
	_, ok := _UnicodeBidiMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i UnicodeBidi) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *UnicodeBidi) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextDirectionsValues = []TextDirections{0, 1, 2, 3, 4, 5, 6, 7}

// TextDirectionsN is the highest valid value
// for type TextDirections, plus one.
const TextDirectionsN TextDirections = 8

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextDirectionsNoOp() {
	var x [1]struct{}
	_ = x[LRTB-(0)]
	_ = x[RLTB-(1)]
	_ = x[TBRL-(2)]
	_ = x[LR-(3)]
	_ = x[RL-(4)]
	_ = x[TB-(5)]
	_ = x[LTR-(6)]
	_ = x[RTL-(7)]
}

var _TextDirectionsNameToValueMap = map[string]TextDirections{
	`LRTB`: 0,
	`lrtb`: 0,
	`RLTB`: 1,
	`rltb`: 1,
	`TBRL`: 2,
	`tbrl`: 2,
	`LR`:   3,
	`lr`:   3,
	`RL`:   4,
	`rl`:   4,
	`TB`:   5,
	`tb`:   5,
	`LTR`:  6,
	`ltr`:  6,
	`RTL`:  7,
	`rtl`:  7,
}

var _TextDirectionsDescMap = map[TextDirections]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
}

var _TextDirectionsMap = map[TextDirections]string{
	0: `LRTB`,
	1: `RLTB`,
	2: `TBRL`,
	3: `LR`,
	4: `RL`,
	5: `TB`,
	6: `LTR`,
	7: `RTL`,
}

// String returns the string representation
// of this TextDirections value.
func (i TextDirections) String() string {
	if str, ok := _TextDirectionsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextDirections value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextDirections) SetString(s string) error {
	if val, ok := _TextDirectionsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextDirectionsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextDirections")
}

// Int64 returns the TextDirections value as an int64.
func (i TextDirections) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextDirections value from an int64.
func (i *TextDirections) SetInt64(in int64) {
	*i = TextDirections(in)
}

// Desc returns the description of the TextDirections value.
func (i TextDirections) Desc() string {
	if str, ok := _TextDirectionsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextDirectionsValues returns all possible values
// for the type TextDirections.
func TextDirectionsValues() []TextDirections {
	return _TextDirectionsValues
}

// Values returns all possible values
// for the type TextDirections.
func (i TextDirections) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextDirectionsValues))
	for i, d := range _TextDirectionsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextDirections.
func (i TextDirections) IsValid() bool {
	_, ok := _TextDirectionsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDirections) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDirections) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextAnchorsValues = []TextAnchors{0, 1, 2}

// TextAnchorsN is the highest valid value
// for type TextAnchors, plus one.
const TextAnchorsN TextAnchors = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextAnchorsNoOp() {
	var x [1]struct{}
	_ = x[AnchorStart-(0)]
	_ = x[AnchorMiddle-(1)]
	_ = x[AnchorEnd-(2)]
}

var _TextAnchorsNameToValueMap = map[string]TextAnchors{
	`AnchorStart`:  0,
	`anchorstart`:  0,
	`AnchorMiddle`: 1,
	`anchormiddle`: 1,
	`AnchorEnd`:    2,
	`anchorend`:    2,
}

var _TextAnchorsDescMap = map[TextAnchors]string{
	0: ``,
	1: ``,
	2: ``,
}

var _TextAnchorsMap = map[TextAnchors]string{
	0: `AnchorStart`,
	1: `AnchorMiddle`,
	2: `AnchorEnd`,
}

// String returns the string representation
// of this TextAnchors value.
func (i TextAnchors) String() string {
	if str, ok := _TextAnchorsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextAnchors value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextAnchors) SetString(s string) error {
	if val, ok := _TextAnchorsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextAnchorsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextAnchors")
}

// Int64 returns the TextAnchors value as an int64.
func (i TextAnchors) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextAnchors value from an int64.
func (i *TextAnchors) SetInt64(in int64) {
	*i = TextAnchors(in)
}

// Desc returns the description of the TextAnchors value.
func (i TextAnchors) Desc() string {
	if str, ok := _TextAnchorsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextAnchorsValues returns all possible values
// for the type TextAnchors.
func TextAnchorsValues() []TextAnchors {
	return _TextAnchorsValues
}

// Values returns all possible values
// for the type TextAnchors.
func (i TextAnchors) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextAnchorsValues))
	for i, d := range _TextAnchorsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextAnchors.
func (i TextAnchors) IsValid() bool {
	_, ok := _TextAnchorsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextAnchors) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextAnchors) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _WhiteSpacesValues = []WhiteSpaces{0, 1, 2, 3, 4}

// WhiteSpacesN is the highest valid value
// for type WhiteSpaces, plus one.
const WhiteSpacesN WhiteSpaces = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _WhiteSpacesNoOp() {
	var x [1]struct{}
	_ = x[WhiteSpaceNormal-(0)]
	_ = x[WhiteSpaceNowrap-(1)]
	_ = x[WhiteSpacePre-(2)]
	_ = x[WhiteSpacePreLine-(3)]
	_ = x[WhiteSpacePreWrap-(4)]
}

var _WhiteSpacesNameToValueMap = map[string]WhiteSpaces{
	`WhiteSpaceNormal`:  0,
	`whitespacenormal`:  0,
	`WhiteSpaceNowrap`:  1,
	`whitespacenowrap`:  1,
	`WhiteSpacePre`:     2,
	`whitespacepre`:     2,
	`WhiteSpacePreLine`: 3,
	`whitespacepreline`: 3,
	`WhiteSpacePreWrap`: 4,
	`whitespaceprewrap`: 4,
}

var _WhiteSpacesDescMap = map[WhiteSpaces]string{
	0: `WhiteSpaceNormal means that all white space is collapsed to a single space, and text wraps when necessary`,
	1: `WhiteSpaceNowrap means that sequences of whitespace will collapse into a single whitespace. Text will never wrap to the next line. The text continues on the same line until a &lt;br&gt; tag is encountered`,
	2: `WhiteSpacePre means that whitespace is preserved by the browser. Text will only wrap on line breaks. Acts like the &lt;pre&gt; tag in HTML. This invokes a different hand-written parser because the default golang parser automatically throws away whitespace`,
	3: `WhiteSpacePreLine means that sequences of whitespace will collapse into a single whitespace. Text will wrap when necessary, and on line breaks`,
	4: `WhiteSpacePreWrap means that whitespace is preserved by the browser. Text will wrap when necessary, and on line breaks`,
}

var _WhiteSpacesMap = map[WhiteSpaces]string{
	0: `WhiteSpaceNormal`,
	1: `WhiteSpaceNowrap`,
	2: `WhiteSpacePre`,
	3: `WhiteSpacePreLine`,
	4: `WhiteSpacePreWrap`,
}

// String returns the string representation
// of this WhiteSpaces value.
func (i WhiteSpaces) String() string {
	if str, ok := _WhiteSpacesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the WhiteSpaces value from its
// string representation, and returns an
// error if the string is invalid.
func (i *WhiteSpaces) SetString(s string) error {
	if val, ok := _WhiteSpacesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _WhiteSpacesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type WhiteSpaces")
}

// Int64 returns the WhiteSpaces value as an int64.
func (i WhiteSpaces) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the WhiteSpaces value from an int64.
func (i *WhiteSpaces) SetInt64(in int64) {
	*i = WhiteSpaces(in)
}

// Desc returns the description of the WhiteSpaces value.
func (i WhiteSpaces) Desc() string {
	if str, ok := _WhiteSpacesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// WhiteSpacesValues returns all possible values
// for the type WhiteSpaces.
func WhiteSpacesValues() []WhiteSpaces {
	return _WhiteSpacesValues
}

// Values returns all possible values
// for the type WhiteSpaces.
func (i WhiteSpaces) Values() []enums.Enum {
	res := make([]enums.Enum, len(_WhiteSpacesValues))
	for i, d := range _WhiteSpacesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type WhiteSpaces.
func (i WhiteSpaces) IsValid() bool {
	_, ok := _WhiteSpacesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WhiteSpaces) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WhiteSpaces) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
