// Code generated by "goki generate"; DO NOT EDIT.

package styles

import (
	"errors"
	"strconv"
	"strings"
	"sync/atomic"

	"goki.dev/enums"
)

var _BorderStylesValues = []BorderStyles{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// BorderStylesN is the highest valid value
// for type BorderStyles, plus one.
const BorderStylesN BorderStyles = 10

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BorderStylesNoOp() {
	var x [1]struct{}
	_ = x[BorderSolid-(0)]
	_ = x[BorderDotted-(1)]
	_ = x[BorderDashed-(2)]
	_ = x[BorderDouble-(3)]
	_ = x[BorderGroove-(4)]
	_ = x[BorderRidge-(5)]
	_ = x[BorderInset-(6)]
	_ = x[BorderOutset-(7)]
	_ = x[BorderNone-(8)]
	_ = x[BorderHidden-(9)]
}

var _BorderStylesNameToValueMap = map[string]BorderStyles{
	`Solid`:  0,
	`solid`:  0,
	`Dotted`: 1,
	`dotted`: 1,
	`Dashed`: 2,
	`dashed`: 2,
	`Double`: 3,
	`double`: 3,
	`Groove`: 4,
	`groove`: 4,
	`Ridge`:  5,
	`ridge`:  5,
	`Inset`:  6,
	`inset`:  6,
	`Outset`: 7,
	`outset`: 7,
	`None`:   8,
	`none`:   8,
	`Hidden`: 9,
	`hidden`: 9,
}

var _BorderStylesDescMap = map[BorderStyles]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
	8: ``,
	9: ``,
}

var _BorderStylesMap = map[BorderStyles]string{
	0: `Solid`,
	1: `Dotted`,
	2: `Dashed`,
	3: `Double`,
	4: `Groove`,
	5: `Ridge`,
	6: `Inset`,
	7: `Outset`,
	8: `None`,
	9: `Hidden`,
}

// String returns the string representation
// of this BorderStyles value.
func (i BorderStyles) String() string {
	if str, ok := _BorderStylesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BorderStyles value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BorderStyles) SetString(s string) error {
	if val, ok := _BorderStylesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BorderStylesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BorderStyles")
}

// Int64 returns the BorderStyles value as an int64.
func (i BorderStyles) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BorderStyles value from an int64.
func (i *BorderStyles) SetInt64(in int64) {
	*i = BorderStyles(in)
}

// Desc returns the description of the BorderStyles value.
func (i BorderStyles) Desc() string {
	if str, ok := _BorderStylesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BorderStylesValues returns all possible values
// for the type BorderStyles.
func BorderStylesValues() []BorderStyles {
	return _BorderStylesValues
}

// Values returns all possible values
// for the type BorderStyles.
func (i BorderStyles) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BorderStylesValues))
	for i, d := range _BorderStylesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BorderStyles.
func (i BorderStyles) IsValid() bool {
	_, ok := _BorderStylesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BorderStyles) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BorderStyles) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontStylesValues = []FontStyles{0, 1, 2}

// FontStylesN is the highest valid value
// for type FontStyles, plus one.
const FontStylesN FontStyles = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontStylesNoOp() {
	var x [1]struct{}
	_ = x[FontNormal-(0)]
	_ = x[FontItalic-(1)]
	_ = x[FontOblique-(2)]
}

var _FontStylesNameToValueMap = map[string]FontStyles{
	`Normal`:  0,
	`normal`:  0,
	`Italic`:  1,
	`italic`:  1,
	`Oblique`: 2,
	`oblique`: 2,
}

var _FontStylesDescMap = map[FontStyles]string{
	0: ``,
	1: ``,
	2: ``,
}

var _FontStylesMap = map[FontStyles]string{
	0: `Normal`,
	1: `Italic`,
	2: `Oblique`,
}

// String returns the string representation
// of this FontStyles value.
func (i FontStyles) String() string {
	if str, ok := _FontStylesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontStyles value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontStyles) SetString(s string) error {
	if val, ok := _FontStylesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontStylesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontStyles")
}

// Int64 returns the FontStyles value as an int64.
func (i FontStyles) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontStyles value from an int64.
func (i *FontStyles) SetInt64(in int64) {
	*i = FontStyles(in)
}

// Desc returns the description of the FontStyles value.
func (i FontStyles) Desc() string {
	if str, ok := _FontStylesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontStylesValues returns all possible values
// for the type FontStyles.
func FontStylesValues() []FontStyles {
	return _FontStylesValues
}

// Values returns all possible values
// for the type FontStyles.
func (i FontStyles) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontStylesValues))
	for i, d := range _FontStylesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontStyles.
func (i FontStyles) IsValid() bool {
	_, ok := _FontStylesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStyles) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStyles) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontWeightsValues = []FontWeights{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}

// FontWeightsN is the highest valid value
// for type FontWeights, plus one.
const FontWeightsN FontWeights = 20

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontWeightsNoOp() {
	var x [1]struct{}
	_ = x[WeightNormal-(0)]
	_ = x[Weight100-(1)]
	_ = x[WeightThin-(2)]
	_ = x[Weight200-(3)]
	_ = x[WeightExtraLight-(4)]
	_ = x[Weight300-(5)]
	_ = x[WeightLight-(6)]
	_ = x[Weight400-(7)]
	_ = x[Weight500-(8)]
	_ = x[WeightMedium-(9)]
	_ = x[Weight600-(10)]
	_ = x[WeightSemiBold-(11)]
	_ = x[Weight700-(12)]
	_ = x[WeightBold-(13)]
	_ = x[Weight800-(14)]
	_ = x[WeightExtraBold-(15)]
	_ = x[Weight900-(16)]
	_ = x[WeightBlack-(17)]
	_ = x[WeightBolder-(18)]
	_ = x[WeightLighter-(19)]
}

var _FontWeightsNameToValueMap = map[string]FontWeights{
	`Normal`:     0,
	`normal`:     0,
	`100`:        1,
	`Thin`:       2,
	`thin`:       2,
	`200`:        3,
	`ExtraLight`: 4,
	`extralight`: 4,
	`300`:        5,
	`Light`:      6,
	`light`:      6,
	`400`:        7,
	`500`:        8,
	`Medium`:     9,
	`medium`:     9,
	`600`:        10,
	`SemiBold`:   11,
	`semibold`:   11,
	`700`:        12,
	`Bold`:       13,
	`bold`:       13,
	`800`:        14,
	`ExtraBold`:  15,
	`extrabold`:  15,
	`900`:        16,
	`Black`:      17,
	`black`:      17,
	`Bolder`:     18,
	`bolder`:     18,
	`Lighter`:    19,
	`lighter`:    19,
}

var _FontWeightsDescMap = map[FontWeights]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
	11: ``,
	12: ``,
	13: ``,
	14: ``,
	15: ``,
	16: ``,
	17: ``,
	18: ``,
	19: ``,
}

var _FontWeightsMap = map[FontWeights]string{
	0:  `Normal`,
	1:  `100`,
	2:  `Thin`,
	3:  `200`,
	4:  `ExtraLight`,
	5:  `300`,
	6:  `Light`,
	7:  `400`,
	8:  `500`,
	9:  `Medium`,
	10: `600`,
	11: `SemiBold`,
	12: `700`,
	13: `Bold`,
	14: `800`,
	15: `ExtraBold`,
	16: `900`,
	17: `Black`,
	18: `Bolder`,
	19: `Lighter`,
}

// String returns the string representation
// of this FontWeights value.
func (i FontWeights) String() string {
	if str, ok := _FontWeightsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontWeights value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontWeights) SetString(s string) error {
	if val, ok := _FontWeightsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontWeightsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontWeights")
}

// Int64 returns the FontWeights value as an int64.
func (i FontWeights) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontWeights value from an int64.
func (i *FontWeights) SetInt64(in int64) {
	*i = FontWeights(in)
}

// Desc returns the description of the FontWeights value.
func (i FontWeights) Desc() string {
	if str, ok := _FontWeightsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontWeightsValues returns all possible values
// for the type FontWeights.
func FontWeightsValues() []FontWeights {
	return _FontWeightsValues
}

// Values returns all possible values
// for the type FontWeights.
func (i FontWeights) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontWeightsValues))
	for i, d := range _FontWeightsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontWeights.
func (i FontWeights) IsValid() bool {
	_, ok := _FontWeightsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontWeights) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontWeights) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontStretchValues = []FontStretch{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

// FontStretchN is the highest valid value
// for type FontStretch, plus one.
const FontStretchN FontStretch = 11

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontStretchNoOp() {
	var x [1]struct{}
	_ = x[FontStrNormal-(0)]
	_ = x[FontStrUltraCondensed-(1)]
	_ = x[FontStrExtraCondensed-(2)]
	_ = x[FontStrSemiCondensed-(3)]
	_ = x[FontStrSemiExpanded-(4)]
	_ = x[FontStrExtraExpanded-(5)]
	_ = x[FontStrUltraExpanded-(6)]
	_ = x[FontStrCondensed-(7)]
	_ = x[FontStrExpanded-(8)]
	_ = x[FontStrNarrower-(9)]
	_ = x[FontStrWider-(10)]
}

var _FontStretchNameToValueMap = map[string]FontStretch{
	`Normal`:         0,
	`normal`:         0,
	`UltraCondensed`: 1,
	`ultracondensed`: 1,
	`ExtraCondensed`: 2,
	`extracondensed`: 2,
	`SemiCondensed`:  3,
	`semicondensed`:  3,
	`SemiExpanded`:   4,
	`semiexpanded`:   4,
	`ExtraExpanded`:  5,
	`extraexpanded`:  5,
	`UltraExpanded`:  6,
	`ultraexpanded`:  6,
	`Condensed`:      7,
	`condensed`:      7,
	`Expanded`:       8,
	`expanded`:       8,
	`Narrower`:       9,
	`narrower`:       9,
	`Wider`:          10,
	`wider`:          10,
}

var _FontStretchDescMap = map[FontStretch]string{
	0:  ``,
	1:  ``,
	2:  ``,
	3:  ``,
	4:  ``,
	5:  ``,
	6:  ``,
	7:  ``,
	8:  ``,
	9:  ``,
	10: ``,
}

var _FontStretchMap = map[FontStretch]string{
	0:  `Normal`,
	1:  `UltraCondensed`,
	2:  `ExtraCondensed`,
	3:  `SemiCondensed`,
	4:  `SemiExpanded`,
	5:  `ExtraExpanded`,
	6:  `UltraExpanded`,
	7:  `Condensed`,
	8:  `Expanded`,
	9:  `Narrower`,
	10: `Wider`,
}

// String returns the string representation
// of this FontStretch value.
func (i FontStretch) String() string {
	if str, ok := _FontStretchMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontStretch value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontStretch) SetString(s string) error {
	if val, ok := _FontStretchNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontStretchNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontStretch")
}

// Int64 returns the FontStretch value as an int64.
func (i FontStretch) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontStretch value from an int64.
func (i *FontStretch) SetInt64(in int64) {
	*i = FontStretch(in)
}

// Desc returns the description of the FontStretch value.
func (i FontStretch) Desc() string {
	if str, ok := _FontStretchDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontStretchValues returns all possible values
// for the type FontStretch.
func FontStretchValues() []FontStretch {
	return _FontStretchValues
}

// Values returns all possible values
// for the type FontStretch.
func (i FontStretch) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontStretchValues))
	for i, d := range _FontStretchValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontStretch.
func (i FontStretch) IsValid() bool {
	_, ok := _FontStretchMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontStretch) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontStretch) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextDecorationsValues = []TextDecorations{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// TextDecorationsN is the highest valid value
// for type TextDecorations, plus one.
const TextDecorationsN TextDecorations = 10

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextDecorationsNoOp() {
	var x [1]struct{}
	_ = x[DecoNone-(0)]
	_ = x[DecoUnderline-(1)]
	_ = x[DecoOverline-(2)]
	_ = x[DecoLineThrough-(3)]
	_ = x[DecoBlink-(4)]
	_ = x[DecoDottedUnderline-(5)]
	_ = x[DecoParaStart-(6)]
	_ = x[DecoSuper-(7)]
	_ = x[DecoSub-(8)]
	_ = x[DecoBackgroundColor-(9)]
}

var _TextDecorationsNameToValueMap = map[string]TextDecorations{
	`None`:            0,
	`none`:            0,
	`Underline`:       1,
	`underline`:       1,
	`Overline`:        2,
	`overline`:        2,
	`LineThrough`:     3,
	`linethrough`:     3,
	`Blink`:           4,
	`blink`:           4,
	`DottedUnderline`: 5,
	`dottedunderline`: 5,
	`ParaStart`:       6,
	`parastart`:       6,
	`Super`:           7,
	`super`:           7,
	`Sub`:             8,
	`sub`:             8,
	`BackgroundColor`: 9,
	`backgroundcolor`: 9,
}

var _TextDecorationsDescMap = map[TextDecorations]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: `Blink is not currently supported (and probably a bad idea generally ;)`,
	5: `DottedUnderline is used for abbr tag -- otherwise not a standard text-decoration option afaik`,
	6: `DecoParaStart at start of a SpanRender indicates that it should be styled as the start of a new paragraph and not just the start of a new line`,
	7: `DecoSuper indicates super-scripted text`,
	8: `DecoSub indicates sub-scripted text`,
	9: `DecoBackgroundColor indicates that a bg color has been set -- for use in optimizing rendering`,
}

var _TextDecorationsMap = map[TextDecorations]string{
	0: `None`,
	1: `Underline`,
	2: `Overline`,
	3: `LineThrough`,
	4: `Blink`,
	5: `DottedUnderline`,
	6: `ParaStart`,
	7: `Super`,
	8: `Sub`,
	9: `BackgroundColor`,
}

// String returns the string representation
// of this TextDecorations value.
func (i TextDecorations) String() string {
	str := ""
	for _, ie := range _TextDecorationsValues {
		if i.HasFlag(ie) {
			ies := ie.BitIndexString()
			if str == "" {
				str = ies
			} else {
				str += "|" + ies
			}
		}
	}
	return str
}

// BitIndexString returns the string
// representation of this TextDecorations value
// if it is a bit index value
// (typically an enum constant), and
// not an actual bit flag value.
func (i TextDecorations) BitIndexString() string {
	if str, ok := _TextDecorationsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextDecorations value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextDecorations) SetString(s string) error {
	*i = 0
	return i.SetStringOr(s)
}

// SetStringOr sets the TextDecorations value from its
// string representation while preserving any
// bit flags already set, and returns an
// error if the string is invalid.
func (i *TextDecorations) SetStringOr(s string) error {
	flgs := strings.Split(s, "|")
	for _, flg := range flgs {
		if val, ok := _TextDecorationsNameToValueMap[flg]; ok {
			i.SetFlag(true, &val)
		} else if val, ok := _TextDecorationsNameToValueMap[strings.ToLower(flg)]; ok {
			i.SetFlag(true, &val)
		} else {
			return errors.New(flg + " is not a valid value for type TextDecorations")
		}
	}
	return nil
}

// Int64 returns the TextDecorations value as an int64.
func (i TextDecorations) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextDecorations value from an int64.
func (i *TextDecorations) SetInt64(in int64) {
	*i = TextDecorations(in)
}

// Desc returns the description of the TextDecorations value.
func (i TextDecorations) Desc() string {
	if str, ok := _TextDecorationsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextDecorationsValues returns all possible values
// for the type TextDecorations.
func TextDecorationsValues() []TextDecorations {
	return _TextDecorationsValues
}

// Values returns all possible values
// for the type TextDecorations.
func (i TextDecorations) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextDecorationsValues))
	for i, d := range _TextDecorationsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextDecorations.
func (i TextDecorations) IsValid() bool {
	_, ok := _TextDecorationsMap[i]
	return ok
}

// HasFlag returns whether these
// bit flags have the given bit flag set.
func (i TextDecorations) HasFlag(f enums.BitFlag) bool {
	return atomic.LoadInt64((*int64)(&i))&(1<<uint32(f.Int64())) != 0
}

// SetFlag sets the value of the given
// flags in these flags to the given value.
func (i *TextDecorations) SetFlag(on bool, f ...enums.BitFlag) {
	var mask int64
	for _, v := range f {
		mask |= 1 << v.Int64()
	}
	in := int64(*i)
	if on {
		in |= mask
		atomic.StoreInt64((*int64)(i), in)
	} else {
		in &^= mask
		atomic.StoreInt64((*int64)(i), in)
	}
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDecorations) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDecorations) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _BaselineShiftsValues = []BaselineShifts{0, 1, 2}

// BaselineShiftsN is the highest valid value
// for type BaselineShifts, plus one.
const BaselineShiftsN BaselineShifts = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _BaselineShiftsNoOp() {
	var x [1]struct{}
	_ = x[ShiftBaseline-(0)]
	_ = x[ShiftSuper-(1)]
	_ = x[ShiftSub-(2)]
}

var _BaselineShiftsNameToValueMap = map[string]BaselineShifts{
	`Baseline`: 0,
	`baseline`: 0,
	`Super`:    1,
	`super`:    1,
	`Sub`:      2,
	`sub`:      2,
}

var _BaselineShiftsDescMap = map[BaselineShifts]string{
	0: ``,
	1: ``,
	2: ``,
}

var _BaselineShiftsMap = map[BaselineShifts]string{
	0: `Baseline`,
	1: `Super`,
	2: `Sub`,
}

// String returns the string representation
// of this BaselineShifts value.
func (i BaselineShifts) String() string {
	if str, ok := _BaselineShiftsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the BaselineShifts value from its
// string representation, and returns an
// error if the string is invalid.
func (i *BaselineShifts) SetString(s string) error {
	if val, ok := _BaselineShiftsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _BaselineShiftsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type BaselineShifts")
}

// Int64 returns the BaselineShifts value as an int64.
func (i BaselineShifts) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the BaselineShifts value from an int64.
func (i *BaselineShifts) SetInt64(in int64) {
	*i = BaselineShifts(in)
}

// Desc returns the description of the BaselineShifts value.
func (i BaselineShifts) Desc() string {
	if str, ok := _BaselineShiftsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// BaselineShiftsValues returns all possible values
// for the type BaselineShifts.
func BaselineShiftsValues() []BaselineShifts {
	return _BaselineShiftsValues
}

// Values returns all possible values
// for the type BaselineShifts.
func (i BaselineShifts) Values() []enums.Enum {
	res := make([]enums.Enum, len(_BaselineShiftsValues))
	for i, d := range _BaselineShiftsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type BaselineShifts.
func (i BaselineShifts) IsValid() bool {
	_, ok := _BaselineShiftsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BaselineShifts) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BaselineShifts) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FontVariantsValues = []FontVariants{0, 1}

// FontVariantsN is the highest valid value
// for type FontVariants, plus one.
const FontVariantsN FontVariants = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FontVariantsNoOp() {
	var x [1]struct{}
	_ = x[FontVarNormal-(0)]
	_ = x[FontVarSmallCaps-(1)]
}

var _FontVariantsNameToValueMap = map[string]FontVariants{
	`Normal`:    0,
	`normal`:    0,
	`SmallCaps`: 1,
	`smallcaps`: 1,
}

var _FontVariantsDescMap = map[FontVariants]string{
	0: ``,
	1: ``,
}

var _FontVariantsMap = map[FontVariants]string{
	0: `Normal`,
	1: `SmallCaps`,
}

// String returns the string representation
// of this FontVariants value.
func (i FontVariants) String() string {
	if str, ok := _FontVariantsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FontVariants value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FontVariants) SetString(s string) error {
	if val, ok := _FontVariantsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FontVariantsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FontVariants")
}

// Int64 returns the FontVariants value as an int64.
func (i FontVariants) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FontVariants value from an int64.
func (i *FontVariants) SetInt64(in int64) {
	*i = FontVariants(in)
}

// Desc returns the description of the FontVariants value.
func (i FontVariants) Desc() string {
	if str, ok := _FontVariantsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FontVariantsValues returns all possible values
// for the type FontVariants.
func FontVariantsValues() []FontVariants {
	return _FontVariantsValues
}

// Values returns all possible values
// for the type FontVariants.
func (i FontVariants) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FontVariantsValues))
	for i, d := range _FontVariantsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FontVariants.
func (i FontVariants) IsValid() bool {
	_, ok := _FontVariantsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FontVariants) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FontVariants) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _AlignValues = []Align{0, 1, 2, 3, 4, 5, 6}

// AlignN is the highest valid value
// for type Align, plus one.
const AlignN Align = 7

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _AlignNoOp() {
	var x [1]struct{}
	_ = x[AlignStart-(0)]
	_ = x[AlignEnd-(1)]
	_ = x[AlignCenter-(2)]
	_ = x[AlignBaseline-(3)]
	_ = x[AlignSpaceBetween-(4)]
	_ = x[AlignSpaceAround-(5)]
	_ = x[AlignSpaceEvenly-(6)]
}

var _AlignNameToValueMap = map[string]Align{
	`Start`:        0,
	`start`:        0,
	`End`:          1,
	`end`:          1,
	`Center`:       2,
	`center`:       2,
	`Baseline`:     3,
	`baseline`:     3,
	`SpaceBetween`: 4,
	`spacebetween`: 4,
	`SpaceAround`:  5,
	`spacearound`:  5,
	`SpaceEvenly`:  6,
	`spaceevenly`:  6,
}

var _AlignDescMap = map[Align]string{
	0: `Align items to the start (top, left) of layout`,
	1: `Align items to the end (bottom, right) of layout`,
	2: `Align all items centered around the center of layout space`,
	3: `Align to text baselines`,
	4: `First and last are flush, equal space between remaining items`,
	5: `First and last have 1/2 space at edges, full space between remaining items`,
	6: `Equal space at start, end, and between all items`,
}

var _AlignMap = map[Align]string{
	0: `Start`,
	1: `End`,
	2: `Center`,
	3: `Baseline`,
	4: `SpaceBetween`,
	5: `SpaceAround`,
	6: `SpaceEvenly`,
}

// String returns the string representation
// of this Align value.
func (i Align) String() string {
	if str, ok := _AlignMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Align value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Align) SetString(s string) error {
	if val, ok := _AlignNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _AlignNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Align")
}

// Int64 returns the Align value as an int64.
func (i Align) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Align value from an int64.
func (i *Align) SetInt64(in int64) {
	*i = Align(in)
}

// Desc returns the description of the Align value.
func (i Align) Desc() string {
	if str, ok := _AlignDescMap[i]; ok {
		return str
	}
	return i.String()
}

// AlignValues returns all possible values
// for the type Align.
func AlignValues() []Align {
	return _AlignValues
}

// Values returns all possible values
// for the type Align.
func (i Align) Values() []enums.Enum {
	res := make([]enums.Enum, len(_AlignValues))
	for i, d := range _AlignValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Align.
func (i Align) IsValid() bool {
	_, ok := _AlignMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Align) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Align) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _OverflowValues = []Overflow{0, 1, 2, 3}

// OverflowN is the highest valid value
// for type Overflow, plus one.
const OverflowN Overflow = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _OverflowNoOp() {
	var x [1]struct{}
	_ = x[OverflowVisible-(0)]
	_ = x[OverflowHidden-(1)]
	_ = x[OverflowAuto-(2)]
	_ = x[OverflowScroll-(3)]
}

var _OverflowNameToValueMap = map[string]Overflow{
	`Visible`: 0,
	`visible`: 0,
	`Hidden`:  1,
	`hidden`:  1,
	`Auto`:    2,
	`auto`:    2,
	`Scroll`:  3,
	`scroll`:  3,
}

var _OverflowDescMap = map[Overflow]string{
	0: `OverflowVisible makes the overflow visible, meaning that the size of the container is always at least the Min size of its contents. No scrollbars are shown.`,
	1: `OverflowHidden hides the overflow and doesn&#39;t present scrollbars.`,
	2: `OverflowAuto automatically determines if scrollbars should be added to show the overflow. Scrollbars are added only if the actual content size is greater than the currently available size.`,
	3: `OverflowScroll means that scrollbars are always visible, and is otherwise identical to Auto. However, only during Viewport PrefSize call, the actual content size is used -- otherwise it behaves just like Auto.`,
}

var _OverflowMap = map[Overflow]string{
	0: `Visible`,
	1: `Hidden`,
	2: `Auto`,
	3: `Scroll`,
}

// String returns the string representation
// of this Overflow value.
func (i Overflow) String() string {
	if str, ok := _OverflowMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Overflow value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Overflow) SetString(s string) error {
	if val, ok := _OverflowNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _OverflowNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Overflow")
}

// Int64 returns the Overflow value as an int64.
func (i Overflow) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Overflow value from an int64.
func (i *Overflow) SetInt64(in int64) {
	*i = Overflow(in)
}

// Desc returns the description of the Overflow value.
func (i Overflow) Desc() string {
	if str, ok := _OverflowDescMap[i]; ok {
		return str
	}
	return i.String()
}

// OverflowValues returns all possible values
// for the type Overflow.
func OverflowValues() []Overflow {
	return _OverflowValues
}

// Values returns all possible values
// for the type Overflow.
func (i Overflow) Values() []enums.Enum {
	res := make([]enums.Enum, len(_OverflowValues))
	for i, d := range _OverflowValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Overflow.
func (i Overflow) IsValid() bool {
	_, ok := _OverflowMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Overflow) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Overflow) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _FillRulesValues = []FillRules{0, 1}

// FillRulesN is the highest valid value
// for type FillRules, plus one.
const FillRulesN FillRules = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _FillRulesNoOp() {
	var x [1]struct{}
	_ = x[FillRuleNonZero-(0)]
	_ = x[FillRuleEvenOdd-(1)]
}

var _FillRulesNameToValueMap = map[string]FillRules{
	`NonZero`: 0,
	`nonzero`: 0,
	`EvenOdd`: 1,
	`evenodd`: 1,
}

var _FillRulesDescMap = map[FillRules]string{
	0: ``,
	1: ``,
}

var _FillRulesMap = map[FillRules]string{
	0: `NonZero`,
	1: `EvenOdd`,
}

// String returns the string representation
// of this FillRules value.
func (i FillRules) String() string {
	if str, ok := _FillRulesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the FillRules value from its
// string representation, and returns an
// error if the string is invalid.
func (i *FillRules) SetString(s string) error {
	if val, ok := _FillRulesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _FillRulesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type FillRules")
}

// Int64 returns the FillRules value as an int64.
func (i FillRules) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the FillRules value from an int64.
func (i *FillRules) SetInt64(in int64) {
	*i = FillRules(in)
}

// Desc returns the description of the FillRules value.
func (i FillRules) Desc() string {
	if str, ok := _FillRulesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// FillRulesValues returns all possible values
// for the type FillRules.
func FillRulesValues() []FillRules {
	return _FillRulesValues
}

// Values returns all possible values
// for the type FillRules.
func (i FillRules) Values() []enums.Enum {
	res := make([]enums.Enum, len(_FillRulesValues))
	for i, d := range _FillRulesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type FillRules.
func (i FillRules) IsValid() bool {
	_, ok := _FillRulesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i FillRules) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *FillRules) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _VectorEffectsValues = []VectorEffects{0, 1}

// VectorEffectsN is the highest valid value
// for type VectorEffects, plus one.
const VectorEffectsN VectorEffects = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _VectorEffectsNoOp() {
	var x [1]struct{}
	_ = x[VecEffNone-(0)]
	_ = x[VecEffNonScalingStroke-(1)]
}

var _VectorEffectsNameToValueMap = map[string]VectorEffects{
	`None`:             0,
	`none`:             0,
	`NonScalingStroke`: 1,
	`nonscalingstroke`: 1,
}

var _VectorEffectsDescMap = map[VectorEffects]string{
	0: ``,
	1: `VecEffNonScalingStroke means that the stroke width is not affected by transform properties`,
}

var _VectorEffectsMap = map[VectorEffects]string{
	0: `None`,
	1: `NonScalingStroke`,
}

// String returns the string representation
// of this VectorEffects value.
func (i VectorEffects) String() string {
	if str, ok := _VectorEffectsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the VectorEffects value from its
// string representation, and returns an
// error if the string is invalid.
func (i *VectorEffects) SetString(s string) error {
	if val, ok := _VectorEffectsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _VectorEffectsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type VectorEffects")
}

// Int64 returns the VectorEffects value as an int64.
func (i VectorEffects) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the VectorEffects value from an int64.
func (i *VectorEffects) SetInt64(in int64) {
	*i = VectorEffects(in)
}

// Desc returns the description of the VectorEffects value.
func (i VectorEffects) Desc() string {
	if str, ok := _VectorEffectsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// VectorEffectsValues returns all possible values
// for the type VectorEffects.
func VectorEffectsValues() []VectorEffects {
	return _VectorEffectsValues
}

// Values returns all possible values
// for the type VectorEffects.
func (i VectorEffects) Values() []enums.Enum {
	res := make([]enums.Enum, len(_VectorEffectsValues))
	for i, d := range _VectorEffectsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type VectorEffects.
func (i VectorEffects) IsValid() bool {
	_, ok := _VectorEffectsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i VectorEffects) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *VectorEffects) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LineCapsValues = []LineCaps{0, 1, 2, 3, 4}

// LineCapsN is the highest valid value
// for type LineCaps, plus one.
const LineCapsN LineCaps = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LineCapsNoOp() {
	var x [1]struct{}
	_ = x[LineCapButt-(0)]
	_ = x[LineCapRound-(1)]
	_ = x[LineCapSquare-(2)]
	_ = x[LineCapCubic-(3)]
	_ = x[LineCapQuadratic-(4)]
}

var _LineCapsNameToValueMap = map[string]LineCaps{
	`Butt`:      0,
	`butt`:      0,
	`Round`:     1,
	`round`:     1,
	`Square`:    2,
	`square`:    2,
	`Cubic`:     3,
	`cubic`:     3,
	`Quadratic`: 4,
	`quadratic`: 4,
}

var _LineCapsDescMap = map[LineCaps]string{
	0: ``,
	1: ``,
	2: ``,
	3: `rasterx extension`,
	4: `rasterx extension`,
}

var _LineCapsMap = map[LineCaps]string{
	0: `Butt`,
	1: `Round`,
	2: `Square`,
	3: `Cubic`,
	4: `Quadratic`,
}

// String returns the string representation
// of this LineCaps value.
func (i LineCaps) String() string {
	if str, ok := _LineCapsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the LineCaps value from its
// string representation, and returns an
// error if the string is invalid.
func (i *LineCaps) SetString(s string) error {
	if val, ok := _LineCapsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LineCapsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type LineCaps")
}

// Int64 returns the LineCaps value as an int64.
func (i LineCaps) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the LineCaps value from an int64.
func (i *LineCaps) SetInt64(in int64) {
	*i = LineCaps(in)
}

// Desc returns the description of the LineCaps value.
func (i LineCaps) Desc() string {
	if str, ok := _LineCapsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LineCapsValues returns all possible values
// for the type LineCaps.
func LineCapsValues() []LineCaps {
	return _LineCapsValues
}

// Values returns all possible values
// for the type LineCaps.
func (i LineCaps) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LineCapsValues))
	for i, d := range _LineCapsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type LineCaps.
func (i LineCaps) IsValid() bool {
	_, ok := _LineCapsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineCaps) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineCaps) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _LineJoinsValues = []LineJoins{0, 1, 2, 3, 4, 5}

// LineJoinsN is the highest valid value
// for type LineJoins, plus one.
const LineJoinsN LineJoins = 6

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LineJoinsNoOp() {
	var x [1]struct{}
	_ = x[LineJoinMiter-(0)]
	_ = x[LineJoinMiterClip-(1)]
	_ = x[LineJoinRound-(2)]
	_ = x[LineJoinBevel-(3)]
	_ = x[LineJoinArcs-(4)]
	_ = x[LineJoinArcsClip-(5)]
}

var _LineJoinsNameToValueMap = map[string]LineJoins{
	`Miter`:     0,
	`miter`:     0,
	`MiterClip`: 1,
	`miterclip`: 1,
	`Round`:     2,
	`round`:     2,
	`Bevel`:     3,
	`bevel`:     3,
	`Arcs`:      4,
	`arcs`:      4,
	`ArcsClip`:  5,
	`arcsclip`:  5,
}

var _LineJoinsDescMap = map[LineJoins]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: `rasterx extension`,
}

var _LineJoinsMap = map[LineJoins]string{
	0: `Miter`,
	1: `MiterClip`,
	2: `Round`,
	3: `Bevel`,
	4: `Arcs`,
	5: `ArcsClip`,
}

// String returns the string representation
// of this LineJoins value.
func (i LineJoins) String() string {
	if str, ok := _LineJoinsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the LineJoins value from its
// string representation, and returns an
// error if the string is invalid.
func (i *LineJoins) SetString(s string) error {
	if val, ok := _LineJoinsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LineJoinsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type LineJoins")
}

// Int64 returns the LineJoins value as an int64.
func (i LineJoins) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the LineJoins value from an int64.
func (i *LineJoins) SetInt64(in int64) {
	*i = LineJoins(in)
}

// Desc returns the description of the LineJoins value.
func (i LineJoins) Desc() string {
	if str, ok := _LineJoinsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LineJoinsValues returns all possible values
// for the type LineJoins.
func LineJoinsValues() []LineJoins {
	return _LineJoinsValues
}

// Values returns all possible values
// for the type LineJoins.
func (i LineJoins) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LineJoinsValues))
	for i, d := range _LineJoinsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type LineJoins.
func (i LineJoins) IsValid() bool {
	_, ok := _LineJoinsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i LineJoins) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *LineJoins) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _UnicodeBidiValues = []UnicodeBidi{0, 1, 2}

// UnicodeBidiN is the highest valid value
// for type UnicodeBidi, plus one.
const UnicodeBidiN UnicodeBidi = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _UnicodeBidiNoOp() {
	var x [1]struct{}
	_ = x[BidiNormal-(0)]
	_ = x[BidiEmbed-(1)]
	_ = x[BidiBidiOverride-(2)]
}

var _UnicodeBidiNameToValueMap = map[string]UnicodeBidi{
	`Normal`:       0,
	`normal`:       0,
	`Embed`:        1,
	`embed`:        1,
	`BidiOverride`: 2,
	`bidioverride`: 2,
}

var _UnicodeBidiDescMap = map[UnicodeBidi]string{
	0: ``,
	1: ``,
	2: ``,
}

var _UnicodeBidiMap = map[UnicodeBidi]string{
	0: `Normal`,
	1: `Embed`,
	2: `BidiOverride`,
}

// String returns the string representation
// of this UnicodeBidi value.
func (i UnicodeBidi) String() string {
	if str, ok := _UnicodeBidiMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the UnicodeBidi value from its
// string representation, and returns an
// error if the string is invalid.
func (i *UnicodeBidi) SetString(s string) error {
	if val, ok := _UnicodeBidiNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _UnicodeBidiNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type UnicodeBidi")
}

// Int64 returns the UnicodeBidi value as an int64.
func (i UnicodeBidi) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the UnicodeBidi value from an int64.
func (i *UnicodeBidi) SetInt64(in int64) {
	*i = UnicodeBidi(in)
}

// Desc returns the description of the UnicodeBidi value.
func (i UnicodeBidi) Desc() string {
	if str, ok := _UnicodeBidiDescMap[i]; ok {
		return str
	}
	return i.String()
}

// UnicodeBidiValues returns all possible values
// for the type UnicodeBidi.
func UnicodeBidiValues() []UnicodeBidi {
	return _UnicodeBidiValues
}

// Values returns all possible values
// for the type UnicodeBidi.
func (i UnicodeBidi) Values() []enums.Enum {
	res := make([]enums.Enum, len(_UnicodeBidiValues))
	for i, d := range _UnicodeBidiValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type UnicodeBidi.
func (i UnicodeBidi) IsValid() bool {
	_, ok := _UnicodeBidiMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i UnicodeBidi) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *UnicodeBidi) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextDirectionsValues = []TextDirections{0, 1, 2, 3, 4, 5, 6, 7}

// TextDirectionsN is the highest valid value
// for type TextDirections, plus one.
const TextDirectionsN TextDirections = 8

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextDirectionsNoOp() {
	var x [1]struct{}
	_ = x[LRTB-(0)]
	_ = x[RLTB-(1)]
	_ = x[TBRL-(2)]
	_ = x[LR-(3)]
	_ = x[RL-(4)]
	_ = x[TB-(5)]
	_ = x[LTR-(6)]
	_ = x[RTL-(7)]
}

var _TextDirectionsNameToValueMap = map[string]TextDirections{
	`LRTB`: 0,
	`lrtb`: 0,
	`RLTB`: 1,
	`rltb`: 1,
	`TBRL`: 2,
	`tbrl`: 2,
	`LR`:   3,
	`lr`:   3,
	`RL`:   4,
	`rl`:   4,
	`TB`:   5,
	`tb`:   5,
	`LTR`:  6,
	`ltr`:  6,
	`RTL`:  7,
	`rtl`:  7,
}

var _TextDirectionsDescMap = map[TextDirections]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
	4: ``,
	5: ``,
	6: ``,
	7: ``,
}

var _TextDirectionsMap = map[TextDirections]string{
	0: `LRTB`,
	1: `RLTB`,
	2: `TBRL`,
	3: `LR`,
	4: `RL`,
	5: `TB`,
	6: `LTR`,
	7: `RTL`,
}

// String returns the string representation
// of this TextDirections value.
func (i TextDirections) String() string {
	if str, ok := _TextDirectionsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextDirections value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextDirections) SetString(s string) error {
	if val, ok := _TextDirectionsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextDirectionsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextDirections")
}

// Int64 returns the TextDirections value as an int64.
func (i TextDirections) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextDirections value from an int64.
func (i *TextDirections) SetInt64(in int64) {
	*i = TextDirections(in)
}

// Desc returns the description of the TextDirections value.
func (i TextDirections) Desc() string {
	if str, ok := _TextDirectionsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextDirectionsValues returns all possible values
// for the type TextDirections.
func TextDirectionsValues() []TextDirections {
	return _TextDirectionsValues
}

// Values returns all possible values
// for the type TextDirections.
func (i TextDirections) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextDirectionsValues))
	for i, d := range _TextDirectionsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextDirections.
func (i TextDirections) IsValid() bool {
	_, ok := _TextDirectionsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextDirections) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextDirections) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _TextAnchorsValues = []TextAnchors{0, 1, 2}

// TextAnchorsN is the highest valid value
// for type TextAnchors, plus one.
const TextAnchorsN TextAnchors = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _TextAnchorsNoOp() {
	var x [1]struct{}
	_ = x[AnchorStart-(0)]
	_ = x[AnchorMiddle-(1)]
	_ = x[AnchorEnd-(2)]
}

var _TextAnchorsNameToValueMap = map[string]TextAnchors{
	`Start`:  0,
	`start`:  0,
	`Middle`: 1,
	`middle`: 1,
	`End`:    2,
	`end`:    2,
}

var _TextAnchorsDescMap = map[TextAnchors]string{
	0: ``,
	1: ``,
	2: ``,
}

var _TextAnchorsMap = map[TextAnchors]string{
	0: `Start`,
	1: `Middle`,
	2: `End`,
}

// String returns the string representation
// of this TextAnchors value.
func (i TextAnchors) String() string {
	if str, ok := _TextAnchorsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the TextAnchors value from its
// string representation, and returns an
// error if the string is invalid.
func (i *TextAnchors) SetString(s string) error {
	if val, ok := _TextAnchorsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _TextAnchorsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type TextAnchors")
}

// Int64 returns the TextAnchors value as an int64.
func (i TextAnchors) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the TextAnchors value from an int64.
func (i *TextAnchors) SetInt64(in int64) {
	*i = TextAnchors(in)
}

// Desc returns the description of the TextAnchors value.
func (i TextAnchors) Desc() string {
	if str, ok := _TextAnchorsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// TextAnchorsValues returns all possible values
// for the type TextAnchors.
func TextAnchorsValues() []TextAnchors {
	return _TextAnchorsValues
}

// Values returns all possible values
// for the type TextAnchors.
func (i TextAnchors) Values() []enums.Enum {
	res := make([]enums.Enum, len(_TextAnchorsValues))
	for i, d := range _TextAnchorsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type TextAnchors.
func (i TextAnchors) IsValid() bool {
	_, ok := _TextAnchorsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i TextAnchors) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *TextAnchors) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}

var _WhiteSpacesValues = []WhiteSpaces{0, 1, 2, 3, 4}

// WhiteSpacesN is the highest valid value
// for type WhiteSpaces, plus one.
const WhiteSpacesN WhiteSpaces = 5

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _WhiteSpacesNoOp() {
	var x [1]struct{}
	_ = x[WhiteSpaceNormal-(0)]
	_ = x[WhiteSpaceNowrap-(1)]
	_ = x[WhiteSpacePre-(2)]
	_ = x[WhiteSpacePreLine-(3)]
	_ = x[WhiteSpacePreWrap-(4)]
}

var _WhiteSpacesNameToValueMap = map[string]WhiteSpaces{
	`Normal`:  0,
	`normal`:  0,
	`Nowrap`:  1,
	`nowrap`:  1,
	`Pre`:     2,
	`pre`:     2,
	`PreLine`: 3,
	`preline`: 3,
	`PreWrap`: 4,
	`prewrap`: 4,
}

var _WhiteSpacesDescMap = map[WhiteSpaces]string{
	0: `WhiteSpaceNormal means that all white space is collapsed to a single space, and text wraps when necessary`,
	1: `WhiteSpaceNowrap means that sequences of whitespace will collapse into a single whitespace. Text will never wrap to the next line. The text continues on the same line until a &lt;br&gt; tag is encountered`,
	2: `WhiteSpacePre means that whitespace is preserved by the browser. Text will only wrap on line breaks. Acts like the &lt;pre&gt; tag in HTML. This invokes a different hand-written parser because the default golang parser automatically throws away whitespace`,
	3: `WhiteSpacePreLine means that sequences of whitespace will collapse into a single whitespace. Text will wrap when necessary, and on line breaks`,
	4: `WhiteSpacePreWrap means that whitespace is preserved by the browser. Text will wrap when necessary, and on line breaks`,
}

var _WhiteSpacesMap = map[WhiteSpaces]string{
	0: `Normal`,
	1: `Nowrap`,
	2: `Pre`,
	3: `PreLine`,
	4: `PreWrap`,
}

// String returns the string representation
// of this WhiteSpaces value.
func (i WhiteSpaces) String() string {
	if str, ok := _WhiteSpacesMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the WhiteSpaces value from its
// string representation, and returns an
// error if the string is invalid.
func (i *WhiteSpaces) SetString(s string) error {
	if val, ok := _WhiteSpacesNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _WhiteSpacesNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type WhiteSpaces")
}

// Int64 returns the WhiteSpaces value as an int64.
func (i WhiteSpaces) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the WhiteSpaces value from an int64.
func (i *WhiteSpaces) SetInt64(in int64) {
	*i = WhiteSpaces(in)
}

// Desc returns the description of the WhiteSpaces value.
func (i WhiteSpaces) Desc() string {
	if str, ok := _WhiteSpacesDescMap[i]; ok {
		return str
	}
	return i.String()
}

// WhiteSpacesValues returns all possible values
// for the type WhiteSpaces.
func WhiteSpacesValues() []WhiteSpaces {
	return _WhiteSpacesValues
}

// Values returns all possible values
// for the type WhiteSpaces.
func (i WhiteSpaces) Values() []enums.Enum {
	res := make([]enums.Enum, len(_WhiteSpacesValues))
	for i, d := range _WhiteSpacesValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type WhiteSpaces.
func (i WhiteSpaces) IsValid() bool {
	_, ok := _WhiteSpacesMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i WhiteSpaces) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *WhiteSpaces) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
