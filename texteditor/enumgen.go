// Code generated by "core generate"; DO NOT EDIT.

package texteditor

import (
	"cogentcore.org/core/enums"
	"cogentcore.org/core/core"
)

var _SpellSignalsValues = []SpellSignals{0, 1}

// SpellSignalsN is the highest valid value for type SpellSignals, plus one.
const SpellSignalsN SpellSignals = 2

var _SpellSignalsValueMap = map[string]SpellSignals{`Select`: 0, `Ignore`: 1}

var _SpellSignalsDescMap = map[SpellSignals]string{0: `SpellSelect means the user chose one of the possible corrections`, 1: `SpellIgnore signals the user chose ignore so clear the tag`}

var _SpellSignalsMap = map[SpellSignals]string{0: `Select`, 1: `Ignore`}

// String returns the string representation of this SpellSignals value.
func (i SpellSignals) String() string { return enums.String(i, _SpellSignalsMap) }

// SetString sets the SpellSignals value from its string representation,
// and returns an error if the string is invalid.
func (i *SpellSignals) SetString(s string) error {
	return enums.SetString(i, s, _SpellSignalsValueMap, "SpellSignals")
}

// Int64 returns the SpellSignals value as an int64.
func (i SpellSignals) Int64() int64 { return int64(i) }

// SetInt64 sets the SpellSignals value from an int64.
func (i *SpellSignals) SetInt64(in int64) { *i = SpellSignals(in) }

// Desc returns the description of the SpellSignals value.
func (i SpellSignals) Desc() string { return enums.Desc(i, _SpellSignalsDescMap) }

// SpellSignalsValues returns all possible values for the type SpellSignals.
func SpellSignalsValues() []SpellSignals { return _SpellSignalsValues }

// Values returns all possible values for the type SpellSignals.
func (i SpellSignals) Values() []enums.Enum { return enums.Values(_SpellSignalsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SpellSignals) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SpellSignals) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "SpellSignals")
}

var _BufferSignalsValues = []BufferSignals{0, 1, 2, 3, 4, 5, 6}

// BufferSignalsN is the highest valid value for type BufferSignals, plus one.
const BufferSignalsN BufferSignals = 7

var _BufferSignalsValueMap = map[string]BufferSignals{`Done`: 0, `New`: 1, `Mods`: 2, `Insert`: 3, `Delete`: 4, `MarkupUpdated`: 5, `Closed`: 6}

var _BufferSignalsDescMap = map[BufferSignals]string{0: `BufferDone means that editing was completed and applied to Txt field -- data is Txt bytes`, 1: `BufferNew signals that entirely new text is present. All views should do full layout update.`, 2: `BufferMods signals that potentially diffuse modifications have been made. Views should do a Layout and Render.`, 3: `BufferInsert signals that some text was inserted. data is textbuf.Edit describing change. The Buf always reflects the current state *after* the edit.`, 4: `BufferDelete signals that some text was deleted. data is textbuf.Edit describing change. The Buf always reflects the current state *after* the edit.`, 5: `BufferMarkupUpdated signals that the Markup text has been updated This signal is typically sent from a separate goroutine, so should be used with a mutex`, 6: `BufferClosed signals that the textbuf was closed.`}

var _BufferSignalsMap = map[BufferSignals]string{0: `Done`, 1: `New`, 2: `Mods`, 3: `Insert`, 4: `Delete`, 5: `MarkupUpdated`, 6: `Closed`}

// String returns the string representation of this BufferSignals value.
func (i BufferSignals) String() string { return enums.String(i, _BufferSignalsMap) }

// SetString sets the BufferSignals value from its string representation,
// and returns an error if the string is invalid.
func (i *BufferSignals) SetString(s string) error {
	return enums.SetString(i, s, _BufferSignalsValueMap, "BufferSignals")
}

// Int64 returns the BufferSignals value as an int64.
func (i BufferSignals) Int64() int64 { return int64(i) }

// SetInt64 sets the BufferSignals value from an int64.
func (i *BufferSignals) SetInt64(in int64) { *i = BufferSignals(in) }

// Desc returns the description of the BufferSignals value.
func (i BufferSignals) Desc() string { return enums.Desc(i, _BufferSignalsDescMap) }

// BufferSignalsValues returns all possible values for the type BufferSignals.
func BufferSignalsValues() []BufferSignals { return _BufferSignalsValues }

// Values returns all possible values for the type BufferSignals.
func (i BufferSignals) Values() []enums.Enum { return enums.Values(_BufferSignalsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BufferSignals) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BufferSignals) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BufferSignals")
}

var _BufferFlagsValues = []BufferFlags{2, 3, 4, 5, 6}

// BufferFlagsN is the highest valid value for type BufferFlags, plus one.
const BufferFlagsN BufferFlags = 7

var _BufferFlagsValueMap = map[string]BufferFlags{`AutoSaving`: 2, `MarkingUp`: 3, `Changed`: 4, `NotSaved`: 5, `FileModOK`: 6}

var _BufferFlagsDescMap = map[BufferFlags]string{2: `BufferAutoSaving is used in atomically safe way to protect autosaving`, 3: `BufferMarkingUp indicates current markup operation in progress -- don&#39;t redo`, 4: `BufferChanged indicates if the text has been changed (edited) relative to the original, since last EditDone`, 5: `BufferNotSaved indicates if the text has been changed (edited) relative to the original, since last Save`, 6: `BufferFileModOK have already asked about fact that file has changed since being opened, user is ok`}

var _BufferFlagsMap = map[BufferFlags]string{2: `AutoSaving`, 3: `MarkingUp`, 4: `Changed`, 5: `NotSaved`, 6: `FileModOK`}

// String returns the string representation of this BufferFlags value.
func (i BufferFlags) String() string {
	return enums.BitFlagStringExtended(i, _BufferFlagsValues, core.WidgetFlagsValues())
}

// BitIndexString returns the string representation of this BufferFlags value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i BufferFlags) BitIndexString() string {
	return enums.BitIndexStringExtended[BufferFlags, core.WidgetFlags](i, _BufferFlagsMap)
}

// SetString sets the BufferFlags value from its string representation,
// and returns an error if the string is invalid.
func (i *BufferFlags) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the BufferFlags value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *BufferFlags) SetStringOr(s string) error {
	return enums.SetStringOrExtended(i, (*core.WidgetFlags)(i), s, _BufferFlagsValueMap)
}

// Int64 returns the BufferFlags value as an int64.
func (i BufferFlags) Int64() int64 { return int64(i) }

// SetInt64 sets the BufferFlags value from an int64.
func (i *BufferFlags) SetInt64(in int64) { *i = BufferFlags(in) }

// Desc returns the description of the BufferFlags value.
func (i BufferFlags) Desc() string {
	return enums.DescExtended[BufferFlags, core.WidgetFlags](i, _BufferFlagsDescMap)
}

// BufferFlagsValues returns all possible values for the type BufferFlags.
func BufferFlagsValues() []BufferFlags {
	return enums.ValuesGlobalExtended(_BufferFlagsValues, core.WidgetFlagsValues())
}

// Values returns all possible values for the type BufferFlags.
func (i BufferFlags) Values() []enums.Enum {
	return enums.ValuesExtended(_BufferFlagsValues, core.WidgetFlagsValues())
}

// HasFlag returns whether these bit flags have the given bit flag set.
func (i BufferFlags) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(&i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *BufferFlags) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BufferFlags) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BufferFlags) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "BufferFlags")
}

var _EditorFlagsValues = []EditorFlags{2, 3, 4, 5, 6}

// EditorFlagsN is the highest valid value for type EditorFlags, plus one.
const EditorFlagsN EditorFlags = 7

var _EditorFlagsValueMap = map[string]EditorFlags{`EditorHasLineNos`: 2, `EditorNeedsLayout`: 3, `EditorLastWasTabAI`: 4, `EditorLastWasUndo`: 5, `EditorTargetSet`: 6}

var _EditorFlagsDescMap = map[EditorFlags]string{2: `EditorHasLineNos indicates that this editor has line numbers (per Buf option)`, 3: `EditorNeedsLayout is set by NeedsLayout: Editor does significant internal layout in LayoutAllLines, and its layout is simply based on what it gets allocated, so it does not affect the rest of the Scene.`, 4: `EditorLastWasTabAI indicates that last key was a Tab auto-indent`, 5: `EditorLastWasUndo indicates that last key was an undo`, 6: `EditorTargetSet indicates that the CursorTarget is set`}

var _EditorFlagsMap = map[EditorFlags]string{2: `EditorHasLineNos`, 3: `EditorNeedsLayout`, 4: `EditorLastWasTabAI`, 5: `EditorLastWasUndo`, 6: `EditorTargetSet`}

// String returns the string representation of this EditorFlags value.
func (i EditorFlags) String() string {
	return enums.BitFlagStringExtended(i, _EditorFlagsValues, core.WidgetFlagsValues())
}

// BitIndexString returns the string representation of this EditorFlags value
// if it is a bit index value (typically an enum constant), and
// not an actual bit flag value.
func (i EditorFlags) BitIndexString() string {
	return enums.BitIndexStringExtended[EditorFlags, core.WidgetFlags](i, _EditorFlagsMap)
}

// SetString sets the EditorFlags value from its string representation,
// and returns an error if the string is invalid.
func (i *EditorFlags) SetString(s string) error { *i = 0; return i.SetStringOr(s) }

// SetStringOr sets the EditorFlags value from its string representation
// while preserving any bit flags already set, and returns an
// error if the string is invalid.
func (i *EditorFlags) SetStringOr(s string) error {
	return enums.SetStringOrExtended(i, (*core.WidgetFlags)(i), s, _EditorFlagsValueMap)
}

// Int64 returns the EditorFlags value as an int64.
func (i EditorFlags) Int64() int64 { return int64(i) }

// SetInt64 sets the EditorFlags value from an int64.
func (i *EditorFlags) SetInt64(in int64) { *i = EditorFlags(in) }

// Desc returns the description of the EditorFlags value.
func (i EditorFlags) Desc() string {
	return enums.DescExtended[EditorFlags, core.WidgetFlags](i, _EditorFlagsDescMap)
}

// EditorFlagsValues returns all possible values for the type EditorFlags.
func EditorFlagsValues() []EditorFlags {
	return enums.ValuesGlobalExtended(_EditorFlagsValues, core.WidgetFlagsValues())
}

// Values returns all possible values for the type EditorFlags.
func (i EditorFlags) Values() []enums.Enum {
	return enums.ValuesExtended(_EditorFlagsValues, core.WidgetFlagsValues())
}

// HasFlag returns whether these bit flags have the given bit flag set.
func (i EditorFlags) HasFlag(f enums.BitFlag) bool { return enums.HasFlag((*int64)(&i), f) }

// SetFlag sets the value of the given flags in these flags to the given value.
func (i *EditorFlags) SetFlag(on bool, f ...enums.BitFlag) { enums.SetFlag((*int64)(i), on, f...) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i EditorFlags) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *EditorFlags) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "EditorFlags")
}
