// Code generated by "enumgen generate"; DO NOT EDIT.

package units

import (
	"errors"
	"strconv"
	"strings"

	"goki.dev/enums"
)

var _UnitsValues = []Units{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

// UnitsN is the highest valid value
// for type Units, plus one.
const UnitsN Units = 21

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _UnitsNoOp() {
	var x [1]struct{}
	_ = x[UnitPx-(0)]
	_ = x[UnitDp-(1)]
	_ = x[UnitEw-(2)]
	_ = x[UnitEh-(3)]
	_ = x[UnitPw-(4)]
	_ = x[UnitPh-(5)]
	_ = x[UnitRem-(6)]
	_ = x[UnitEm-(7)]
	_ = x[UnitEx-(8)]
	_ = x[UnitCh-(9)]
	_ = x[UnitVw-(10)]
	_ = x[UnitVh-(11)]
	_ = x[UnitVmin-(12)]
	_ = x[UnitVmax-(13)]
	_ = x[UnitCm-(14)]
	_ = x[UnitMm-(15)]
	_ = x[UnitQ-(16)]
	_ = x[UnitIn-(17)]
	_ = x[UnitPc-(18)]
	_ = x[UnitPt-(19)]
	_ = x[UnitDot-(20)]
}

var _UnitsNameToValueMap = map[string]Units{
	`UnitPx`:   0,
	`unitpx`:   0,
	`UnitDp`:   1,
	`unitdp`:   1,
	`UnitEw`:   2,
	`unitew`:   2,
	`UnitEh`:   3,
	`uniteh`:   3,
	`UnitPw`:   4,
	`unitpw`:   4,
	`UnitPh`:   5,
	`unitph`:   5,
	`UnitRem`:  6,
	`unitrem`:  6,
	`UnitEm`:   7,
	`unitem`:   7,
	`UnitEx`:   8,
	`unitex`:   8,
	`UnitCh`:   9,
	`unitch`:   9,
	`UnitVw`:   10,
	`unitvw`:   10,
	`UnitVh`:   11,
	`unitvh`:   11,
	`UnitVmin`: 12,
	`unitvmin`: 12,
	`UnitVmax`: 13,
	`unitvmax`: 13,
	`UnitCm`:   14,
	`unitcm`:   14,
	`UnitMm`:   15,
	`unitmm`:   15,
	`UnitQ`:    16,
	`unitq`:    16,
	`UnitIn`:   17,
	`unitin`:   17,
	`UnitPc`:   18,
	`unitpc`:   18,
	`UnitPt`:   19,
	`unitpt`:   19,
	`UnitDot`:  20,
	`unitdot`:  20,
}

var _UnitsDescMap = map[Units]string{
	0:  `UnitPx = pixels -- 1px = 1/96th of 1in -- these are NOT raw display pixels`,
	1:  `UnitDp = density-independent pixels -- 1dp = 1/160th of 1in`,
	2:  `UnitEw = percentage of element width (equivalent to CSS % in some contexts)`,
	3:  `UnitEh = percentage of element height (equivalent to CSS % in some contexts)`,
	4:  `UnitPw = percentage of parent width (equivalent to CSS % in some contexts)`,
	5:  `UnitPh = percentage of parent height (equivalent to CSS % in some contexts)`,
	6:  `UnitRem = font size of the root element -- defaults to 12pt scaled by DPI factor`,
	7:  `UnitEm = font size of the element -- fallback to 12pt by default`,
	8:  `UnitEx = x-height of the element&#39;s font (size of &#39;x&#39; glyph) -- fallback to 0.5em by default`,
	9:  `UnitCh = width of the &#39;0&#39; glyph in the element&#39;s font -- fallback to 0.5em by default`,
	10: `UnitVw = 1% of the viewport&#39;s width`,
	11: `UnitVh = 1% of the viewport&#39;s height`,
	12: `UnitVmin = 1% of the viewport&#39;s smaller dimension`,
	13: `UnitVmax = 1% of the viewport&#39;s larger dimension`,
	14: `UnitCm = centimeters -- 1cm = 96px/2.54`,
	15: `UnitMm = millimeters -- 1mm = 1/10th of cm`,
	16: `UnitQ = quarter-millimeters -- 1q = 1/40th of cm`,
	17: `UnitIn = inches -- 1in = 2.54cm = 96px`,
	18: `UnitPc = picas -- 1pc = 1/6th of 1in`,
	19: `UnitPt = points -- 1pt = 1/72th of 1in`,
	20: `UnitDot = actual real display pixels -- generally only use internally`,
}

var _UnitsMap = map[Units]string{
	0:  `UnitPx`,
	1:  `UnitDp`,
	2:  `UnitEw`,
	3:  `UnitEh`,
	4:  `UnitPw`,
	5:  `UnitPh`,
	6:  `UnitRem`,
	7:  `UnitEm`,
	8:  `UnitEx`,
	9:  `UnitCh`,
	10: `UnitVw`,
	11: `UnitVh`,
	12: `UnitVmin`,
	13: `UnitVmax`,
	14: `UnitCm`,
	15: `UnitMm`,
	16: `UnitQ`,
	17: `UnitIn`,
	18: `UnitPc`,
	19: `UnitPt`,
	20: `UnitDot`,
}

// String returns the string representation
// of this Units value.
func (i Units) String() string {
	if str, ok := _UnitsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Units value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Units) SetString(s string) error {
	if val, ok := _UnitsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _UnitsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Units")
}

// Int64 returns the Units value as an int64.
func (i Units) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Units value from an int64.
func (i *Units) SetInt64(in int64) {
	*i = Units(in)
}

// Desc returns the description of the Units value.
func (i Units) Desc() string {
	if str, ok := _UnitsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// UnitsValues returns all possible values
// for the type Units.
func UnitsValues() []Units {
	return _UnitsValues
}

// Values returns all possible values
// for the type Units.
func (i Units) Values() []enums.Enum {
	res := make([]enums.Enum, len(_UnitsValues))
	for i, d := range _UnitsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Units.
func (i Units) IsValid() bool {
	_, ok := _UnitsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Units) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Units) UnmarshalText(text []byte) error {
	return i.SetString(string(text))
}
