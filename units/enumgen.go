// Code generated by "goki generate"; DO NOT EDIT.

package units

import (
	"errors"
	"log"
	"strconv"
	"strings"

	"goki.dev/goki/enums"
)

var _UnitsValues = []Units{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}

// UnitsN is the highest valid value
// for type Units, plus one.
const UnitsN Units = 21

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _UnitsNoOp() {
	var x [1]struct{}
	_ = x[UnitDp-(0)]
	_ = x[UnitPx-(1)]
	_ = x[UnitEw-(2)]
	_ = x[UnitEh-(3)]
	_ = x[UnitPw-(4)]
	_ = x[UnitPh-(5)]
	_ = x[UnitRem-(6)]
	_ = x[UnitEm-(7)]
	_ = x[UnitEx-(8)]
	_ = x[UnitCh-(9)]
	_ = x[UnitVw-(10)]
	_ = x[UnitVh-(11)]
	_ = x[UnitVmin-(12)]
	_ = x[UnitVmax-(13)]
	_ = x[UnitCm-(14)]
	_ = x[UnitMm-(15)]
	_ = x[UnitQ-(16)]
	_ = x[UnitIn-(17)]
	_ = x[UnitPc-(18)]
	_ = x[UnitPt-(19)]
	_ = x[UnitDot-(20)]
}

var _UnitsNameToValueMap = map[string]Units{
	`dp`:   0,
	`px`:   1,
	`ew`:   2,
	`eh`:   3,
	`pw`:   4,
	`ph`:   5,
	`rem`:  6,
	`em`:   7,
	`ex`:   8,
	`ch`:   9,
	`vw`:   10,
	`vh`:   11,
	`vmin`: 12,
	`vmax`: 13,
	`cm`:   14,
	`mm`:   15,
	`q`:    16,
	`in`:   17,
	`pc`:   18,
	`pt`:   19,
	`dot`:  20,
}

var _UnitsDescMap = map[Units]string{
	0:  `UnitDp = density-independent pixels; 1dp = 1/160th of 1in`,
	1:  `UnitPx = pixels; 1px = 1/96th of 1in; these are NOT raw display pixels`,
	2:  `UnitEw = percentage of element width (equivalent to CSS % in some contexts)`,
	3:  `UnitEh = percentage of element height (equivalent to CSS % in some contexts)`,
	4:  `UnitPw = percentage of parent width (equivalent to CSS % in some contexts)`,
	5:  `UnitPh = percentage of parent height (equivalent to CSS % in some contexts)`,
	6:  `UnitRem = font size of the root element -- defaults to 12pt scaled by DPI factor`,
	7:  `UnitEm = font size of the element -- fallback to 12pt by default`,
	8:  `UnitEx = x-height of the element&#39;s font (size of &#39;x&#39; glyph) -- fallback to 0.5em by default`,
	9:  `UnitCh = width of the &#39;0&#39; glyph in the element&#39;s font -- fallback to 0.5em by default`,
	10: `UnitVw = 1% of the viewport&#39;s width`,
	11: `UnitVh = 1% of the viewport&#39;s height`,
	12: `UnitVmin = 1% of the viewport&#39;s smaller dimension`,
	13: `UnitVmax = 1% of the viewport&#39;s larger dimension`,
	14: `UnitCm = centimeters -- 1cm = 96px/2.54`,
	15: `UnitMm = millimeters -- 1mm = 1/10th of cm`,
	16: `UnitQ = quarter-millimeters -- 1q = 1/40th of cm`,
	17: `UnitIn = inches -- 1in = 2.54cm = 96px`,
	18: `UnitPc = picas -- 1pc = 1/6th of 1in`,
	19: `UnitPt = points -- 1pt = 1/72th of 1in`,
	20: `UnitDot = actual real display pixels, which are generally only used internally`,
}

var _UnitsMap = map[Units]string{
	0:  `dp`,
	1:  `px`,
	2:  `ew`,
	3:  `eh`,
	4:  `pw`,
	5:  `ph`,
	6:  `rem`,
	7:  `em`,
	8:  `ex`,
	9:  `ch`,
	10: `vw`,
	11: `vh`,
	12: `vmin`,
	13: `vmax`,
	14: `cm`,
	15: `mm`,
	16: `q`,
	17: `in`,
	18: `pc`,
	19: `pt`,
	20: `dot`,
}

// String returns the string representation
// of this Units value.
func (i Units) String() string {
	if str, ok := _UnitsMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Units value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Units) SetString(s string) error {
	if val, ok := _UnitsNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _UnitsNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Units")
}

// Int64 returns the Units value as an int64.
func (i Units) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Units value from an int64.
func (i *Units) SetInt64(in int64) {
	*i = Units(in)
}

// Desc returns the description of the Units value.
func (i Units) Desc() string {
	if str, ok := _UnitsDescMap[i]; ok {
		return str
	}
	return i.String()
}

// UnitsValues returns all possible values
// for the type Units.
func UnitsValues() []Units {
	return _UnitsValues
}

// Values returns all possible values
// for the type Units.
func (i Units) Values() []enums.Enum {
	res := make([]enums.Enum, len(_UnitsValues))
	for i, d := range _UnitsValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Units.
func (i Units) IsValid() bool {
	_, ok := _UnitsMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Units) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Units) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}
