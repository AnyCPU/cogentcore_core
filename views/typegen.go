// Code generated by "core generate"; DO NOT EDIT.

package views

import (
	"image"
	"image/color"
	"reflect"
	"time"

	"cogentcore.org/core/base/fileinfo"
	"cogentcore.org/core/core"
	"cogentcore.org/core/events/key"
	"cogentcore.org/core/icons"
	"cogentcore.org/core/keymap"
	"cogentcore.org/core/styles/units"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

// ColorMapButtonType is the [types.Type] for [ColorMapButton]
var ColorMapButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ColorMapButton", IDName: "color-map-button", Doc: "ColorMapButton displays a color map spectrum and can be clicked on\nto display a dialog for selecting different color map options.\nIt represents a [ColorMapName] value.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "MapName"}}, Instance: &ColorMapButton{}})

// NewColorMapButton returns a new [ColorMapButton] with the given optional parent:
// ColorMapButton displays a color map spectrum and can be clicked on
// to display a dialog for selecting different color map options.
// It represents a [ColorMapName] value.
func NewColorMapButton(parent ...tree.Node) *ColorMapButton {
	return tree.New[*ColorMapButton](parent...)
}

// NodeType returns the [*types.Type] of [ColorMapButton]
func (t *ColorMapButton) NodeType() *types.Type { return ColorMapButtonType }

// New returns a new [*ColorMapButton] value
func (t *ColorMapButton) New() tree.Node { return &ColorMapButton{} }

// SetMapName sets the [ColorMapButton.MapName]
func (t *ColorMapButton) SetMapName(v string) *ColorMapButton { t.MapName = v; return t }

// ColorPickerType is the [types.Type] for [ColorPicker]
var ColorPickerType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ColorPicker", IDName: "color-picker", Doc: "ColorPicker shows a color, using sliders or numbers to set values.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Color", Doc: "the color that we view"}}, Instance: &ColorPicker{}})

// NewColorPicker returns a new [ColorPicker] with the given optional parent:
// ColorPicker shows a color, using sliders or numbers to set values.
func NewColorPicker(parent ...tree.Node) *ColorPicker { return tree.New[*ColorPicker](parent...) }

// NodeType returns the [*types.Type] of [ColorPicker]
func (t *ColorPicker) NodeType() *types.Type { return ColorPickerType }

// New returns a new [*ColorPicker] value
func (t *ColorPicker) New() tree.Node { return &ColorPicker{} }

// ColorButtonType is the [types.Type] for [ColorButton]
var ColorButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ColorButton", IDName: "color-button", Doc: "ColorButton represents a color value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Color"}}, Instance: &ColorButton{}})

// NewColorButton returns a new [ColorButton] with the given optional parent:
// ColorButton represents a color value with a button.
func NewColorButton(parent ...tree.Node) *ColorButton { return tree.New[*ColorButton](parent...) }

// NodeType returns the [*types.Type] of [ColorButton]
func (t *ColorButton) NodeType() *types.Type { return ColorButtonType }

// New returns a new [*ColorButton] value
func (t *ColorButton) New() tree.Node { return &ColorButton{} }

// SetColor sets the [ColorButton.Color]
func (t *ColorButton) SetColor(v color.RGBA) *ColorButton { t.Color = v; return t }

// FilePickerType is the [types.Type] for [FilePicker]
var FilePickerType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.FilePicker", IDName: "file-picker", Doc: "FilePicker is a viewer onto files -- core of the file chooser dialog", Methods: []types.Method{{Name: "UpdateFilesAction", Doc: "UpdateFilesAction updates the list of files and other views for the current path.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "AddPathToFavorites", Doc: "AddPathToFavorites adds the current path to favorites", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DirPathUp", Doc: "DirPathUp moves up one directory in the path", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "NewFolder", Doc: "NewFolder creates a new folder with the given name in the current directory.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"name"}, Returns: []string{"error"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "DirPath", Doc: "path to directory of files to display"}, {Name: "CurrentSelectedFile", Doc: "currently selected file"}, {Name: "Ext", Doc: "target extension(s) (comma separated if multiple, including initial .), if any"}, {Name: "FilterFunc", Doc: "optional styling function"}, {Name: "ExtMap", Doc: "map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value"}, {Name: "Files", Doc: "files for current directory"}, {Name: "SelectedIndex", Doc: "index of currently selected file in Files list (-1 if none)"}, {Name: "Watcher", Doc: "change notify for current dir"}, {Name: "DoneWatcher", Doc: "channel to close watcher watcher"}, {Name: "UpdateMu", Doc: "UpdateFiles mutex"}, {Name: "PrevPath", Doc: "Previous path that was processed via UpdateFiles"}}, Instance: &FilePicker{}})

// NewFilePicker returns a new [FilePicker] with the given optional parent:
// FilePicker is a viewer onto files -- core of the file chooser dialog
func NewFilePicker(parent ...tree.Node) *FilePicker { return tree.New[*FilePicker](parent...) }

// NodeType returns the [*types.Type] of [FilePicker]
func (t *FilePicker) NodeType() *types.Type { return FilePickerType }

// New returns a new [*FilePicker] value
func (t *FilePicker) New() tree.Node { return &FilePicker{} }

// SetFilterFunc sets the [FilePicker.FilterFunc]:
// optional styling function
func (t *FilePicker) SetFilterFunc(v FilePickerFilterFunc) *FilePicker { t.FilterFunc = v; return t }

// SetExtMap sets the [FilePicker.ExtMap]:
// map of lower-cased extensions from Ext -- used for highlighting files with one of these extensions -- maps onto original ext value
func (t *FilePicker) SetExtMap(v map[string]string) *FilePicker { t.ExtMap = v; return t }

// SetFiles sets the [FilePicker.Files]:
// files for current directory
func (t *FilePicker) SetFiles(v ...*fileinfo.FileInfo) *FilePicker { t.Files = v; return t }

// FileButtonType is the [types.Type] for [FileButton]
var FileButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.FileButton", IDName: "file-button", Doc: "FileButton represents a filename value with a button\nthat opens a [FilePicker].", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Filename"}}, Instance: &FileButton{}})

// NewFileButton returns a new [FileButton] with the given optional parent:
// FileButton represents a filename value with a button
// that opens a [FilePicker].
func NewFileButton(parent ...tree.Node) *FileButton { return tree.New[*FileButton](parent...) }

// NodeType returns the [*types.Type] of [FileButton]
func (t *FileButton) NodeType() *types.Type { return FileButtonType }

// New returns a new [*FileButton] value
func (t *FileButton) New() tree.Node { return &FileButton{} }

// SetFilename sets the [FileButton.Filename]
func (t *FileButton) SetFilename(v string) *FileButton { t.Filename = v; return t }

// FuncButtonType is the [types.Type] for [FuncButton]
var FuncButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.FuncButton", IDName: "func-button", Doc: "FuncButton is a button that is set up to call a function when it\nis pressed, using a dialog to prompt the user for any arguments.\nAlso, it automatically sets various properties of the button like\nthe name, text, tooltip, and icon based on the properties of the\nfunction, using [reflect] and [types]. The function must be registered\nwith [types] to get documentation information, but that is not\nrequired; add a `//types:add` comment directive and run `core generate`\nif you want tooltips. If the function is a method, both the method and\nits receiver type must be added to [types] to get documentation.", Directives: []types.Directive{{Tool: "core", Directive: "no-new"}}, Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Func", Doc: "Func is the [types.Func] associated with this button.\nThis function can also be a method, but it must be\nconverted to a [types.Func] first. It should typically\nbe set using [FuncButton.SetFunc]."}, {Name: "ReflectFunc", Doc: "ReflectFunc is the [reflect.Value] of the function or\nmethod associated with this button. It should typically\nbet set using [FuncButton.SetFunc]."}, {Name: "Args", Doc: "Args are the [FuncArg] objects associated with the\narguments of the function. They are automatically set in\n[SetFunc], but they can be customized to configure\ndefault values and other options."}, {Name: "Returns", Doc: "Returns are the [FuncArg] objects associated with the\nreturn values of the function. They are automatically\nset in [SetFunc], but they can be customized to configure\noptions. The [FuncArg.Value]s are not set until the\nfunction is called, and are thus not typically applicable\nto access."}, {Name: "Confirm", Doc: "Confirm is whether to prompt the user for confirmation\nbefore calling the function."}, {Name: "ShowReturn", Doc: "ShowReturn is whether to display the return values of\nthe function (and a success message if there are none).\nThe way that the return values are shown is determined\nby ShowReturnAsDialog. Non-nil error return values will\nalways be shown, even if ShowReturn is set to false."}, {Name: "ShowReturnAsDialog", Doc: "ShowReturnAsDialog, if and only if ShowReturn is true,\nindicates to show the return values of the function in\na dialog, instead of in a snackbar, as they are by default.\nIf there are multiple return values from the function, or if\none of them is a complex type (pointer, struct, slice,\narray, map), then ShowReturnAsDialog will\nautomatically be set to true."}, {Name: "NewWindow", Doc: "NewWindow makes the ReturnDialog a NewWindow dialog\n(if supported by platform)."}, {Name: "WarnUnadded", Doc: "WarnUnadded is whether to log warnings when a function that\nhas not been added to [types] is used. It is on by default and\nmust be set before [FuncButton.SetFunc] is called for it to\nhave any effect."}, {Name: "Context", Doc: "Context is used for opening Dialogs if non-nil."}, {Name: "AfterFunc", Doc: "AfterFunc is an optional function called after the func button\nfunction is executed"}}, Instance: &FuncButton{}})

// NodeType returns the [*types.Type] of [FuncButton]
func (t *FuncButton) NodeType() *types.Type { return FuncButtonType }

// New returns a new [*FuncButton] value
func (t *FuncButton) New() tree.Node { return &FuncButton{} }

// SetConfirm sets the [FuncButton.Confirm]:
// Confirm is whether to prompt the user for confirmation
// before calling the function.
func (t *FuncButton) SetConfirm(v bool) *FuncButton { t.Confirm = v; return t }

// SetShowReturn sets the [FuncButton.ShowReturn]:
// ShowReturn is whether to display the return values of
// the function (and a success message if there are none).
// The way that the return values are shown is determined
// by ShowReturnAsDialog. Non-nil error return values will
// always be shown, even if ShowReturn is set to false.
func (t *FuncButton) SetShowReturn(v bool) *FuncButton { t.ShowReturn = v; return t }

// SetShowReturnAsDialog sets the [FuncButton.ShowReturnAsDialog]:
// ShowReturnAsDialog, if and only if ShowReturn is true,
// indicates to show the return values of the function in
// a dialog, instead of in a snackbar, as they are by default.
// If there are multiple return values from the function, or if
// one of them is a complex type (pointer, struct, slice,
// array, map), then ShowReturnAsDialog will
// automatically be set to true.
func (t *FuncButton) SetShowReturnAsDialog(v bool) *FuncButton { t.ShowReturnAsDialog = v; return t }

// SetNewWindow sets the [FuncButton.NewWindow]:
// NewWindow makes the ReturnDialog a NewWindow dialog
// (if supported by platform).
func (t *FuncButton) SetNewWindow(v bool) *FuncButton { t.NewWindow = v; return t }

// SetWarnUnadded sets the [FuncButton.WarnUnadded]:
// WarnUnadded is whether to log warnings when a function that
// has not been added to [types] is used. It is on by default and
// must be set before [FuncButton.SetFunc] is called for it to
// have any effect.
func (t *FuncButton) SetWarnUnadded(v bool) *FuncButton { t.WarnUnadded = v; return t }

// SetContext sets the [FuncButton.Context]:
// Context is used for opening Dialogs if non-nil.
func (t *FuncButton) SetContext(v core.Widget) *FuncButton { t.Context = v; return t }

// SetAfterFunc sets the [FuncButton.AfterFunc]:
// AfterFunc is an optional function called after the func button
// function is executed
func (t *FuncButton) SetAfterFunc(v func()) *FuncButton { t.AfterFunc = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/views.FuncArg", IDName: "func-arg", Doc: "FuncArg represents one argument or return value of a function\nin the context of a [FuncButton].", Directives: []types.Directive{{Tool: "types", Directive: "add", Args: []string{"-setters"}}}, Fields: []types.Field{{Name: "Name", Doc: "Name is the name of the argument or return value."}, {Name: "Tag", Doc: "Tag contains any tags associated with the argument or return value,\nwhich can be added programmatically to customize [core.Value] behavior."}, {Name: "Value", Doc: "Value is the actual value of the function argument or return value.\nIt can be modified when creating a [FuncButton] to set a default value."}}})

// SetName sets the [FuncArg.Name]:
// Name is the name of the argument or return value.
func (t *FuncArg) SetName(v string) *FuncArg { t.Name = v; return t }

// SetTag sets the [FuncArg.Tag]:
// Tag contains any tags associated with the argument or return value,
// which can be added programmatically to customize [core.Value] behavior.
func (t *FuncArg) SetTag(v reflect.StructTag) *FuncArg { t.Tag = v; return t }

// SetValue sets the [FuncArg.Value]:
// Value is the actual value of the function argument or return value.
// It can be modified when creating a [FuncButton] to set a default value.
func (t *FuncArg) SetValue(v any) *FuncArg { t.Value = v; return t }

// InspectorType is the [types.Type] for [Inspector]
var InspectorType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.Inspector", IDName: "inspector", Doc: "Inspector represents a struct, creating a property editor of the fields --\nconstructs Children widgets to show the field names and editor fields for\neach field, within an overall frame with an optional title, and a button\nbox at the bottom where methods can be invoked", Methods: []types.Method{{Name: "Save", Doc: "Save saves tree to current filename, in a standard JSON-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"error"}}, {Name: "SaveAs", Doc: "SaveAs saves tree to given filename, in a standard JSON-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Open", Doc: "Open opens tree from given filename, in a standard JSON-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "ToggleSelectionMode", Doc: "ToggleSelectionMode toggles the editor between selection mode or not.\nIn selection mode, bounding boxes are rendered around each Widget,\nand clicking on a Widget pulls it up in the inspector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "InspectApp", Doc: "InspectApp displays the underlying operating system app", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Root", Doc: "Root is the root of the tree being edited."}, {Name: "CurrentNode", Doc: "CurrentNode is the currently selected node in the tree."}, {Name: "Filename", Doc: "Filename is the current filename for saving / loading"}}, Instance: &Inspector{}})

// NewInspector returns a new [Inspector] with the given optional parent:
// Inspector represents a struct, creating a property editor of the fields --
// constructs Children widgets to show the field names and editor fields for
// each field, within an overall frame with an optional title, and a button
// box at the bottom where methods can be invoked
func NewInspector(parent ...tree.Node) *Inspector { return tree.New[*Inspector](parent...) }

// NodeType returns the [*types.Type] of [Inspector]
func (t *Inspector) NodeType() *types.Type { return InspectorType }

// New returns a new [*Inspector] value
func (t *Inspector) New() tree.Node { return &Inspector{} }

// SetRoot sets the [Inspector.Root]:
// Root is the root of the tree being edited.
func (t *Inspector) SetRoot(v tree.Node) *Inspector { t.Root = v; return t }

// KeyMapButtonType is the [types.Type] for [KeyMapButton]
var KeyMapButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.KeyMapButton", IDName: "key-map-button", Doc: "KeyMapButton represents a [keymap.MapName] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "MapName"}}, Instance: &KeyMapButton{}})

// NewKeyMapButton returns a new [KeyMapButton] with the given optional parent:
// KeyMapButton represents a [keymap.MapName] value with a button.
func NewKeyMapButton(parent ...tree.Node) *KeyMapButton { return tree.New[*KeyMapButton](parent...) }

// NodeType returns the [*types.Type] of [KeyMapButton]
func (t *KeyMapButton) NodeType() *types.Type { return KeyMapButtonType }

// New returns a new [*KeyMapButton] value
func (t *KeyMapButton) New() tree.Node { return &KeyMapButton{} }

// SetMapName sets the [KeyMapButton.MapName]
func (t *KeyMapButton) SetMapName(v keymap.MapName) *KeyMapButton { t.MapName = v; return t }

// KeyChordButtonType is the [types.Type] for [KeyChordButton]
var KeyChordButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.KeyChordButton", IDName: "key-chord-button", Doc: "KeyChordButton represents a [key.Chord] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Chord"}}, Instance: &KeyChordButton{}})

// NewKeyChordButton returns a new [KeyChordButton] with the given optional parent:
// KeyChordButton represents a [key.Chord] value with a button.
func NewKeyChordButton(parent ...tree.Node) *KeyChordButton {
	return tree.New[*KeyChordButton](parent...)
}

// NodeType returns the [*types.Type] of [KeyChordButton]
func (t *KeyChordButton) NodeType() *types.Type { return KeyChordButtonType }

// New returns a new [*KeyChordButton] value
func (t *KeyChordButton) New() tree.Node { return &KeyChordButton{} }

// SetChord sets the [KeyChordButton.Chord]
func (t *KeyChordButton) SetChord(v key.Chord) *KeyChordButton { t.Chord = v; return t }

// KeyValueTableType is the [types.Type] for [KeyValueTable]
var KeyValueTableType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.KeyValueTable", IDName: "key-value-table", Doc: "KeyValueTable represents a map using two columns of editable key and value widgets.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Map", Doc: "Map is the pointer to the map that we are viewing."}, {Name: "Inline", Doc: "Inline is whether to display the map in one line."}, {Name: "SortValues", Doc: "SortValue is whether to sort by values instead of keys."}, {Name: "ncols", Doc: "ncols is the number of columns to display if the key value table is not inline."}}, Instance: &KeyValueTable{}})

// NewKeyValueTable returns a new [KeyValueTable] with the given optional parent:
// KeyValueTable represents a map using two columns of editable key and value widgets.
func NewKeyValueTable(parent ...tree.Node) *KeyValueTable { return tree.New[*KeyValueTable](parent...) }

// NodeType returns the [*types.Type] of [KeyValueTable]
func (t *KeyValueTable) NodeType() *types.Type { return KeyValueTableType }

// New returns a new [*KeyValueTable] value
func (t *KeyValueTable) New() tree.Node { return &KeyValueTable{} }

// SetMap sets the [KeyValueTable.Map]:
// Map is the pointer to the map that we are viewing.
func (t *KeyValueTable) SetMap(v any) *KeyValueTable { t.Map = v; return t }

// SetInline sets the [KeyValueTable.Inline]:
// Inline is whether to display the map in one line.
func (t *KeyValueTable) SetInline(v bool) *KeyValueTable { t.Inline = v; return t }

// SetSortValues sets the [KeyValueTable.SortValues]:
// SortValue is whether to sort by values instead of keys.
func (t *KeyValueTable) SetSortValues(v bool) *KeyValueTable { t.SortValues = v; return t }

// ListType is the [types.Type] for [List]
var ListType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.List", IDName: "list", Doc: "List represents a slice value with index and value widgets.\nUse [ListBase.BindSelect] to make the list designed for item selection.", Embeds: []types.Field{{Name: "ListBase"}}, Fields: []types.Field{{Name: "StyleFunc", Doc: "StyleFunc is an optional styling function."}}, Instance: &List{}})

// NewList returns a new [List] with the given optional parent:
// List represents a slice value with index and value widgets.
// Use [ListBase.BindSelect] to make the list designed for item selection.
func NewList(parent ...tree.Node) *List { return tree.New[*List](parent...) }

// NodeType returns the [*types.Type] of [List]
func (t *List) NodeType() *types.Type { return ListType }

// New returns a new [*List] value
func (t *List) New() tree.Node { return &List{} }

// SetStyleFunc sets the [List.StyleFunc]:
// StyleFunc is an optional styling function.
func (t *List) SetStyleFunc(v ListStyleFunc) *List { t.StyleFunc = v; return t }

// ListBaseType is the [types.Type] for [ListBase]
var ListBaseType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ListBase", IDName: "list-base", Doc: "ListBase is the base for [List] and [TableView] and any other viewers\nof array-like data. It automatically computes the number of rows that fit\nwithin its allocated space, and manages the offset view window into the full\nlist of items, and supports row selection, copy / paste, Drag-n-Drop, etc.\nUse [ListBase.BindSelect] to make the list designed for item selection.", Methods: []types.Method{{Name: "CopyIndexes", Doc: "CopyIndexes copies selected idxs to system.Clipboard, optionally resetting the selection", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"reset"}}, {Name: "DeleteIndexes", Doc: "DeleteIndexes deletes all selected indexes", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CutIndexes", Doc: "CutIndexes copies selected indexes to system.Clipboard and deletes selected indexes", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "PasteIndex", Doc: "PasteIndex pastes clipboard at given idx", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"idx"}}, {Name: "Duplicate", Doc: "Duplicate copies selected items and inserts them after current selection --\nreturn idx of start of duplicates if successful, else -1", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"int"}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Slice", Doc: "Slice is the pointer to the slice that we are viewing."}, {Name: "ShowIndexes", Doc: "ShowIndexes is whether to show the indexes of rows or not (default false)."}, {Name: "MinRows", Doc: "MinRows specifies the minimum number of rows to display, to ensure\nat least this amount is displayed."}, {Name: "SelectedValue", Doc: "SelectedValue is the current selection value; initially select this value if set."}, {Name: "SelectedIndex", Doc: "index of currently selected item"}, {Name: "InitSelectedIndex", Doc: "index of row to select at start"}, {Name: "SelectedIndexes", Doc: "list of currently selected slice indexes"}, {Name: "lastClick", Doc: "lastClick is the last row that has been clicked on.\nThis is used to prevent erroneous double click events\nfrom being sent when the user clicks on multiple different\nrows in quick succession."}, {Name: "NormalCursor", Doc: "NormalCursor is the cached cursor to display when there\nis no row being hovered."}, {Name: "CurrentCursor", Doc: "CurrentCursor is the cached cursor that should currently be\ndisplayed."}, {Name: "SliceUnderlying", Doc: "SliceUnderlying is the underlying slice value."}, {Name: "hoverRow", Doc: "currently hovered row"}, {Name: "DraggedIndexes", Doc: "list of currently dragged indexes"}, {Name: "VisRows", Doc: "total number of rows visible in allocated display size"}, {Name: "StartIndex", Doc: "starting slice index of visible rows"}, {Name: "SliceSize", Doc: "size of slice"}, {Name: "MakeIter", Doc: "iteration through the configuration process, reset when a new slice type is set"}, {Name: "tmpIndex", Doc: "temp idx state for e.g., dnd"}, {Name: "ElementValue", Doc: "ElementValue is a [reflect.Value] representation of the underlying element type\nwhich is used whenever there are no slice elements available"}, {Name: "maxWidth", Doc: "maximum width of value column in chars, if string"}, {Name: "ReadOnlyKeyNav", Doc: "ReadOnlyKeyNav is whether support key navigation when ReadOnly (default true).\nIt uses a capture of up / down events to manipulate selection, not focus."}, {Name: "SelectMode", Doc: "SelectMode is whether to be in select rows mode or editing mode."}, {Name: "ReadOnlyMultiSelect", Doc: "ReadOnlyMultiSelect: if view is ReadOnly, default selection mode is to choose one row only.\nIf this is true, standard multiple selection logic with modifier keys is instead supported."}, {Name: "InFocusGrab", Doc: "InFocusGrab is a guard for recursive focus grabbing."}, {Name: "isArray", Doc: "isArray is whether the slice is actually an array."}}, Instance: &ListBase{}})

// NewListBase returns a new [ListBase] with the given optional parent:
// ListBase is the base for [List] and [TableView] and any other viewers
// of array-like data. It automatically computes the number of rows that fit
// within its allocated space, and manages the offset view window into the full
// list of items, and supports row selection, copy / paste, Drag-n-Drop, etc.
// Use [ListBase.BindSelect] to make the list designed for item selection.
func NewListBase(parent ...tree.Node) *ListBase { return tree.New[*ListBase](parent...) }

// NodeType returns the [*types.Type] of [ListBase]
func (t *ListBase) NodeType() *types.Type { return ListBaseType }

// New returns a new [*ListBase] value
func (t *ListBase) New() tree.Node { return &ListBase{} }

// SetShowIndexes sets the [ListBase.ShowIndexes]:
// ShowIndexes is whether to show the indexes of rows or not (default false).
func (t *ListBase) SetShowIndexes(v bool) *ListBase { t.ShowIndexes = v; return t }

// SetMinRows sets the [ListBase.MinRows]:
// MinRows specifies the minimum number of rows to display, to ensure
// at least this amount is displayed.
func (t *ListBase) SetMinRows(v int) *ListBase { t.MinRows = v; return t }

// SetSelectedValue sets the [ListBase.SelectedValue]:
// SelectedValue is the current selection value; initially select this value if set.
func (t *ListBase) SetSelectedValue(v any) *ListBase { t.SelectedValue = v; return t }

// SetSelectedIndex sets the [ListBase.SelectedIndex]:
// index of currently selected item
func (t *ListBase) SetSelectedIndex(v int) *ListBase { t.SelectedIndex = v; return t }

// SetInitSelectedIndex sets the [ListBase.InitSelectedIndex]:
// index of row to select at start
func (t *ListBase) SetInitSelectedIndex(v int) *ListBase { t.InitSelectedIndex = v; return t }

// SetReadOnlyKeyNav sets the [ListBase.ReadOnlyKeyNav]:
// ReadOnlyKeyNav is whether support key navigation when ReadOnly (default true).
// It uses a capture of up / down events to manipulate selection, not focus.
func (t *ListBase) SetReadOnlyKeyNav(v bool) *ListBase { t.ReadOnlyKeyNav = v; return t }

// SetReadOnlyMultiSelect sets the [ListBase.ReadOnlyMultiSelect]:
// ReadOnlyMultiSelect: if view is ReadOnly, default selection mode is to choose one row only.
// If this is true, standard multiple selection logic with modifier keys is instead supported.
func (t *ListBase) SetReadOnlyMultiSelect(v bool) *ListBase {
	t.ReadOnlyMultiSelect = v
	return t
}

// ListGridType is the [types.Type] for [ListGrid]
var ListGridType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ListGrid", IDName: "list-grid", Doc: "ListGrid handles the resizing logic for List, TableView.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "MinRows", Doc: "MinRows is set from parent SV"}, {Name: "RowHeight", Doc: "height of a single row, computed during layout"}, {Name: "VisRows", Doc: "total number of rows visible in allocated display size"}, {Name: "BgStripe", Doc: "Various computed backgrounds"}, {Name: "BgSelect", Doc: "Various computed backgrounds"}, {Name: "BgSelectStripe", Doc: "Various computed backgrounds"}, {Name: "BgHover", Doc: "Various computed backgrounds"}, {Name: "BgHoverStripe", Doc: "Various computed backgrounds"}, {Name: "BgHoverSelect", Doc: "Various computed backgrounds"}, {Name: "BgHoverSelectStripe", Doc: "Various computed backgrounds"}, {Name: "LastBackground", Doc: "LastBackground is the background for which modified\nbackgrounds were computed -- don't update if same"}}, Instance: &ListGrid{}})

// NewListGrid returns a new [ListGrid] with the given optional parent:
// ListGrid handles the resizing logic for List, TableView.
func NewListGrid(parent ...tree.Node) *ListGrid { return tree.New[*ListGrid](parent...) }

// NodeType returns the [*types.Type] of [ListGrid]
func (t *ListGrid) NodeType() *types.Type { return ListGridType }

// New returns a new [*ListGrid] value
func (t *ListGrid) New() tree.Node { return &ListGrid{} }

// SetLastBackground sets the [ListGrid.LastBackground]:
// LastBackground is the background for which modified
// backgrounds were computed -- don't update if same
func (t *ListGrid) SetLastBackground(v image.Image) *ListGrid {
	t.LastBackground = v
	return t
}

// ListInlineType is the [types.Type] for [ListInline]
var ListInlineType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.ListInline", IDName: "list-inline", Doc: "ListInline represents a slice within a single line of value widgets.\nThis is typically used for smaller slices.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Slice", Doc: "Slice is the slice that we are viewing."}, {Name: "isArray", Doc: "isArray is whether the slice is actually an array."}}, Instance: &ListInline{}})

// NewListInline returns a new [ListInline] with the given optional parent:
// ListInline represents a slice within a single line of value widgets.
// This is typically used for smaller slices.
func NewListInline(parent ...tree.Node) *ListInline {
	return tree.New[*ListInline](parent...)
}

// NodeType returns the [*types.Type] of [ListInline]
func (t *ListInline) NodeType() *types.Type { return ListInlineType }

// New returns a new [*ListInline] value
func (t *ListInline) New() tree.Node { return &ListInline{} }

// StructViewType is the [types.Type] for [StructView]
var StructViewType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.StructView", IDName: "struct-view", Doc: "StructView represents a struct with rows of field names and editable values.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Struct", Doc: "Struct is the pointer to the struct that we are viewing."}, {Name: "Inline", Doc: "Inline is whether to display the struct in one line."}, {Name: "structFields", Doc: "structFields are the fields of the current struct."}, {Name: "isShouldShower", Doc: "isShouldShower is whether the struct implements [core.ShouldShower], which results\nin additional updating being done at certain points."}}, Instance: &StructView{}})

// NewStructView returns a new [StructView] with the given optional parent:
// StructView represents a struct with rows of field names and editable values.
func NewStructView(parent ...tree.Node) *StructView { return tree.New[*StructView](parent...) }

// NodeType returns the [*types.Type] of [StructView]
func (t *StructView) NodeType() *types.Type { return StructViewType }

// New returns a new [*StructView] value
func (t *StructView) New() tree.Node { return &StructView{} }

// SetStruct sets the [StructView.Struct]:
// Struct is the pointer to the struct that we are viewing.
func (t *StructView) SetStruct(v any) *StructView { t.Struct = v; return t }

// SetInline sets the [StructView.Inline]:
// Inline is whether to display the struct in one line.
func (t *StructView) SetInline(v bool) *StructView { t.Inline = v; return t }

// TableViewType is the [types.Type] for [TableView]
var TableViewType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TableView", IDName: "table-view", Doc: "TableView represents a slice of structs as a table, where the fields are\nthe columns and the elements are the rows. It is a full-featured editor with\nmultiple-selection, cut-and-paste, and drag-and-drop.\nUse [ListBase.BindSelect] to make the table view designed for item selection.", Embeds: []types.Field{{Name: "ListBase"}}, Fields: []types.Field{{Name: "StyleFunc", Doc: "StyleFunc is an optional styling function."}, {Name: "SelectedField", Doc: "SelectedField is the current selection field; initially select value in this field."}, {Name: "SortIndex", Doc: "SortIndex is the current sort index."}, {Name: "SortDescending", Doc: "SortDescending is whether the current sort order is descending."}, {Name: "visibleFields", Doc: "visibleFields are the visible fields."}, {Name: "numVisibleFields", Doc: "numVisibleFields is the number of visible fields."}, {Name: "headerWidths", Doc: "headerWidths has the number of characters in each header, per visibleFields."}, {Name: "colMaxWidths", Doc: "colMaxWidths records maximum width in chars of string type fields."}}, Instance: &TableView{}})

// NewTableView returns a new [TableView] with the given optional parent:
// TableView represents a slice of structs as a table, where the fields are
// the columns and the elements are the rows. It is a full-featured editor with
// multiple-selection, cut-and-paste, and drag-and-drop.
// Use [ListBase.BindSelect] to make the table view designed for item selection.
func NewTableView(parent ...tree.Node) *TableView { return tree.New[*TableView](parent...) }

// NodeType returns the [*types.Type] of [TableView]
func (t *TableView) NodeType() *types.Type { return TableViewType }

// New returns a new [*TableView] value
func (t *TableView) New() tree.Node { return &TableView{} }

// SetStyleFunc sets the [TableView.StyleFunc]:
// StyleFunc is an optional styling function.
func (t *TableView) SetStyleFunc(v TableViewStyleFunc) *TableView { t.StyleFunc = v; return t }

// SetSelectedField sets the [TableView.SelectedField]:
// SelectedField is the current selection field; initially select value in this field.
func (t *TableView) SetSelectedField(v string) *TableView { t.SelectedField = v; return t }

// SetSortIndex sets the [TableView.SortIndex]:
// SortIndex is the current sort index.
func (t *TableView) SetSortIndex(v int) *TableView { t.SortIndex = v; return t }

// SetSortDescending sets the [TableView.SortDescending]:
// SortDescending is whether the current sort order is descending.
func (t *TableView) SetSortDescending(v bool) *TableView { t.SortDescending = v; return t }

// TimePickerType is the [types.Type] for [TimePicker]
var TimePickerType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TimePicker", IDName: "time-picker", Doc: "TimePicker is a widget for picking a time.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time", Doc: "Time is the time that we are viewing"}, {Name: "Hour", Doc: "the raw input hour"}, {Name: "PM", Doc: "whether we are in PM mode (so we have to add 12h to everything)"}}, Instance: &TimePicker{}})

// NewTimePicker returns a new [TimePicker] with the given optional parent:
// TimePicker is a widget for picking a time.
func NewTimePicker(parent ...tree.Node) *TimePicker { return tree.New[*TimePicker](parent...) }

// NodeType returns the [*types.Type] of [TimePicker]
func (t *TimePicker) NodeType() *types.Type { return TimePickerType }

// New returns a new [*TimePicker] value
func (t *TimePicker) New() tree.Node { return &TimePicker{} }

// SetTime sets the [TimePicker.Time]:
// Time is the time that we are viewing
func (t *TimePicker) SetTime(v time.Time) *TimePicker { t.Time = v; return t }

// DatePickerType is the [types.Type] for [DatePicker]
var DatePickerType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.DatePicker", IDName: "date-picker", Doc: "DatePicker is a widget for picking a date.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time", Doc: "Time is the time that we are viewing"}}, Instance: &DatePicker{}})

// NewDatePicker returns a new [DatePicker] with the given optional parent:
// DatePicker is a widget for picking a date.
func NewDatePicker(parent ...tree.Node) *DatePicker { return tree.New[*DatePicker](parent...) }

// NodeType returns the [*types.Type] of [DatePicker]
func (t *DatePicker) NodeType() *types.Type { return DatePickerType }

// New returns a new [*DatePicker] value
func (t *DatePicker) New() tree.Node { return &DatePicker{} }

// TimeInputType is the [types.Type] for [TimeInput]
var TimeInputType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TimeInput", IDName: "time-input", Doc: "TimeInput presents two text fields for editing a date and time,\nboth of which can pull up corresponding picker dialogs.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Time"}}, Instance: &TimeInput{}})

// NewTimeInput returns a new [TimeInput] with the given optional parent:
// TimeInput presents two text fields for editing a date and time,
// both of which can pull up corresponding picker dialogs.
func NewTimeInput(parent ...tree.Node) *TimeInput { return tree.New[*TimeInput](parent...) }

// NodeType returns the [*types.Type] of [TimeInput]
func (t *TimeInput) NodeType() *types.Type { return TimeInputType }

// New returns a new [*TimeInput] value
func (t *TimeInput) New() tree.Node { return &TimeInput{} }

// SetTime sets the [TimeInput.Time]
func (t *TimeInput) SetTime(v time.Time) *TimeInput { t.Time = v; return t }

// DurationInputType is the [types.Type] for [DurationInput]
var DurationInputType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.DurationInput", IDName: "duration-input", Doc: "DurationInput represents a [time.Duration] value with a spinner and unit chooser.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Duration"}, {Name: "Unit", Doc: "Unit is the unit of time."}}, Instance: &DurationInput{}})

// NewDurationInput returns a new [DurationInput] with the given optional parent:
// DurationInput represents a [time.Duration] value with a spinner and unit chooser.
func NewDurationInput(parent ...tree.Node) *DurationInput { return tree.New[*DurationInput](parent...) }

// NodeType returns the [*types.Type] of [DurationInput]
func (t *DurationInput) NodeType() *types.Type { return DurationInputType }

// New returns a new [*DurationInput] value
func (t *DurationInput) New() tree.Node { return &DurationInput{} }

// SetDuration sets the [DurationInput.Duration]
func (t *DurationInput) SetDuration(v time.Duration) *DurationInput { t.Duration = v; return t }

// SetUnit sets the [DurationInput.Unit]:
// Unit is the unit of time.
func (t *DurationInput) SetUnit(v string) *DurationInput { t.Unit = v; return t }

// TreeViewType is the [types.Type] for [TreeView]
var TreeViewType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TreeView", IDName: "tree-view", Doc: "TreeView provides a graphical representation of a tree structure,\nproviding full navigation and manipulation abilities.\n\nIt does not handle layout by itself, so if you want it to scroll\nseparately from the rest of the surrounding context, use [NewTreeViewFrame].\n\nIf the SyncNode field is non-nil, typically via\nSyncRootNode method, then the TreeView mirrors another\ntree structure, and tree editing functions apply to\nthe source tree first, and then to the TreeView by sync.\n\nOtherwise, data can be directly encoded in a TreeView\nderived type, to represent any kind of tree structure\nand associated data.\n\nStandard events.Event are sent to any listeners, including\nSelect, Change, and DoubleClick.  The selected nodes\nare in the root SelectedNodes list.", Methods: []types.Method{{Name: "InsertAfter", Doc: "InsertAfter inserts a new node in the tree\nafter this node, at the same (sibling) level,\nprompting for the type of node to insert.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "InsertBefore", Doc: "InsertBefore inserts a new node in the tree\nbefore this node, at the same (sibling) level,\nprompting for the type of node to insert\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "AddChildNode", Doc: "AddChildNode adds a new child node to this one in the tree,\nprompting the user for the type of node to add\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DeleteNode", Doc: "DeleteNode deletes the tree node or sync node corresponding\nto this view node in the sync tree.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Duplicate", Doc: "Duplicate duplicates the sync node corresponding to this view node in\nthe tree, and inserts the duplicate after this node (as a new sibling).\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditNode", Doc: "EditNode pulls up a StructViewDialog window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "InspectNode", Doc: "InspectNode pulls up a new Inspector window on the node.\nIf SyncNode is set, operates on Sync Tree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "OpenAll", Doc: "OpenAll opens the given node and all of its sub-nodes", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CloseAll", Doc: "CloseAll closes the given node and all of its sub-nodes.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Copy", Doc: "Copy copies to system.Clipboard, optionally resetting the selection.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"reset"}}, {Name: "Cut", Doc: "Cut copies to system.Clipboard and deletes selected items.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Paste", Doc: "Paste pastes clipboard at given node.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "WidgetBase"}}, Fields: []types.Field{{Name: "SyncNode", Doc: "If non-nil, the [tree.Node] that this widget is viewing in the tree (the source)"}, {Name: "Text", Doc: "The text to display for the tree view item label, which automatically\ndefaults to the [tree.Node.Name] of the tree view node. It has no effect\nif [TreeView.SyncNode] is non-nil."}, {Name: "Icon", Doc: "optional icon, displayed to the the left of the text label"}, {Name: "IconOpen", Doc: "icon to use for an open (expanded) branch; defaults to [icons.KeyboardArrowDown]"}, {Name: "IconClosed", Doc: "icon to use for a closed (collapsed) branch; defaults to [icons.KeyboardArrowRight]"}, {Name: "IconLeaf", Doc: "icon to use for a terminal node branch that has no children; defaults to [icons.Blank]"}, {Name: "Indent", Doc: "amount to indent children relative to this node"}, {Name: "OpenDepth", Doc: "OpenDepth is the depth for nodes be initialized as open (default 4).\nNodes beyond this depth will be initialized as closed."}, {Name: "Closed", Doc: "Closed is whether this tree view node is currently toggled closed (children not visible)."}, {Name: "SelectMode", Doc: "SelectMode, when set on the root node, determines whether keyboard movements should update selection."}, {Name: "viewIndex", Doc: "linear index of this node within the entire tree.\nupdated on full rebuilds and may sometimes be off,\nbut close enough for expected uses"}, {Name: "widgetSize", Doc: "size of just this node widget.\nour alloc includes all of our children, but we only draw us."}, {Name: "RootView", Doc: "The cached root of the view. It is automatically set and does not need to be\nset by the end user."}, {Name: "SelectedNodes", Doc: "SelectedNodes holds the currently selected nodes, on the\nRootView node only."}, {Name: "actStateLayer", Doc: "actStateLayer is the actual state layer of the tree view, which\nshould be used when rendering it and its parts (but not its children).\nthe reason that it exists is so that the children of the tree view\n(other tree views) do not inherit its stateful background color, as\nthat does not look good."}, {Name: "inOpen", Doc: "inOpen is set in the Open method to prevent recursive opening for lazy-open nodes."}}, Instance: &TreeView{}})

// NewTreeView returns a new [TreeView] with the given optional parent:
// TreeView provides a graphical representation of a tree structure,
// providing full navigation and manipulation abilities.
//
// It does not handle layout by itself, so if you want it to scroll
// separately from the rest of the surrounding context, use [NewTreeViewFrame].
//
// If the SyncNode field is non-nil, typically via
// SyncRootNode method, then the TreeView mirrors another
// tree structure, and tree editing functions apply to
// the source tree first, and then to the TreeView by sync.
//
// Otherwise, data can be directly encoded in a TreeView
// derived type, to represent any kind of tree structure
// and associated data.
//
// Standard events.Event are sent to any listeners, including
// Select, Change, and DoubleClick.  The selected nodes
// are in the root SelectedNodes list.
func NewTreeView(parent ...tree.Node) *TreeView { return tree.New[*TreeView](parent...) }

// NodeType returns the [*types.Type] of [TreeView]
func (t *TreeView) NodeType() *types.Type { return TreeViewType }

// New returns a new [*TreeView] value
func (t *TreeView) New() tree.Node { return &TreeView{} }

// SetText sets the [TreeView.Text]:
// The text to display for the tree view item label, which automatically
// defaults to the [tree.Node.Name] of the tree view node. It has no effect
// if [TreeView.SyncNode] is non-nil.
func (t *TreeView) SetText(v string) *TreeView { t.Text = v; return t }

// SetIcon sets the [TreeView.Icon]:
// optional icon, displayed to the the left of the text label
func (t *TreeView) SetIcon(v icons.Icon) *TreeView { t.Icon = v; return t }

// SetIconOpen sets the [TreeView.IconOpen]:
// icon to use for an open (expanded) branch; defaults to [icons.KeyboardArrowDown]
func (t *TreeView) SetIconOpen(v icons.Icon) *TreeView { t.IconOpen = v; return t }

// SetIconClosed sets the [TreeView.IconClosed]:
// icon to use for a closed (collapsed) branch; defaults to [icons.KeyboardArrowRight]
func (t *TreeView) SetIconClosed(v icons.Icon) *TreeView { t.IconClosed = v; return t }

// SetIconLeaf sets the [TreeView.IconLeaf]:
// icon to use for a terminal node branch that has no children; defaults to [icons.Blank]
func (t *TreeView) SetIconLeaf(v icons.Icon) *TreeView { t.IconLeaf = v; return t }

// SetIndent sets the [TreeView.Indent]:
// amount to indent children relative to this node
func (t *TreeView) SetIndent(v units.Value) *TreeView { t.Indent = v; return t }

// SetOpenDepth sets the [TreeView.OpenDepth]:
// OpenDepth is the depth for nodes be initialized as open (default 4).
// Nodes beyond this depth will be initialized as closed.
func (t *TreeView) SetOpenDepth(v int) *TreeView { t.OpenDepth = v; return t }

// SetClosed sets the [TreeView.Closed]:
// Closed is whether this tree view node is currently toggled closed (children not visible).
func (t *TreeView) SetClosed(v bool) *TreeView { t.Closed = v; return t }

// SetSelectMode sets the [TreeView.SelectMode]:
// SelectMode, when set on the root node, determines whether keyboard movements should update selection.
func (t *TreeView) SetSelectMode(v bool) *TreeView { t.SelectMode = v; return t }

// SetRootView sets the [TreeView.RootView]:
// The cached root of the view. It is automatically set and does not need to be
// set by the end user.
func (t *TreeView) SetRootView(v *TreeView) *TreeView { t.RootView = v; return t }

// SetSelectedNodes sets the [TreeView.SelectedNodes]:
// SelectedNodes holds the currently selected nodes, on the
// RootView node only.
func (t *TreeView) SetSelectedNodes(v ...TreeViewer) *TreeView { t.SelectedNodes = v; return t }

// SliceButtonType is the [types.Type] for [SliceButton]
var SliceButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.SliceButton", IDName: "slice-button", Doc: "SliceButton represents a slice or array value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Slice"}}, Instance: &SliceButton{}})

// NewSliceButton returns a new [SliceButton] with the given optional parent:
// SliceButton represents a slice or array value with a button.
func NewSliceButton(parent ...tree.Node) *SliceButton { return tree.New[*SliceButton](parent...) }

// NodeType returns the [*types.Type] of [SliceButton]
func (t *SliceButton) NodeType() *types.Type { return SliceButtonType }

// New returns a new [*SliceButton] value
func (t *SliceButton) New() tree.Node { return &SliceButton{} }

// SetSlice sets the [SliceButton.Slice]
func (t *SliceButton) SetSlice(v any) *SliceButton { t.Slice = v; return t }

// StructButtonType is the [types.Type] for [StructButton]
var StructButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.StructButton", IDName: "struct-button", Doc: "StructButton represents a slice or array value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Struct"}}, Instance: &StructButton{}})

// NewStructButton returns a new [StructButton] with the given optional parent:
// StructButton represents a slice or array value with a button.
func NewStructButton(parent ...tree.Node) *StructButton { return tree.New[*StructButton](parent...) }

// NodeType returns the [*types.Type] of [StructButton]
func (t *StructButton) NodeType() *types.Type { return StructButtonType }

// New returns a new [*StructButton] value
func (t *StructButton) New() tree.Node { return &StructButton{} }

// SetStruct sets the [StructButton.Struct]
func (t *StructButton) SetStruct(v any) *StructButton { t.Struct = v; return t }

// MapButtonType is the [types.Type] for [MapButton]
var MapButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.MapButton", IDName: "map-button", Doc: "MapButton represents a slice or array value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Map"}}, Instance: &MapButton{}})

// NewMapButton returns a new [MapButton] with the given optional parent:
// MapButton represents a slice or array value with a button.
func NewMapButton(parent ...tree.Node) *MapButton { return tree.New[*MapButton](parent...) }

// NodeType returns the [*types.Type] of [MapButton]
func (t *MapButton) NodeType() *types.Type { return MapButtonType }

// New returns a new [*MapButton] value
func (t *MapButton) New() tree.Node { return &MapButton{} }

// SetMap sets the [MapButton.Map]
func (t *MapButton) SetMap(v any) *MapButton { t.Map = v; return t }

// TreeButtonType is the [types.Type] for [TreeButton]
var TreeButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TreeButton", IDName: "tree-button", Doc: "TreeButton represents a [tree.Node] value with a button.", Embeds: []types.Field{{Name: "Button"}}, Fields: []types.Field{{Name: "Tree"}}, Instance: &TreeButton{}})

// NewTreeButton returns a new [TreeButton] with the given optional parent:
// TreeButton represents a [tree.Node] value with a button.
func NewTreeButton(parent ...tree.Node) *TreeButton { return tree.New[*TreeButton](parent...) }

// NodeType returns the [*types.Type] of [TreeButton]
func (t *TreeButton) NodeType() *types.Type { return TreeButtonType }

// New returns a new [*TreeButton] value
func (t *TreeButton) New() tree.Node { return &TreeButton{} }

// SetTree sets the [TreeButton.Tree]
func (t *TreeButton) SetTree(v tree.Node) *TreeButton { t.Tree = v; return t }

// TypeChooserType is the [types.Type] for [TypeChooser]
var TypeChooserType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.TypeChooser", IDName: "type-chooser", Doc: "TypeChooser represents a [types.Type] value with a chooser.", Embeds: []types.Field{{Name: "Chooser"}}, Instance: &TypeChooser{}})

// NewTypeChooser returns a new [TypeChooser] with the given optional parent:
// TypeChooser represents a [types.Type] value with a chooser.
func NewTypeChooser(parent ...tree.Node) *TypeChooser { return tree.New[*TypeChooser](parent...) }

// NodeType returns the [*types.Type] of [TypeChooser]
func (t *TypeChooser) NodeType() *types.Type { return TypeChooserType }

// New returns a new [*TypeChooser] value
func (t *TypeChooser) New() tree.Node { return &TypeChooser{} }

// IconButtonType is the [types.Type] for [IconButton]
var IconButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.IconButton", IDName: "icon-button", Doc: "IconButton represents an [icons.Icon] with a [core.Button] that opens\na dialog for selecting the icon.", Embeds: []types.Field{{Name: "Button"}}, Instance: &IconButton{}})

// NewIconButton returns a new [IconButton] with the given optional parent:
// IconButton represents an [icons.Icon] with a [core.Button] that opens
// a dialog for selecting the icon.
func NewIconButton(parent ...tree.Node) *IconButton { return tree.New[*IconButton](parent...) }

// NodeType returns the [*types.Type] of [IconButton]
func (t *IconButton) NodeType() *types.Type { return IconButtonType }

// New returns a new [*IconButton] value
func (t *IconButton) New() tree.Node { return &IconButton{} }

// FontButtonType is the [types.Type] for [FontButton]
var FontButtonType = types.AddType(&types.Type{Name: "cogentcore.org/core/views.FontButton", IDName: "font-button", Doc: "FontButton represents a [core.FontName] with a [core.Button] that opens\na dialog for selecting the font family.", Embeds: []types.Field{{Name: "Button"}}, Instance: &FontButton{}})

// NewFontButton returns a new [FontButton] with the given optional parent:
// FontButton represents a [core.FontName] with a [core.Button] that opens
// a dialog for selecting the font family.
func NewFontButton(parent ...tree.Node) *FontButton { return tree.New[*FontButton](parent...) }

// NodeType returns the [*types.Type] of [FontButton]
func (t *FontButton) NodeType() *types.Type { return FontButtonType }

// New returns a new [*FontButton] value
func (t *FontButton) New() tree.Node { return &FontButton{} }
