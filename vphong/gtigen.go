// Code generated by "goki generate ./..."; DO NOT EDIT.

package vphong

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Colors",
	Doc:        "Colors are the material colors with padding for direct uploading to shader",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "mat32.Vec4", Doc: "main color of surface, used for both ambient and diffuse color in standard Phong model -- alpha component determines transparency -- note that transparent objects require more complex rendering", Directives: gti.Directives{}}},
		{"ShinyBright", &gti.Field{Name: "ShinyBright", Type: "mat32.Vec4", Doc: "X = shininess spread factor, Y = shine reflection factor, Z = brightness factor:  shiny = specular shininess factor -- how focally the surface shines back directional light -- this is an exponential factor, with 0 = very broad diffuse reflection, and higher values (typically max of 128) having a smaller more focal specular reflection.  Shine reflect = 1 for full shine white reflection (specular) color, 0 = no shine reflection.  bright = overall multiplier on final computed color value -- can be used to tune the overall brightness of various surfaces relative to each other for a given set of lighting parameters.  W is used for Tex idx.", Directives: gti.Directives{}}},
		{"Emissive", &gti.Field{Name: "Emissive", Type: "mat32.Vec4", Doc: "color that surface emits independent of any lighting -- i.e., glow -- can be used for marking lights with an object", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.NLights",
	Doc:        "Number of different lights active",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Ambient", &gti.Field{Name: "Ambient", Type: "int32", Doc: "", Directives: gti.Directives{}}},
		{"Dir", &gti.Field{Name: "Dir", Type: "int32", Doc: "", Directives: gti.Directives{}}},
		{"Point", &gti.Field{Name: "Point", Type: "int32", Doc: "", Directives: gti.Directives{}}},
		{"Spot", &gti.Field{Name: "Spot", Type: "int32", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.AmbientLight",
	Doc:        "AmbientLight provides diffuse uniform lighting -- typically only one of these",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "mat32.Vec3", Doc: "color of light -- multiplies ambient color of materials", Directives: gti.Directives{}}},
		{"pad0", &gti.Field{Name: "pad0", Type: "float32", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.DirLight",
	Doc:        "DirLight is directional light, which is assumed to project light toward\nthe origin based on its position, with no attenuation, like the Sun.\nFor rendering, the position is negated and normalized to get the direction\nvector (i.e., absolute distance doesn't matter)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "mat32.Vec3", Doc: "color of light at full intensity", Directives: gti.Directives{}}},
		{"pad0", &gti.Field{Name: "pad0", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec3", Doc: "position of light vector -- think of it shining down from this position toward the origin, i.e., the negation of this position is the vector.", Directives: gti.Directives{}}},
		{"pad1", &gti.Field{Name: "pad1", Type: "float32", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.PointLight",
	Doc:        "PointLight is an omnidirectional light with a position\nand associated decay factors, which divide the light intensity as a function of\nlinear and quadratic distance.  The quadratic factor dominates at longer distances.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "mat32.Vec3", Doc: "color of light a full intensity", Directives: gti.Directives{}}},
		{"pad0", &gti.Field{Name: "pad0", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec3", Doc: "position of light in world coordinates", Directives: gti.Directives{}}},
		{"pad1", &gti.Field{Name: "pad1", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Decay", &gti.Field{Name: "Decay", Type: "mat32.Vec3", Doc: "X = Linear, Y = Quad: Distance linear decay factor -- defaults to .1; Distance quadratic decay factor -- defaults to .01 -- dominates at longer distances", Directives: gti.Directives{}}},
		{"pad2", &gti.Field{Name: "pad2", Type: "float32", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.SpotLight",
	Doc:        "Spotlight is a light with a position and direction and\nassociated decay factors and angles,\nwhich divide the light intensity as a function of\nlinear and quadratic distance.\nThe quadratic factor dominates at longer distances.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Color", &gti.Field{Name: "Color", Type: "mat32.Vec3", Doc: "color of light a full intensity", Directives: gti.Directives{}}},
		{"pad0", &gti.Field{Name: "pad0", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec3", Doc: "position of light in world coordinates", Directives: gti.Directives{}}},
		{"pad1", &gti.Field{Name: "pad1", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Dir", &gti.Field{Name: "Dir", Type: "mat32.Vec3", Doc: "direction of light vector", Directives: gti.Directives{}}},
		{"pad2", &gti.Field{Name: "pad2", Type: "float32", Doc: "", Directives: gti.Directives{}}},
		{"Decay", &gti.Field{Name: "Decay", Type: "mat32.Vec4", Doc: "X = Angular Decay, Y = CutAngle, Z = LinDecay, W = QuadDecay: Angular decay factor -- defaults to 15; Cut off angle (in degrees) -- defaults to 45 -- max of 90; Distance linear decay factor -- defaults to 1; Distance quadratic decay factor -- defaults to 1 -- dominates at longer distances", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Mesh",
	Doc:        "Mesh records the number of elements in an indexed triangle mesh,\nwhich always includes normals and texture coordinates, and\noptionally per-vertex colors.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NVtx", &gti.Field{Name: "NVtx", Type: "int", Doc: "number of vertex points, as mat32.Vec3 -- always includes mat32.Vec3 normals and mat32.Vec2 texture coordinates", Directives: gti.Directives{}}},
		{"NIdx", &gti.Field{Name: "NIdx", Type: "int", Doc: "number of indexes, as mat32.ArrayU32", Directives: gti.Directives{}}},
		{"HasColor", &gti.Field{Name: "HasColor", Type: "bool", Doc: "has per-vertex colors, as mat32.Vec4 per vertex", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Mtxs",
	Doc:        "Mtxs contains the camera view and projection matricies, for uniform uploading",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"View", &gti.Field{Name: "View", Type: "mat32.Mat4", Doc: "View Matrix: transforms world into camera-centered, 3D coordinates", Directives: gti.Directives{}}},
		{"Prjn", &gti.Field{Name: "Prjn", Type: "mat32.Mat4", Doc: "Projection Matrix: transforms camera coords into 2D render coordinates", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Sets",
	Doc:        "Sets are variable set numbers - must coordinate with System sets!",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.CurRender",
	Doc:        "CurRender holds info about the current render as updated by\nUse* methods -- determines which pipeline is used.\nDefault is single color.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"DescIdx", &gti.Field{Name: "DescIdx", Type: "int", Doc: "index of descriptor collection to use -- for threaded / parallel rendering -- see vgup.Vars NDescs for more info", Directives: gti.Directives{}}},
		{"UseTexture", &gti.Field{Name: "UseTexture", Type: "bool", Doc: "a texture was selected -- if true, overrides other options", Directives: gti.Directives{}}},
		{"UseVtxColor", &gti.Field{Name: "UseVtxColor", Type: "bool", Doc: "a per-vertex color was selected", Directives: gti.Directives{}}},
		{"ModelMtx", &gti.Field{Name: "ModelMtx", Type: "mat32.Mat4", Doc: "current model pose matrix", Directives: gti.Directives{}}},
		{"VPMtx", &gti.Field{Name: "VPMtx", Type: "Mtxs", Doc: "camera view and projection matrixes", Directives: gti.Directives{}}},
		{"Color", &gti.Field{Name: "Color", Type: "Colors", Doc: "current color surface properties", Directives: gti.Directives{}}},
		{"TexPars", &gti.Field{Name: "TexPars", Type: "TexPars", Doc: "texture parameters -- repeat, offset", Directives: gti.Directives{}}},
		{"TexIdx", &gti.Field{Name: "TexIdx", Type: "int", Doc: "index of currently-selected texture", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.PushU",
	Doc:        "PushU is the push constants structure, holding everything that\nupdates per object -- avoids any limitations on capacity.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ModelMtx", &gti.Field{Name: "ModelMtx", Type: "mat32.Mat4", Doc: "Model Matrix: poses object in world coordinates", Directives: gti.Directives{}}},
		{"Color", &gti.Field{Name: "Color", Type: "Colors", Doc: "surface colors", Directives: gti.Directives{}}},
		{"Tex", &gti.Field{Name: "Tex", Type: "TexPars", Doc: "texture parameters", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Texture",
	Doc:        "Texture has texture image -- stored as image.RGBA for GPU compatibility",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Image", &gti.Field{Name: "Image", Type: "*image.RGBA", Doc: "", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.TexPars",
	Doc:        "TexPars holds texture parameters: how often to repeat the texture image and offset",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Repeat", &gti.Field{Name: "Repeat", Type: "mat32.Vec2", Doc: "how often to repeat the texture in each direction", Directives: gti.Directives{}}},
		{"Off", &gti.Field{Name: "Off", Type: "mat32.Vec2", Doc: "offset for when to start the texure in each direction", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vphong.Phong",
	Doc:        "Phong implements standard Blinn-Phong rendering pipelines in a vgpu System.\nMust Add all Lights, Meshes, Colors, Textures first, and call\nConfig() to configure everything prior to first RenderStart.\n\nMeshes are configured initially with numbers of points, then\nafter Config(), points are set by calling MeshFloatsBy* and\nassigning values.\n\nIf any changes are made to numbers or sizes of anything,\nyou must call Config() again.\n\nChanges to data only can be synced by calling Sync()\n\nRendering starts with RenderStart, followed by Use* calls\nto specify the parameters for each item, and then a Draw call\nto add the rendering command, followed by RenderEnd.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NLights", &gti.Field{Name: "NLights", Type: "NLights", Doc: "number of each type of light", Directives: gti.Directives{}}},
		{"Ambient", &gti.Field{Name: "Ambient", Type: "[MaxLights]AmbientLight", Doc: "ambient lights", Directives: gti.Directives{}}},
		{"Dir", &gti.Field{Name: "Dir", Type: "[MaxLights]DirLight", Doc: "directional lights", Directives: gti.Directives{}}},
		{"Point", &gti.Field{Name: "Point", Type: "[MaxLights]PointLight", Doc: "point lights", Directives: gti.Directives{}}},
		{"Spot", &gti.Field{Name: "Spot", Type: "[MaxLights]SpotLight", Doc: "spot lights", Directives: gti.Directives{}}},
		{"Wireframe", &gti.Field{Name: "Wireframe", Type: "bool", Doc: "[def: false] render using wireframe instead of filled polygons -- this must be set prior to configuring the Phong rendering system", Directives: gti.Directives{}}},
		{"Cur", &gti.Field{Name: "Cur", Type: "CurRender", Doc: "state for current rendering", Directives: gti.Directives{}}},
		{"Meshes", &gti.Field{Name: "Meshes", Type: "ordmap.Map[string, *Mesh]", Doc: "meshes -- holds all the mesh data -- must be configured prior to rendering", Directives: gti.Directives{}}},
		{"Textures", &gti.Field{Name: "Textures", Type: "ordmap.Map[string, *Texture]", Doc: "textures -- must be configured prior to rendering -- a maximum of 16 textures is supported for full cross-platform portability", Directives: gti.Directives{}}},
		{"Colors", &gti.Field{Name: "Colors", Type: "ordmap.Map[string, *Colors]", Doc: "colors, optionally available for looking up by name -- not used directly in rendering", Directives: gti.Directives{}}},
		{"Sys", &gti.Field{Name: "Sys", Type: "vgpu.System", Doc: "rendering system", Directives: gti.Directives{}}},
		{"UpdtMu", &gti.Field{Name: "UpdtMu", Type: "sync.Mutex", Doc: "[view: -] mutex on updating", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
