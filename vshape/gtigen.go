// Code generated by "goki generate ./..."; DO NOT EDIT.

package vshape

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Box",
	Doc:        "Box is a rectangular-shaped solid (cuboid)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "mat32.Vec3", Doc: "size along each dimension", Directives: gti.Directives{}}},
		{"Segs", &gti.Field{Name: "Segs", Type: "mat32.Vec3i", Doc: "number of segments to divide each plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Capsule",
	Doc:        "Capsule is a generalized capsule shape: a cylinder with hemisphere end caps.\nSupports different radii on each end.\nHeight is along the Y axis -- total height is Height + TopRad + BotRad.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", Doc: "height of the cylinder portion", Directives: gti.Directives{}}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", Doc: "radius of the top -- set to 0 to omit top cap", Directives: gti.Directives{}}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", Doc: "radius of the bottom -- set to 0 to omit bottom cap", Directives: gti.Directives{}}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", Doc: "[min: 1] number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", Doc: "number of height segments", Directives: gti.Directives{}}},
		{"CapSegs", &gti.Field{Name: "CapSegs", Type: "int", Doc: "number of segments in the hemisphere cap ends (16 is a reasonable default)", Directives: gti.Directives{}}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] total angle to generate in degrees (max 360)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Cylinder",
	Doc:        "Cylinder is a generalized cylinder shape, including a cone\nor truncated cone by having different size circles at either end.\nHeight is up along the Y axis.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", Doc: "height of the cylinder", Directives: gti.Directives{}}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", Doc: "[min: 1] number of radial segments (32 is a reasonable default for full circle)", Directives: gti.Directives{}}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", Doc: "number of height segments", Directives: gti.Directives{}}},
		{"Top", &gti.Field{Name: "Top", Type: "bool", Doc: "render the top disc", Directives: gti.Directives{}}},
		{"Bottom", &gti.Field{Name: "Bottom", Type: "bool", Doc: "render the bottom disc", Directives: gti.Directives{}}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] starting angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] total angle to generate in degrees (max 360)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.ShapeGroup",
	Doc:        "ShapeGroup is a group of shapes -- returns summary data for shape elements",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Shapes", &gti.Field{Name: "Shapes", Type: "[]Shape", Doc: "list of shapes in group", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Lines",
	Doc:        "Lines are lines rendered as long thin boxes defined by points\nand width parameters.  The Mesh must be drawn in the XY plane (i.e., use Z = 0\nor a constant unless specifically relevant to have full 3D variation).\nRotate the solid to put into other planes.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Points", &gti.Field{Name: "Points", Type: "[]mat32.Vec3", Doc: "line points (must be 2 or more)", Directives: gti.Directives{}}},
		{"Width", &gti.Field{Name: "Width", Type: "mat32.Vec2", Doc: "line width, Y = height perpendicular to line direction, and X = depth", Directives: gti.Directives{}}},
		{"Colors", &gti.Field{Name: "Colors", Type: "[]color.Color", Doc: "optional colors for each point -- actual color interpolates between", Directives: gti.Directives{}}},
		{"Closed", &gti.Field{Name: "Closed", Type: "bool", Doc: "if true, connect the first and last points to form a closed shape", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Plane",
	Doc:        "Plane is a flat 2D plane, which can be oriented along any\naxis facing either positive or negative",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NormAxis", &gti.Field{Name: "NormAxis", Type: "mat32.Dims", Doc: "axis along which the normal perpendicular to the plane points.  E.g., if the Y axis is specified, then it is a standard X-Z ground plane -- see also NormNeg for whether it is facing in the positive or negative of the given axis.", Directives: gti.Directives{}}},
		{"NormNeg", &gti.Field{Name: "NormNeg", Type: "bool", Doc: "if false, the plane normal facing in the positive direction along specified NormAxis, otherwise it faces in the negative if true", Directives: gti.Directives{}}},
		{"Size", &gti.Field{Name: "Size", Type: "mat32.Vec2", Doc: "2D size of plane", Directives: gti.Directives{}}},
		{"Segs", &gti.Field{Name: "Segs", Type: "mat32.Vec2i", Doc: "number of segments to divide plane into (enforced to be at least 1) -- may potentially increase rendering quality to have > 1", Directives: gti.Directives{}}},
		{"Offset", &gti.Field{Name: "Offset", Type: "float32", Doc: "offset from origin along direction of normal to the plane", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Shape",
	Doc:        "Shape is an interface for all shape-constructing elements",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.ShapeBase",
	Doc:        "ShapeBase is the base shape element",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"VtxOff", &gti.Field{Name: "VtxOff", Type: "int", Doc: "vertex offset, in points", Directives: gti.Directives{}}},
		{"IdxOff", &gti.Field{Name: "IdxOff", Type: "int", Doc: "index offset, in points", Directives: gti.Directives{}}},
		{"CBBox", &gti.Field{Name: "CBBox", Type: "mat32.Box3", Doc: "cubic bounding box in local coords", Directives: gti.Directives{}}},
		{"Pos", &gti.Field{Name: "Pos", Type: "mat32.Vec3", Doc: "all shapes take a 3D position offset to enable composition", Directives: gti.Directives{}}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Sphere",
	Doc:        "Sphere is a sphere shape (can be a partial sphere too)",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", Doc: "radius of the sphere", Directives: gti.Directives{}}},
		{"WidthSegs", &gti.Field{Name: "WidthSegs", Type: "int", Doc: "[min: 3] number of segments around the width of the sphere (32 is reasonable default for full circle)", Directives: gti.Directives{}}},
		{"HeightSegs", &gti.Field{Name: "HeightSegs", Type: "int", Doc: "[min: 3] number of height segments (32 is reasonable default for full height)", Directives: gti.Directives{}}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] starting radial angle in degrees, relative to -1,0,0 left side starting point", Directives: gti.Directives{}}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}}},
		{"ElevStart", &gti.Field{Name: "ElevStart", Type: "float32", Doc: "[min: 0] [max: 180] [step: 5] starting elevation (height) angle in degrees - 0 = top of sphere, and Pi is bottom", Directives: gti.Directives{}}},
		{"ElevLen", &gti.Field{Name: "ElevLen", Type: "float32", Doc: "[min: 0] [max: 180] [step: 5] total angle to generate in degrees (max = 180)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "goki.dev/vgpu/v2/vshape.Torus",
	Doc:        "Torus is a torus mesh, defined by the radius of the solid tube and the\nlarger radius of the ring.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", Doc: "larger radius of the torus ring", Directives: gti.Directives{}}},
		{"TubeRadius", &gti.Field{Name: "TubeRadius", Type: "float32", Doc: "radius of the solid tube", Directives: gti.Directives{}}},
		{"RadialSegs", &gti.Field{Name: "RadialSegs", Type: "int", Doc: "[min: 1] number of segments around the radius of the torus (32 is reasonable default for full circle)", Directives: gti.Directives{}}},
		{"TubeSegs", &gti.Field{Name: "TubeSegs", Type: "int", Doc: "[min: 1] number of segments for the tube itself (32 is reasonable default for full height)", Directives: gti.Directives{}}},
		{"AngStart", &gti.Field{Name: "AngStart", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] starting radial angle in degrees relative to 1,0,0 starting point", Directives: gti.Directives{}}},
		{"AngLen", &gti.Field{Name: "AngLen", Type: "float32", Doc: "[min: 0] [max: 360] [step: 5] total radial angle to generate in degrees (max = 360)", Directives: gti.Directives{}}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"ShapeBase", &gti.Field{Name: "ShapeBase", Type: "ShapeBase", Doc: "", Directives: gti.Directives{}}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
