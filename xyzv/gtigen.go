// Code generated by "goki generate"; DO NOT EDIT.

package xyzv

import (
	"goki.dev/goki/gti"
	"goki.dev/goki/ki"
	"goki.dev/goki/ordmap"
	"goki.dev/goki/xyz"
)

// ManipPtType is the [gti.Type] for [ManipPt]
var ManipPtType = gti.AddType(&gti.Type{
	Name:      "goki.dev/goki/xyzv.ManipPt",
	ShortName: "xyzv.ManipPt",
	IDName:    "manip-pt",
	Doc:       "ManipPt is a manipulation control point",
	Directives: gti.Directives{
		&gti.Directive{Tool: "goki", Directive: "no-new", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/goki/xyz.Solid", LocalType: "xyz.Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &ManipPt{},
})

// KiType returns the [*gti.Type] of [ManipPt]
func (t *ManipPt) KiType() *gti.Type {
	return ManipPtType
}

// New returns a new [*ManipPt] value
func (t *ManipPt) New() ki.Ki {
	return &ManipPt{}
}

// SetMat sets the [ManipPt.Mat]
func (t *ManipPt) SetMat(v xyz.Material) *ManipPt {
	t.Mat = v
	return t
}

// SceneType is the [gti.Type] for [Scene]
var SceneType = gti.AddType(&gti.Type{
	Name:       "goki.dev/goki/xyzv.Scene",
	ShortName:  "xyzv.Scene",
	IDName:     "scene",
	Doc:        "Scene is a gi.Widget that manages a xyz.Scene,\nproviding the basic rendering logic for the 3D scene\nin the 2D gi gui context.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Scene", &gti.Field{Name: "Scene", Type: "*goki.dev/goki/xyz.Scene", LocalType: "*xyz.Scene", Doc: "Scene is the 3D Scene", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"SelMode", &gti.Field{Name: "SelMode", Type: "goki.dev/goki/xyzv.SelModes", LocalType: "SelModes", Doc: "how to deal with selection / manipulation events", Directives: gti.Directives{}, Tag: ""}},
		{"CurSel", &gti.Field{Name: "CurSel", Type: "goki.dev/goki/xyz.Node", LocalType: "xyz.Node", Doc: "currently selected node", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
		{"CurManipPt", &gti.Field{Name: "CurManipPt", Type: "*goki.dev/goki/xyzv.ManipPt", LocalType: "*ManipPt", Doc: "currently selected manipulation control point", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
		{"SelParams", &gti.Field{Name: "SelParams", Type: "goki.dev/goki/xyzv.SelParams", LocalType: "SelParams", Doc: "parameters for selection / manipulation box", Directives: gti.Directives{}, Tag: "view:\"inline\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"WidgetBase", &gti.Field{Name: "WidgetBase", Type: "goki.dev/goki/gi.WidgetBase", LocalType: "gi.WidgetBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Scene{},
})

// NewScene adds a new [Scene] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewScene(par ki.Ki, name ...string) *Scene {
	return par.NewChild(SceneType, name...).(*Scene)
}

// KiType returns the [*gti.Type] of [Scene]
func (t *Scene) KiType() *gti.Type {
	return SceneType
}

// New returns a new [*Scene] value
func (t *Scene) New() ki.Ki {
	return &Scene{}
}

// SetSelMode sets the [Scene.SelMode]:
// how to deal with selection / manipulation events
func (t *Scene) SetSelMode(v SelModes) *Scene {
	t.SelMode = v
	return t
}

// SetCurSel sets the [Scene.CurSel]:
// currently selected node
func (t *Scene) SetCurSel(v xyz.Node) *Scene {
	t.CurSel = v
	return t
}

// SetCurManipPt sets the [Scene.CurManipPt]:
// currently selected manipulation control point
func (t *Scene) SetCurManipPt(v *ManipPt) *Scene {
	t.CurManipPt = v
	return t
}

// SetSelParams sets the [Scene.SelParams]:
// parameters for selection / manipulation box
func (t *Scene) SetSelParams(v SelParams) *Scene {
	t.SelParams = v
	return t
}

// SetTooltip sets the [Scene.Tooltip]
func (t *Scene) SetTooltip(v string) *Scene {
	t.Tooltip = v
	return t
}

// SceneViewType is the [gti.Type] for [SceneView]
var SceneViewType = gti.AddType(&gti.Type{
	Name:       "goki.dev/goki/xyzv.SceneView",
	ShortName:  "xyzv.SceneView",
	IDName:     "scene-view",
	Doc:        "SceneView provides a toolbar controller for an xyz.Scene,\nand manipulation abilities.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/goki/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &SceneView{},
})

// NewSceneView adds a new [SceneView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSceneView(par ki.Ki, name ...string) *SceneView {
	return par.NewChild(SceneViewType, name...).(*SceneView)
}

// KiType returns the [*gti.Type] of [SceneView]
func (t *SceneView) KiType() *gti.Type {
	return SceneViewType
}

// New returns a new [*SceneView] value
func (t *SceneView) New() ki.Ki {
	return &SceneView{}
}

// SetTooltip sets the [SceneView.Tooltip]
func (t *SceneView) SetTooltip(v string) *SceneView {
	t.Tooltip = v
	return t
}

// SetStackTop sets the [SceneView.StackTop]
func (t *SceneView) SetStackTop(v int) *SceneView {
	t.StackTop = v
	return t
}
